diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 00000000..17e84771
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,339 @@
+cmake_minimum_required(VERSION 3.16)
+
+# ---------------------------------------------------------------------------------------
+# Project / version
+# ---------------------------------------------------------------------------------------
+project(OpenRGB
+  VERSION 0.9.1
+  LANGUAGES CXX C
+)
+
+# C++17 (std::filesystem)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
+set(CMAKE_CXX_EXTENSIONS OFF)
+
+set(TARGET_NAME openrgb)
+
+# ---------------------------------------------------------------------------------------
+# Qt setup
+# ---------------------------------------------------------------------------------------
+set(QT_NEEDED_COMPONENTS Widgets DBus LinguistTools)
+
+find_package(Qt6 QUIET COMPONENTS ${QT_NEEDED_COMPONENTS})
+if(Qt6_FOUND)
+  set(QT_PACKAGE Qt6)
+  add_compile_definitions(_QT6)
+else()
+  find_package(Qt5 REQUIRED COMPONENTS ${QT_NEEDED_COMPONENTS})
+  set(QT_PACKAGE Qt5)
+endif()
+
+set(CMAKE_AUTOMOC ON)
+set(CMAKE_AUTOUIC ON)
+set(CMAKE_AUTORCC ON)
+
+# ---------------------------------------------------------------------------------------
+# Build info (Git and date)
+# ---------------------------------------------------------------------------------------
+if(DEFINED ENV{SOURCE_DATE_EPOCH})
+  execute_process(
+    COMMAND bash -lc "date -R -d @${SOURCE_DATE_EPOCH}"
+    OUTPUT_VARIABLE BUILDDATE_RAW OUTPUT_STRIP_TRAILING_WHITESPACE
+  )
+else()
+  execute_process(
+    COMMAND bash -lc "date -R"
+    OUTPUT_VARIABLE BUILDDATE_RAW OUTPUT_STRIP_TRAILING_WHITESPACE
+  )
+endif()
+
+find_package(Git QUIET)
+if(GIT_FOUND)
+  execute_process(COMMAND ${GIT_EXECUTABLE} log -n 1 --pretty=format:%H
+                  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+                  OUTPUT_VARIABLE GIT_COMMIT_ID_RAW OUTPUT_STRIP_TRAILING_WHITESPACE)
+  execute_process(COMMAND ${GIT_EXECUTABLE} log -n 1 --pretty=format:%ci
+                  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+                  OUTPUT_VARIABLE GIT_COMMIT_DATE_RAW OUTPUT_STRIP_TRAILING_WHITESPACE)
+  execute_process(COMMAND ${GIT_EXECUTABLE} branch --show-current
+                  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+                  OUTPUT_VARIABLE GIT_BRANCH_RAW OUTPUT_STRIP_TRAILING_WHITESPACE)
+endif()
+
+if(NOT GIT_COMMIT_ID_RAW)
+  set(GIT_COMMIT_ID_RAW "unknown")
+endif()
+if(NOT GIT_COMMIT_DATE_RAW)
+  set(GIT_COMMIT_DATE_RAW "${BUILDDATE_RAW}")
+endif()
+if(NOT GIT_BRANCH_RAW)
+  set(GIT_BRANCH_RAW "unknown")
+endif()
+
+add_compile_definitions(
+  VERSION_STRING="${PROJECT_VERSION}"
+  BUILDDATE_STRING="${BUILDDATE_RAW}"
+  GIT_COMMIT_ID="${GIT_COMMIT_ID_RAW}"
+  GIT_COMMIT_DATE="${GIT_COMMIT_DATE_RAW}"
+  GIT_BRANCH="${GIT_BRANCH_RAW}"
+)
+
+# ---------------------------------------------------------------------------------------
+# Dependencies (libusb, libe131)
+# ---------------------------------------------------------------------------------------
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(LIBUSB REQUIRED libusb-1.0)
+pkg_check_modules(LIBE131 libe131)
+set(USE_SYSTEM_LIBE131 ${LIBE131_FOUND})
+
+# ---------------------------------------------------------------------------------------
+# Includes
+# ---------------------------------------------------------------------------------------
+set(COMMON_INCLUDE_DIRS
+  ${CMAKE_SOURCE_DIR}
+  ${CMAKE_SOURCE_DIR}/dependencies/CRCpp
+  ${CMAKE_SOURCE_DIR}/dependencies/httplib
+  ${CMAKE_SOURCE_DIR}/dependencies/json
+  ${CMAKE_SOURCE_DIR}/dependencies/mdns
+  ${CMAKE_SOURCE_DIR}/dmiinfo
+  ${CMAKE_SOURCE_DIR}/hidapi_wrapper
+  ${CMAKE_SOURCE_DIR}/i2c_smbus
+  ${CMAKE_SOURCE_DIR}/i2c_tools
+  ${CMAKE_SOURCE_DIR}/interop
+  ${CMAKE_SOURCE_DIR}/net_port
+  ${CMAKE_SOURCE_DIR}/pci_ids
+  ${CMAKE_SOURCE_DIR}/scsiapi
+  ${CMAKE_SOURCE_DIR}/serial_port
+  ${CMAKE_SOURCE_DIR}/super_io
+  ${CMAKE_SOURCE_DIR}/AutoStart
+  ${CMAKE_SOURCE_DIR}/KeyboardLayoutManager
+  ${CMAKE_SOURCE_DIR}/RGBController
+  ${CMAKE_SOURCE_DIR}/qt
+  ${CMAKE_SOURCE_DIR}/SuspendResume
+  ${CMAKE_SOURCE_DIR}/dependencies/NVFC
+)
+
+# ---------------------------------------------------------------------------------------
+# Sources and headers
+# ---------------------------------------------------------------------------------------
+file(GLOB_RECURSE GUI_FORMS qt/*.ui)
+file(GLOB_RECURSE GUI_HEADERS qt/*.h)
+file(GLOB_RECURSE GUI_SOURCES qt/*.cpp)
+
+file(GLOB_RECURSE CTRL_HEADERS_ALL Controllers/*.h)
+file(GLOB_RECURSE CTRL_SOURCES_ALL Controllers/*.cpp)
+
+foreach(h ${CTRL_HEADERS_ALL})
+  if(h MATCHES "_Windows|_MacOS|_FreeBSD")
+    list(REMOVE_ITEM CTRL_HEADERS_ALL ${h})
+  endif()
+endforeach()
+foreach(s ${CTRL_SOURCES_ALL})
+  if(s MATCHES "_Windows|_MacOS|_FreeBSD")
+    list(REMOVE_ITEM CTRL_SOURCES_ALL ${s})
+  endif()
+endforeach()
+
+file(GLOB_RECURSE CTRL_HEADERS_LINUX Controllers/*_Linux*.h)
+file(GLOB_RECURSE CTRL_SOURCES_LINUX Controllers/*_Linux*.cpp)
+list(APPEND CTRL_HEADERS_ALL ${CTRL_HEADERS_LINUX})
+list(APPEND CTRL_SOURCES_ALL ${CTRL_SOURCES_LINUX})
+
+set(OTHER_HEADERS
+  Colors.h
+  dependencies/json/json.hpp
+  LogManager.h
+  NetworkClient.h
+  NetworkProtocol.h
+  NetworkServer.h
+  OpenRGBPluginInterface.h
+  ProfileManager.h
+  ResourceManager.h
+  SettingsManager.h
+  Detector.h
+  DeviceDetector.h
+  dmiinfo/dmiinfo.h
+  filesystem.h
+  hidapi_wrapper/hidapi_wrapper.h
+  i2c_smbus/i2c_smbus.h
+  i2c_tools/i2c_tools.h
+  interop/DeviceGuard.h
+  interop/DeviceGuardLock.h
+  interop/DeviceGuardManager.h
+  net_port/net_port.h
+  pci_ids/pci_ids.h
+  scsiapi/scsiapi.h
+  serial_port/find_usb_serial_port.h
+  serial_port/serial_port.h
+  StringUtils.h
+  super_io/super_io.h
+  SuspendResume/SuspendResume.h
+  AutoStart/AutoStart.h
+  KeyboardLayoutManager/KeyboardLayoutManager.h
+  RGBController/RGBController.h
+  RGBController/RGBController_Dummy.h
+  RGBController/RGBControllerKeyNames.h
+  RGBController/RGBController_Network.h
+  dependencies/NVFC/nvapi.h
+  i2c_smbus/i2c_smbus_linux.h
+  AutoStart/AutoStart-Linux.h
+  SuspendResume/SuspendResume_Linux_FreeBSD.h
+)
+
+set(OTHER_SOURCES
+  main.cpp
+  cli.cpp
+  dmiinfo/dmiinfo.cpp
+  LogManager.cpp
+  NetworkClient.cpp
+  NetworkProtocol.cpp
+  NetworkServer.cpp
+  ProfileManager.cpp
+  ResourceManager.cpp
+  SPDAccessor.cpp
+  SettingsManager.cpp
+  i2c_smbus/i2c_smbus.cpp
+  i2c_tools/i2c_tools.cpp
+  interop/DeviceGuard.cpp
+  interop/DeviceGuardLock.cpp
+  interop/DeviceGuardManager.cpp
+  net_port/net_port.cpp
+  serial_port/serial_port.cpp
+  StringUtils.cpp
+  super_io/super_io.cpp
+  AutoStart/AutoStart.cpp
+  KeyboardLayoutManager/KeyboardLayoutManager.cpp
+  RGBController/RGBController.cpp
+  RGBController/RGBController_Dummy.cpp
+  RGBController/RGBControllerKeyNames.cpp
+  RGBController/RGBController_Network.cpp
+  dependencies/NVFC/nvapi.cpp
+  i2c_smbus/i2c_smbus_linux.cpp
+  scsiapi/scsiapi_linux.c
+  serial_port/find_usb_serial_port_linux.cpp
+  AutoStart/AutoStart-Linux.cpp
+  SuspendResume/SuspendResume_Linux_FreeBSD.cpp
+)
+
+if(NOT USE_SYSTEM_LIBE131)
+  list(APPEND OTHER_SOURCES dependencies/libe131/src/e131.c)
+  list(APPEND COMMON_INCLUDE_DIRS ${CMAKE_SOURCE_DIR}/dependencies/libe131/src)
+endif()
+
+# ---------------------------------------------------------------------------------------
+# Executable
+# ---------------------------------------------------------------------------------------
+add_executable(${TARGET_NAME}
+  ${GUI_SOURCES}
+  ${CTRL_SOURCES_ALL}
+  ${OTHER_SOURCES}
+  ${GUI_HEADERS}
+  ${CTRL_HEADERS_ALL}
+  ${OTHER_HEADERS}
+  ${GUI_FORMS}
+)
+
+# ---------------------------------------------------------------------------------------
+# Include all controller subdirectories automatically
+# ---------------------------------------------------------------------------------------
+set(CONTROLLER_INCLUDE_DIRS "")
+foreach(header ${CTRL_HEADERS_ALL})
+  get_filename_component(DIR ${header} DIRECTORY)
+  list(APPEND CONTROLLER_INCLUDE_DIRS ${DIR})
+endforeach()
+list(REMOVE_DUPLICATES CONTROLLER_INCLUDE_DIRS)
+target_include_directories(${TARGET_NAME} PRIVATE ${CONTROLLER_INCLUDE_DIRS})
+
+target_include_directories(${TARGET_NAME} PRIVATE
+  ${COMMON_INCLUDE_DIRS}
+  ${LIBUSB_INCLUDE_DIRS}
+)
+
+target_link_libraries(${TARGET_NAME} PRIVATE
+  ${QT_PACKAGE}::Widgets
+  ${QT_PACKAGE}::DBus
+  ${LIBUSB_LIBRARIES}
+  dl
+)
+
+# ---------------------------------------------------------------------------------------
+# HIDAPI detection
+# ---------------------------------------------------------------------------------------
+find_package(hidapi QUIET COMPONENTS hidraw libusb)
+
+if(TARGET hidapi::hidraw)
+  message(STATUS "Using HIDAPI hidraw backend")
+  set(HIDAPI_TARGET hidapi::hidraw)
+elseif(TARGET hidapi::libusb)
+  message(STATUS "Using HIDAPI libusb backend")
+  set(HIDAPI_TARGET hidapi::libusb)
+elseif(TARGET hidapi::hidapi)
+  message(STATUS "Using generic HIDAPI backend")
+  set(HIDAPI_TARGET hidapi::hidapi)
+else()
+  message(WARNING "No system HIDAPI found — falling back to pkg-config")
+  find_package(PkgConfig REQUIRED)
+  pkg_check_modules(HIDAPI REQUIRED hidapi)
+  target_include_directories(${TARGET_NAME} PRIVATE ${HIDAPI_INCLUDE_DIRS})
+  set(HIDAPI_TARGET ${HIDAPI_LIBRARIES})
+endif()
+
+if(EXISTS "/usr/include/hidapi/hidapi.h")
+  target_include_directories(${TARGET_NAME} PRIVATE /usr/include/hidapi)
+endif()
+
+execute_process(
+  COMMAND bash -c "pkg-config --modversion hidapi-hidraw 2>/dev/null || echo 0.0.0"
+  OUTPUT_VARIABLE HIDAPI_HIDRAW_VERSION OUTPUT_STRIP_TRAILING_WHITESPACE
+)
+if(HIDAPI_HIDRAW_VERSION VERSION_GREATER_EQUAL 0.10.1)
+  add_compile_definitions(USE_HID_USAGE)
+endif()
+
+target_link_libraries(${TARGET_NAME} PRIVATE ${HIDAPI_TARGET})
+
+# ---------------------------------------------------------------------------------------
+# Remove -pipe from global flags (incompatible with -save-temps)
+# ---------------------------------------------------------------------------------------
+foreach(var CMAKE_C_FLAGS CMAKE_CXX_FLAGS CMAKE_C_FLAGS_RELEASE CMAKE_CXX_FLAGS_RELEASE
+            CMAKE_C_FLAGS_DEBUG CMAKE_CXX_FLAGS_DEBUG)
+  if(${var} MATCHES "-pipe")
+    string(REPLACE "-pipe" "" ${var} "${${var}}")
+    message(STATUS "Removed -pipe from ${var}: ${${var}}")
+  endif()
+endforeach()
+
+# ---------------------------------------------------------------------------------------
+# Optimization flags
+# ---------------------------------------------------------------------------------------
+if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
+  target_compile_options(${TARGET_NAME} PRIVATE
+    -Wno-implicit-fallthrough -Wno-psabi -Wno-unused-parameter
+    -Wno-sign-compare -Wno-unused-variable -Wno-unused-result -Wno-deprecated-declarations
+    -O3 -funroll-loops -fstrict-aliasing -ftree-vectorize -fprefetch-loop-arrays
+    -fomit-frame-pointer -fno-math-errno -save-temps
+  )
+  include(CheckIPOSupported)
+  check_ipo_supported(RESULT lto_ok OUTPUT lto_msg)
+  if(lto_ok)
+    set_property(TARGET ${TARGET_NAME} PROPERTY INTERPROCEDURAL_OPTIMIZATION TRUE)
+  endif()
+endif()
+
+# ---------------------------------------------------------------------------------------
+# Install paths
+# ---------------------------------------------------------------------------------------
+if(NOT DEFINED CMAKE_INSTALL_PREFIX)
+  set(CMAKE_INSTALL_PREFIX /usr CACHE PATH "Install prefix" FORCE)
+endif()
+
+set(OPENRGB_SYSTEM_PLUGIN_DIRECTORY "${CMAKE_INSTALL_PREFIX}/lib/openrgb/plugins")
+target_compile_definitions(${TARGET_NAME} PRIVATE
+  OPENRGB_SYSTEM_PLUGIN_DIRECTORY="${OPENRGB_SYSTEM_PLUGIN_DIRECTORY}"
+)
+
+install(TARGETS ${TARGET_NAME} RUNTIME DESTINATION bin)
+install(FILES qt/org.openrgb.OpenRGB.desktop DESTINATION share/applications)
+install(FILES qt/org.openrgb.OpenRGB.png DESTINATION share/icons/hicolor/128x128/apps)
+install(FILES qt/org.openrgb.OpenRGB.metainfo.xml DESTINATION share/metainfo)
diff --git a/Dockerfile b/Dockerfile
index b0a17604..d74f1a8e 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,26 +1,32 @@
-# Use a base image with the required development tools
-FROM ubuntu:22.04
+# Arch Linux base
+FROM archlinux:base
 
-ARG DEBIAN_FRONTEND=noninteractive
+# Actualiza e instala dependencias (Qt5 + build + libs)
+RUN pacman -Syu --noconfirm && \
+    pacman -S --noconfirm --needed \
+      base-devel \
+      git \
+      qt5-base \
+      qt5-tools \
+      qt5-svg \
+      qt5-declarative \
+      libusb \
+      hidapi \
+      mbedtls \
+      pkgconf \
+      which \
+      coreutils && \
+    # Limpia caché de paquetes para reducir tamaño
+    pacman -Scc --noconfirm
 
-# Install essential packages and dependencies
-RUN apt-get update && apt-get install -y \
-    git \
-    build-essential \
-    qtcreator \
-    qtbase5-dev \
-    qtchooser \
-    qt5-qmake \
-    qtbase5-dev-tools \
-    libusb-1.0-0-dev \
-    libhidapi-dev \
-    pkgconf \
-    libmbedtls-dev \
-    qttools5-dev-tools \
-    && rm -rf /var/lib/apt/lists/*
+# (Opcional) alias para qmake
+RUN ln -s /usr/bin/qmake-qt5 /usr/local/bin/qmake
 
-# Set the default command to clone, build, and copy the binary
-CMD ["/bin/bash", "-c", "\
+# Comando por defecto: construir
+# Nota: si no creaste /input/build en tiempo de build, móntalo en runtime.
+CMD bash -lc '\
     cd /input/build && \
-    qmake ../OpenRGB.pro && \
-    make -j$(nproc)"]
+    export QMAKE_MAKEFLAGS="-j$(nproc)" && \
+    qmake-qt5 ../OpenRGB.pro && \
+    make -j"$(nproc)" \
+'
diff --git a/OpenRGB.pro b/OpenRGB.pro
index 3d938d61..de56e73d 100644
--- a/OpenRGB.pro
+++ b/OpenRGB.pro
@@ -4,12 +4,6 @@
 #   Adam Honse (CalcProgrammer1)                        5/25/2020                               #
 #-----------------------------------------------------------------------------------------------#
 
-#-----------------------------------------------------------------------------------------------#
-# Qt Configuration                                                                              #
-#-----------------------------------------------------------------------------------------------#
-QT +=                                                                                           \
-    core                                                                                        \
-    gui                                                                                         \
 
 #-----------------------------------------------------------------------------------------------#
 # Set compiler to use C++17 to make std::filesystem available                                   #
@@ -36,10 +30,7 @@ TEMPLATE    = app
 #-----------------------------------------------------------------------------------------------#
 # Automatically generated build information                                                     #
 #-----------------------------------------------------------------------------------------------#
-win32:BUILDDATE         = $$system(date /t)
-linux:BUILDDATE         = $$system(date -R -d "@${SOURCE_DATE_EPOCH:-$(date +%s)}")
-freebsd:BUILDDATE       = $$system(date -j -R -r "${SOURCE_DATE_EPOCH:-$(date +%s)}")
-macx:BUILDDATE          = $$system(date -j -R -r "${SOURCE_DATE_EPOCH:-$(date +%s)}")
+BUILDDATE               = $$system(date -R -d "@${SOURCE_DATE_EPOCH:-$(date +%s)}")
 GIT_COMMIT_ID           = $$system(git log -n 1 --pretty=format:"%H")
 GIT_COMMIT_DATE         = $$system(git log -n 1 --pretty=format:"%ci")
 GIT_BRANCH              = $$system(git branch --show-current)
@@ -74,8 +65,7 @@ CONTROLLER_INCLUDES = $$unique(CONTROLLER_INCLUDES)
 
 #-----------------------------------------------------------------------------------------------#
 # Remove OS-specific files from the overall controller headers and sources lists                #
-# The suffixes _Windows, _Linux, _FreeBSD, and _MacOS are usable to denote that a file only     #
-# applies to one or more OSes.  The suffixes may be combined such as <file>_Windows_Linux.cpp.  #
+# Only Linux files are included                                                                 #
 #-----------------------------------------------------------------------------------------------#
 CONTROLLER_H_WINDOWS    = $$files("Controllers/*_Windows*.h",   true)
 CONTROLLER_CPP_WINDOWS  = $$files("Controllers/*_Windows*.cpp", true)
@@ -102,10 +92,7 @@ CONTROLLER_CPP         -= $$CONTROLLER_CPP_MACOS
 INCLUDEPATH +=                                                                                  \
     $$CONTROLLER_INCLUDES                                                                       \
     $$GUI_INCLUDES                                                                              \
-    dependencies/ColorWheel                                                                     \
     dependencies/CRCpp/                                                                         \
-    dependencies/hueplusplus-1.1.0/include                                                      \
-    dependencies/hueplusplus-1.1.0/include/hueplusplus                                          \
     dependencies/httplib                                                                        \
     dependencies/json/                                                                          \
     dependencies/mdns                                                                           \
@@ -129,14 +116,12 @@ HEADERS +=
     $$GUI_H                                                                                     \
     $$CONTROLLER_H                                                                              \
     Colors.h                                                                                    \
-    dependencies/ColorWheel/ColorWheel.h                                                        \
     dependencies/json/json.hpp                                                                  \
     LogManager.h                                                                                \
     NetworkClient.h                                                                             \
     NetworkProtocol.h                                                                           \
     NetworkServer.h                                                                             \
     OpenRGBPluginInterface.h                                                                    \
-    PluginManager.h                                                                             \
     ProfileManager.h                                                                            \
     ResourceManager.h                                                                           \
     SettingsManager.h                                                                           \
@@ -168,36 +153,6 @@ HEADERS +=
 SOURCES +=                                                                                      \
     $$GUI_CPP                                                                                   \
     $$CONTROLLER_CPP                                                                            \
-    dependencies/ColorWheel/ColorWheel.cpp                                                      \
-    dependencies/hueplusplus-1.1.0/src/Action.cpp                                               \
-    dependencies/hueplusplus-1.1.0/src/APICache.cpp                                             \
-    dependencies/hueplusplus-1.1.0/src/BaseDevice.cpp                                           \
-    dependencies/hueplusplus-1.1.0/src/BaseHttpHandler.cpp                                      \
-    dependencies/hueplusplus-1.1.0/src/Bridge.cpp                                               \
-    dependencies/hueplusplus-1.1.0/src/BridgeConfig.cpp                                         \
-    dependencies/hueplusplus-1.1.0/src/CLIPSensors.cpp                                          \
-    dependencies/hueplusplus-1.1.0/src/ColorUnits.cpp                                           \
-    dependencies/hueplusplus-1.1.0/src/EntertainmentMode.cpp                                    \
-    dependencies/hueplusplus-1.1.0/src/ExtendedColorHueStrategy.cpp                             \
-    dependencies/hueplusplus-1.1.0/src/ExtendedColorTemperatureStrategy.cpp                     \
-    dependencies/hueplusplus-1.1.0/src/Group.cpp                                                \
-    dependencies/hueplusplus-1.1.0/src/HueCommandAPI.cpp                                        \
-    dependencies/hueplusplus-1.1.0/src/HueDeviceTypes.cpp                                       \
-    dependencies/hueplusplus-1.1.0/src/HueException.cpp                                         \
-    dependencies/hueplusplus-1.1.0/src/Light.cpp                                                \
-    dependencies/hueplusplus-1.1.0/src/ModelPictures.cpp                                        \
-    dependencies/hueplusplus-1.1.0/src/NewDeviceList.cpp                                        \
-    dependencies/hueplusplus-1.1.0/src/Scene.cpp                                                \
-    dependencies/hueplusplus-1.1.0/src/Schedule.cpp                                             \
-    dependencies/hueplusplus-1.1.0/src/Sensor.cpp                                               \
-    dependencies/hueplusplus-1.1.0/src/SimpleBrightnessStrategy.cpp                             \
-    dependencies/hueplusplus-1.1.0/src/SimpleColorHueStrategy.cpp                               \
-    dependencies/hueplusplus-1.1.0/src/SimpleColorTemperatureStrategy.cpp                       \
-    dependencies/hueplusplus-1.1.0/src/StateTransaction.cpp                                     \
-    dependencies/hueplusplus-1.1.0/src/TimePattern.cpp                                          \
-    dependencies/hueplusplus-1.1.0/src/UPnP.cpp                                                 \
-    dependencies/hueplusplus-1.1.0/src/Utils.cpp                                                \
-    dependencies/hueplusplus-1.1.0/src/ZLLSensors.cpp                                           \
     main.cpp                                                                                    \
     cli.cpp                                                                                     \
     dmiinfo/dmiinfo.cpp                                                                         \
@@ -205,7 +160,6 @@ SOURCES +=
     NetworkClient.cpp                                                                           \
     NetworkProtocol.cpp                                                                         \
     NetworkServer.cpp                                                                           \
-    PluginManager.cpp                                                                           \
     ProfileManager.cpp                                                                          \
     ResourceManager.cpp                                                                         \
     SPDAccessor.cpp                                                                             \
@@ -226,9 +180,6 @@ SOURCES +=
     RGBController/RGBControllerKeyNames.cpp                                                     \
     RGBController/RGBController_Network.cpp                                                     \
 
-RESOURCES +=                                                                                    \
-    qt/resources.qrc                                                                            \
-
 #-----------------------------------------------------------------------------------------------#
 # General configuration to decide if in-tree dependencies are used or not
 #-----------------------------------------------------------------------------------------------#
@@ -237,15 +188,12 @@ RESOURCES +=
 !system_libe131:INCLUDEPATH += dependencies/libe131/src/
 
 #-----------------------------------------------------------------------------------------------#
-# General configuration out-of-tree dependencies if in-tree are not used for systems
-# who use pkg-config i.e. Unix-like. Also includes macOS as Homebrew uses pkg-config too.
+# General configuration out-of-tree dependencies if in-tree are not used                        #
 #-----------------------------------------------------------------------------------------------#
 
-unix {
-    system_libe131 {
-        CONFIG += link_pkgconfig
-        PKGCONFIG += libe131
-    }
+system_libe131 {
+    CONFIG += link_pkgconfig
+    PKGCONFIG += libe131
 }
 
 #-----------------------------------------------------------------------------------------------#
@@ -270,547 +218,125 @@ TRANSLATIONS +=
     qt/i18n/OpenRGB_zh_CN.ts                                                                    \
     qt/i18n/OpenRGB_zh_TW.ts                                                                    \
 
-#-----------------------------------------------------------------------------------------------#
-# Windows-specific Configuration                                                                #
-#-----------------------------------------------------------------------------------------------#
-win32:QMAKE_CXXFLAGS += /utf-8
-win32:INCLUDEPATH +=                                                                            \
-    dependencies/display-library/include                                                        \
-    dependencies/hidapi-win/include                                                             \
-    dependencies/winring0/include                                                               \
-    dependencies/libusb-1.0.27/include                                                          \
-    dependencies/mbedtls-2.28.8/include                                                         \
-    dependencies/NVFC                                                                           \
-    wmi/                                                                                        \
-
-win32:SOURCES += $$CONTROLLER_CPP_WINDOWS
-
-win32:SOURCES +=                                                                                \
-    dependencies/hueplusplus-1.1.0/src/WinHttpHandler.cpp                                       \
-    dependencies/mbedtls-2.28.8/library/aes.c                                                   \
-    dependencies/mbedtls-2.28.8/library/aesni.c                                                 \
-    dependencies/mbedtls-2.28.8/library/arc4.c                                                  \
-    dependencies/mbedtls-2.28.8/library/aria.c                                                  \
-    dependencies/mbedtls-2.28.8/library/asn1parse.c                                             \
-    dependencies/mbedtls-2.28.8/library/asn1write.c                                             \
-    dependencies/mbedtls-2.28.8/library/base64.c                                                \
-    dependencies/mbedtls-2.28.8/library/bignum.c                                                \
-    dependencies/mbedtls-2.28.8/library/blowfish.c                                              \
-    dependencies/mbedtls-2.28.8/library/camellia.c                                              \
-    dependencies/mbedtls-2.28.8/library/ccm.c                                                   \
-    dependencies/mbedtls-2.28.8/library/certs.c                                                 \
-    dependencies/mbedtls-2.28.8/library/chacha20.c                                              \
-    dependencies/mbedtls-2.28.8/library/chachapoly.c                                            \
-    dependencies/mbedtls-2.28.8/library/cipher.c                                                \
-    dependencies/mbedtls-2.28.8/library/cipher_wrap.c                                           \
-    dependencies/mbedtls-2.28.8/library/cmac.c                                                  \
-    dependencies/mbedtls-2.28.8/library/constant_time.c                                         \
-    dependencies/mbedtls-2.28.8/library/ctr_drbg.c                                              \
-    dependencies/mbedtls-2.28.8/library/debug.c                                                 \
-    dependencies/mbedtls-2.28.8/library/des.c                                                   \
-    dependencies/mbedtls-2.28.8/library/dhm.c                                                   \
-    dependencies/mbedtls-2.28.8/library/ecdh.c                                                  \
-    dependencies/mbedtls-2.28.8/library/ecdsa.c                                                 \
-    dependencies/mbedtls-2.28.8/library/ecjpake.c                                               \
-    dependencies/mbedtls-2.28.8/library/ecp.c                                                   \
-    dependencies/mbedtls-2.28.8/library/ecp_curves.c                                            \
-    dependencies/mbedtls-2.28.8/library/entropy.c                                               \
-    dependencies/mbedtls-2.28.8/library/entropy_poll.c                                          \
-    dependencies/mbedtls-2.28.8/library/error.c                                                 \
-    dependencies/mbedtls-2.28.8/library/gcm.c                                                   \
-    dependencies/mbedtls-2.28.8/library/havege.c                                                \
-    dependencies/mbedtls-2.28.8/library/hkdf.c                                                  \
-    dependencies/mbedtls-2.28.8/library/hmac_drbg.c                                             \
-    dependencies/mbedtls-2.28.8/library/md2.c                                                   \
-    dependencies/mbedtls-2.28.8/library/md4.c                                                   \
-    dependencies/mbedtls-2.28.8/library/md5.c                                                   \
-    dependencies/mbedtls-2.28.8/library/md.c                                                    \
-    dependencies/mbedtls-2.28.8/library/memory_buffer_alloc.c                                   \
-    dependencies/mbedtls-2.28.8/library/mps_reader.c                                            \
-    dependencies/mbedtls-2.28.8/library/mps_trace.c                                             \
-    dependencies/mbedtls-2.28.8/library/net_sockets.c                                           \
-    dependencies/mbedtls-2.28.8/library/nist_kw.c                                               \
-    dependencies/mbedtls-2.28.8/library/oid.c                                                   \
-    dependencies/mbedtls-2.28.8/library/padlock.c                                               \
-    dependencies/mbedtls-2.28.8/library/pem.c                                                   \
-    dependencies/mbedtls-2.28.8/library/pk.c                                                    \
-    dependencies/mbedtls-2.28.8/library/pkcs11.c                                                \
-    dependencies/mbedtls-2.28.8/library/pkcs12.c                                                \
-    dependencies/mbedtls-2.28.8/library/pkcs5.c                                                 \
-    dependencies/mbedtls-2.28.8/library/pkparse.c                                               \
-    dependencies/mbedtls-2.28.8/library/pk_wrap.c                                               \
-    dependencies/mbedtls-2.28.8/library/pkwrite.c                                               \
-    dependencies/mbedtls-2.28.8/library/platform.c                                              \
-    dependencies/mbedtls-2.28.8/library/platform_util.c                                         \
-    dependencies/mbedtls-2.28.8/library/poly1305.c                                              \
-    dependencies/mbedtls-2.28.8/library/psa_crypto_aead.c                                       \
-    dependencies/mbedtls-2.28.8/library/psa_crypto.c                                            \
-    dependencies/mbedtls-2.28.8/library/psa_crypto_cipher.c                                     \
-    dependencies/mbedtls-2.28.8/library/psa_crypto_client.c                                     \
-    dependencies/mbedtls-2.28.8/library/psa_crypto_driver_wrappers.c                            \
-    dependencies/mbedtls-2.28.8/library/psa_crypto_ecp.c                                        \
-    dependencies/mbedtls-2.28.8/library/psa_crypto_hash.c                                       \
-    dependencies/mbedtls-2.28.8/library/psa_crypto_mac.c                                        \
-    dependencies/mbedtls-2.28.8/library/psa_crypto_rsa.c                                        \
-    dependencies/mbedtls-2.28.8/library/psa_crypto_se.c                                         \
-    dependencies/mbedtls-2.28.8/library/psa_crypto_slot_management.c                            \
-    dependencies/mbedtls-2.28.8/library/psa_crypto_storage.c                                    \
-    dependencies/mbedtls-2.28.8/library/psa_its_file.c                                          \
-    dependencies/mbedtls-2.28.8/library/ripemd160.c                                             \
-    dependencies/mbedtls-2.28.8/library/rsa.c                                                   \
-    dependencies/mbedtls-2.28.8/library/rsa_internal.c                                          \
-    dependencies/mbedtls-2.28.8/library/sha1.c                                                  \
-    dependencies/mbedtls-2.28.8/library/sha256.c                                                \
-    dependencies/mbedtls-2.28.8/library/sha512.c                                                \
-    dependencies/mbedtls-2.28.8/library/ssl_cache.c                                             \
-    dependencies/mbedtls-2.28.8/library/ssl_ciphersuites.c                                      \
-    dependencies/mbedtls-2.28.8/library/ssl_cli.c                                               \
-    dependencies/mbedtls-2.28.8/library/ssl_cookie.c                                            \
-    dependencies/mbedtls-2.28.8/library/ssl_msg.c                                               \
-    dependencies/mbedtls-2.28.8/library/ssl_srv.c                                               \
-    dependencies/mbedtls-2.28.8/library/ssl_ticket.c                                            \
-    dependencies/mbedtls-2.28.8/library/ssl_tls13_keys.c                                        \
-    dependencies/mbedtls-2.28.8/library/ssl_tls.c                                               \
-    dependencies/mbedtls-2.28.8/library/threading.c                                             \
-    dependencies/mbedtls-2.28.8/library/timing.c                                                \
-    dependencies/mbedtls-2.28.8/library/version.c                                               \
-    dependencies/mbedtls-2.28.8/library/version_features.c                                      \
-    dependencies/mbedtls-2.28.8/library/x509.c                                                  \
-    dependencies/mbedtls-2.28.8/library/x509_create.c                                           \
-    dependencies/mbedtls-2.28.8/library/x509_crl.c                                              \
-    dependencies/mbedtls-2.28.8/library/x509_crt.c                                              \
-    dependencies/mbedtls-2.28.8/library/x509_csr.c                                              \
-    dependencies/mbedtls-2.28.8/library/x509write_crt.c                                         \
-    dependencies/mbedtls-2.28.8/library/x509write_csr.c                                         \
-    dependencies/mbedtls-2.28.8/library/xtea.c                                                  \
-    dependencies/NVFC/nvapi.cpp                                                                 \
-    i2c_smbus/i2c_smbus_amdadl.cpp                                                              \
-    i2c_smbus/i2c_smbus_i801.cpp                                                                \
-    i2c_smbus/i2c_smbus_nct6775.cpp                                                             \
-    i2c_smbus/i2c_smbus_nvapi.cpp                                                               \
-    i2c_smbus/i2c_smbus_piix4.cpp                                                               \
-    scsiapi/scsiapi_windows.c                                                                   \
-    serial_port/find_usb_serial_port_win.cpp                                                    \
-    SuspendResume/SuspendResume_Windows.cpp                                                     \
-    wmi/wmi.cpp                                                                                 \
-    AutoStart/AutoStart-Windows.cpp                                                             \
-
-win32:HEADERS += $$CONTROLLER_H_WINDOWS
-
-win32:HEADERS +=                                                                                \
-    dependencies/display-library/include/adl_defines.h                                          \
-    dependencies/display-library/include/adl_sdk.h                                              \
-    dependencies/display-library/include/adl_structures.h                                       \
-    dependencies/winring0/include/OlsApi.h                                                      \
-    dependencies/NVFC/nvapi.h                                                                   \
-    i2c_smbus/i2c_smbus_i801.h                                                                  \
-    i2c_smbus/i2c_smbus_nct6775.h                                                               \
-    i2c_smbus/i2c_smbus_nvapi.h                                                                 \
-    i2c_smbus/i2c_smbus_piix4.h                                                                 \
-    wmi/wmi.h                                                                                   \
-    AutoStart/AutoStart-Windows.h                                                               \
-    SuspendResume/SuspendResume_Windows.h                                                       \
-
-win32:contains(QMAKE_TARGET.arch, x86_64) {
-    LIBS +=                                                                                     \
-        -lws2_32                                                                                \
-        -liphlpapi                                                                              \
-        -L"$$PWD/dependencies/winring0/x64/" -lWinRing0x64                                      \
-        -L"$$PWD/dependencies/libusb-1.0.27/VS2019/MS64/dll" -llibusb-1.0                       \
-        -L"$$PWD/dependencies/hidapi-win/x64/" -lhidapi                                         \
-}
-
-win32:contains(QMAKE_TARGET.arch, x86) {
-    LIBS +=                                                                                     \
-        -lws2_32                                                                                \
-        -liphlpapi                                                                              \
-        -L"$$PWD/dependencies/winring0/Win32/" -lWinRing0                                       \
-        -L"$$PWD/dependencies/libusb-1.0.27/VS2019/MS32/dll" -llibusb-1.0                       \
-        -L"$$PWD/dependencies/hidapi-win/x86/" -lhidapi                                         \
-}
-
-win32:DEFINES -=                                                                                \
-    UNICODE
-
-win32:DEFINES +=                                                                                \
-    USE_HID_USAGE                                                                               \
-    _MBCS                                                                                       \
-    WIN32                                                                                       \
-    _CRT_SECURE_NO_WARNINGS                                                                     \
-    _WINSOCK_DEPRECATED_NO_WARNINGS                                                             \
-    WIN32_LEAN_AND_MEAN                                                                         \
-
-win32:RC_ICONS +=                                                                               \
-    qt/OpenRGB.ico
-
-#-----------------------------------------------------------------------------------------------#
-# Windows GitLab CI Configuration                                                               #
-#-----------------------------------------------------------------------------------------------#
-win32:CONFIG(debug, debug|release) {
-    win32:DESTDIR = debug
-}
-
-win32:CONFIG(release, debug|release) {
-    win32:DESTDIR = release
-}
-
-win32:OBJECTS_DIR = _intermediate_$$DESTDIR/.obj
-win32:MOC_DIR     = _intermediate_$$DESTDIR/.moc
-win32:RCC_DIR     = _intermediate_$$DESTDIR/.qrc
-win32:UI_DIR      = _intermediate_$$DESTDIR/.ui
-
-#-----------------------------------------------------------------------------------------------#
-# Copy dependencies to output directory                                                         #
-#-----------------------------------------------------------------------------------------------#
-
-win32:contains(QMAKE_TARGET.arch, x86_64) {
-    copydata.commands += $(COPY_FILE) \"$$shell_path($$PWD/dependencies/winring0/x64/WinRing0x64.dll                )\" \"$$shell_path($$DESTDIR)\" $$escape_expand(\n\t)
-    copydata.commands += $(COPY_FILE) \"$$shell_path($$PWD/dependencies/winring0/x64/WinRing0x64.sys                )\" \"$$shell_path($$DESTDIR)\" $$escape_expand(\n\t)
-    copydata.commands += $(COPY_FILE) \"$$shell_path($$PWD/dependencies/libusb-1.0.27/VS2019/MS64/dll/libusb-1.0.dll)\" \"$$shell_path($$DESTDIR)\" $$escape_expand(\n\t)
-    copydata.commands += $(COPY_FILE) \"$$shell_path($$PWD/dependencies/hidapi-win/x64/hidapi.dll                   )\" \"$$shell_path($$DESTDIR)\" $$escape_expand(\n\t)
-    first.depends = $(first) copydata
-    export(first.depends)
-    export(copydata.commands)
-    QMAKE_EXTRA_TARGETS += first copydata
-}
-
-win32:contains(QMAKE_TARGET.arch, x86) {
-    copydata.commands += $(COPY_FILE) \"$$shell_path($$PWD/dependencies/winring0/Win32/WinRing0.dll                 )\" \"$$shell_path($$DESTDIR)\" $$escape_expand(\n\t)
-    copydata.commands += $(COPY_FILE) \"$$shell_path($$PWD/dependencies/winring0/Win32/WinRing0.sys                 )\" \"$$shell_path($$DESTDIR)\" $$escape_expand(\n\t)
-    copydata.commands += $(COPY_FILE) \"$$shell_path($$PWD/dependencies/winring0/x64/WinRing0x64.sys                )\" \"$$shell_path($$DESTDIR)\" $$escape_expand(\n\t)
-    copydata.commands += $(COPY_FILE) \"$$shell_path($$PWD/dependencies/libusb-1.0.27/VS2019/MS32/dll/libusb-1.0.dll)\" \"$$shell_path($$DESTDIR)\" $$escape_expand(\n\t)
-    copydata.commands += $(COPY_FILE) \"$$shell_path($$PWD/dependencies/hidapi-win/x86/hidapi.dll                   )\" \"$$shell_path($$DESTDIR)\" $$escape_expand(\n\t)
-
-    first.depends = $(first) copydata
-    export(first.depends)
-    export(copydata.commands)
-    QMAKE_EXTRA_TARGETS += first copydata
-}
 
 #-----------------------------------------------------------------------------------------------#
 # Linux-specific Configuration                                                                  #
 #-----------------------------------------------------------------------------------------------#
-contains(QMAKE_PLATFORM, linux) {
-    CONFIG += link_pkgconfig
-
-    PKGCONFIG +=                                                                                \
-    libusb-1.0
-
-    TARGET = $$lower($$TARGET)
-
-    HEADERS += $$CONTROLLER_H_LINUX
+CONFIG += link_pkgconfig
 
-    HEADERS +=                                                                                  \
-    dependencies/NVFC/nvapi.h                                                                   \
-    i2c_smbus/i2c_smbus_linux.h                                                                 \
-    AutoStart/AutoStart-Linux.h                                                                 \
-    SuspendResume/SuspendResume_Linux_FreeBSD.h                                                 \
+PKGCONFIG +=                                                                                \
+libusb-1.0
 
-    INCLUDEPATH +=                                                                              \
-    dependencies/NVFC                                                                           \
-    /usr/include/mbedtls2/                                                                      \
+TARGET = $$lower($$TARGET)
 
-    LIBS +=                                                                                     \
-    -L/usr/lib/mbedtls2/                                                                        \
-    -lmbedx509                                                                                  \
-    -lmbedtls                                                                                   \
-    -lmbedcrypto                                                                                \
-    -ldl                                                                                        \
+HEADERS += $$CONTROLLER_H_LINUX
 
-    COMPILER_VERSION = $$system($$QMAKE_CXX " -dumpversion")
-    if (!versionAtLeast(COMPILER_VERSION, "9")) {
-         LIBS += -lstdc++fs
-    }
+HEADERS +=                                                                                  \
+dependencies/NVFC/nvapi.h                                                                   \
+i2c_smbus/i2c_smbus_linux.h                                                                 \
+AutoStart/AutoStart-Linux.h                                                                 \
+SuspendResume/SuspendResume_Linux_FreeBSD.h                                                 \
 
-    QT += dbus
-
-    QMAKE_CXXFLAGS += -Wno-implicit-fallthrough -Wno-psabi
-
-    #-------------------------------------------------------------------------------------------#
-    # Determine which hidapi to use based on availability                                       #
-    #   Prefer hidraw backend, then libusb                                                      #
-    #-------------------------------------------------------------------------------------------#
-    packagesExist(hidapi-hidraw) {
-        PKGCONFIG += hidapi-hidraw
-
-        #---------------------------------------------------------------------------------------#
-        # hidapi-hidraw >= 0.10.1 supports USAGE/USAGE_PAGE                                     #
-        # Define USE_HID_USAGE if hidapi-hidraw supports it                                     #
-        #---------------------------------------------------------------------------------------#
-        HIDAPI_HIDRAW_VERSION = $$system($$PKG_CONFIG --modversion hidapi-hidraw)
-        if(versionAtLeast(HIDAPI_HIDRAW_VERSION, "0.10.1")) {
-            DEFINES += USE_HID_USAGE
-        }
-    } else {
-        packagesExist(hidapi-libusb) {
-            PKGCONFIG += hidapi-libusb
-        } else {
-            PKGCONFIG += hidapi
-        }
-    }
-
-    SOURCES += $$CONTROLLER_CPP_LINUX
-
-    SOURCES +=                                                                                  \
-    dependencies/hueplusplus-1.1.0/src/LinHttpHandler.cpp                                       \
-    dependencies/NVFC/nvapi.cpp                                                                 \
-    i2c_smbus/i2c_smbus_linux.cpp                                                               \
-    scsiapi/scsiapi_linux.c                                                                     \
-    serial_port/find_usb_serial_port_linux.cpp                                                  \
-    AutoStart/AutoStart-Linux.cpp                                                               \
-    SuspendResume/SuspendResume_Linux_FreeBSD.cpp                                               \
-
-    #-------------------------------------------------------------------------------------------#
-    # Set up install paths                                                                      #
-    # These install paths are used for AppImage and .deb packaging                              #
-    #-------------------------------------------------------------------------------------------#
-    isEmpty(PREFIX) {
-        PREFIX = /usr
-    }
+INCLUDEPATH +=                                                                              \
+dependencies/NVFC                                                                           \
 
-    !defined(OPENRGB_SYSTEM_PLUGIN_DIRECTORY, var):OPENRGB_SYSTEM_PLUGIN_DIRECTORY =            \
-        "$$PREFIX/lib/openrgb/plugins"                                                          \
-
-    DEFINES +=                                                                                  \
-        OPENRGB_SYSTEM_PLUGIN_DIRECTORY=\\"\"\"$$OPENRGB_SYSTEM_PLUGIN_DIRECTORY\\"\"\"         \
-
-    #-------------------------------------------------------------------------------------------#
-    # Custom target for dynamically created udev_rules                                          #
-    #   Ordinarily you would add the 'udev_rules' target to both QMAKE_EXTRA_TARGETS to add a   #
-    #   rule in the Makefile and PRE_TARGETDEPS to ensure it is a dependency of the TARGET      #
-    #                                                                                           #
-    #   ie. QMAKE_EXTRA_TARGETS += udev_rules                                                   #
-    #       PRE_TARGETDEPS      += udev_rules                                                   #
-    #-------------------------------------------------------------------------------------------#
-    CONFIG(release, debug|release) {
-        udev_rules.CONFIG       = no_check_exist
-        udev_rules.target       = 60-openrgb.rules
-        udev_rules.path         = $$PREFIX/lib/udev/rules.d/
-
-        exists($$udev_rules.target) {
-            message($$udev_rules.target " - UDEV rules file exists. Removing from build")
-            udev_rules.files    = $$udev_rules.target
-        } else {
-            message($$udev_rules.target " - UDEV rules file missing. Adding script to build")
-            #-----------------------------------------------------------------------------------#
-            # This is a compiler config flag to save the preproccessed .ii & .s                 #
-            #   files so as to automatically process the UDEV rules and the Supported Devices   #
-            #-----------------------------------------------------------------------------------#
-            QMAKE_CXXFLAGS+=-save-temps
-            QMAKE_CXXFLAGS-=-pipe
-            udev_rules.extra    = $$PWD/scripts/build-udev-rules.sh $$PWD $$GIT_COMMIT_ID
-            udev_rules.files    = $$OUT_PWD/60-openrgb.rules
-        }
-    }
+LIBS +=                                                                                     \
+-ldl                                                                                        \
 
-    #-------------------------------------------------------------------------------------------#
-    # Add static files to installation                                                          #
-    #-------------------------------------------------------------------------------------------#
-    target.path=$$PREFIX/bin/
-    desktop.path=$$PREFIX/share/applications/
-    desktop.files+=qt/org.openrgb.OpenRGB.desktop
-    icon.path=$$PREFIX/share/icons/hicolor/128x128/apps/
-    icon.files+=qt/org.openrgb.OpenRGB.png
-    metainfo.path=$$PREFIX/share/metainfo/
-    metainfo.files+=qt/org.openrgb.OpenRGB.metainfo.xml
-    INSTALLS += target desktop icon metainfo udev_rules
+COMPILER_VERSION = $$system($$QMAKE_CXX " -dumpversion")
+if (!versionAtLeast(COMPILER_VERSION, "9")) {
+     LIBS += -lstdc++fs
 }
 
-#-----------------------------------------------------------------------------------------------#
-# FreeBSD-specific Configuration                                                                #
-#-----------------------------------------------------------------------------------------------#
-contains(QMAKE_PLATFORM, freebsd) {
-    CONFIG += link_pkgconfig
-
-    PKGCONFIG +=                                                                                \
-    libusb-1.0
-
-    TARGET = $$lower($$TARGET)
-
-    HEADERS += $$CONTROLLER_H_FREEBSD
-
-    HEADERS +=                                                                                  \
-    AutoStart/AutoStart-FreeBSD.h                                                               \
-    SuspendResume/SuspendResume_Linux_FreeBSD.h                                                 \
-
-    HEADERS -=                                                                                  \
-    Controllers/SeagateController/RGBController_Seagate.h                                       \
-    Controllers/SeagateController/SeagateController.h                                           \
-    Controllers/ENESMBusController/ENESMBusInterface/ENESMBusInterface_ROGArion.h               \
-    $$CONTROLLER_H_WINDOWS                                                                      \
-
-    LIBS +=                                                                                     \
-    -lmbedx509                                                                                  \
-    -lmbedtls                                                                                   \
-    -lmbedcrypto                                                                                \
-
-    COMPILER_VERSION = $$system($$QMAKE_CXX " -dumpversion")
-    if (!versionAtLeast(COMPILER_VERSION, "9")) {
-         LIBS += -lstdc++fs
+QT += dbus
+
+QMAKE_CXXFLAGS += -Wno-implicit-fallthrough -Wno-psabi -Wno-unused-parameter -Wno-sign-compare -Wno-unused-variable -Wno-unused-result -Wno-class-memaccess -O3 -flto=auto -funroll-loops -fstrict-aliasing -ftree-vectorize -fprefetch-loop-arrays -fomit-frame-pointer -fno-math-errno
+QMAKE_LFLAGS += -s -flto=auto
+
+#-------------------------------------------------------------------------------------------#
+# Determine which hidapi to use based on availability                                       #
+#   Prefer hidraw backend, then libusb                                                      #
+#-------------------------------------------------------------------------------------------#
+packagesExist(hidapi-hidraw) {
+    PKGCONFIG += hidapi-hidraw
+
+    #---------------------------------------------------------------------------------------#
+    # hidapi-hidraw >= 0.10.1 supports USAGE/USAGE_PAGE                                     #
+    # Define USE_HID_USAGE if hidapi-hidraw supports it                                     #
+    #---------------------------------------------------------------------------------------#
+    HIDAPI_HIDRAW_VERSION = $$system($$PKG_CONFIG --modversion hidapi-hidraw)
+    if(versionAtLeast(HIDAPI_HIDRAW_VERSION, "0.10.1")) {
+        DEFINES += USE_HID_USAGE
     }
-
-    QT += dbus
-
-    #-------------------------------------------------------------------------------------------#
-    # Determine which hidapi to use based on availability                                       #
-    #   Prefer hidraw backend, then libusb                                                      #
-    #-------------------------------------------------------------------------------------------#
-    packagesExist(hidapi-hidraw) {
-        PKGCONFIG += hidapi-hidraw
-
-        #---------------------------------------------------------------------------------------#
-        # hidapi-hidraw >= 0.10.1 supports USAGE/USAGE_PAGE                                     #
-        # Define USE_HID_USAGE if hidapi-hidraw supports it                                     #
-        #---------------------------------------------------------------------------------------#
-        packagesExist(hidapi-hidraw>=0.10.1) {
-            DEFINES += USE_HID_USAGE
-        }
+} else {
+    packagesExist(hidapi-libusb) {
+        PKGCONFIG += hidapi-libusb
     } else {
-        packagesExist(hidapi-libusb) {
-            PKGCONFIG += hidapi-libusb
-        } else {
-            PKGCONFIG += hidapi
-        }
+        PKGCONFIG += hidapi
     }
-
-    SOURCES += $$CONTROLLER_CPP_FREEBSD
-
-    SOURCES +=                                                                                  \
-    dependencies/hueplusplus-1.1.0/src/LinHttpHandler.cpp                                       \
-    serial_port/find_usb_serial_port_linux.cpp                                                  \
-    AutoStart/AutoStart-FreeBSD.cpp                                                             \
-    SuspendResume/SuspendResume_Linux_FreeBSD.cpp                                               \
-
-    SOURCES -=                                                                                  \
-    Controllers/SeagateController/RGBController_Seagate.cpp                                     \
-    Controllers/SeagateController/SeagateController.cpp                                         \
-    Controllers/SeagateController/SeagateControllerDetect.cpp                                   \
-    Controllers/ENESMBusController/ROGArionDetect.cpp                                           \
-    Controllers/ENESMBusController/ENESMBusInterface/ENESMBusInterface_ROGArion.cpp             \
-
-    #-------------------------------------------------------------------------------------------#
-    # Set up install paths                                                                      #
-    # These install paths are used for AppImage and .deb packaging                              #
-    #-------------------------------------------------------------------------------------------#
-    isEmpty(PREFIX) {
-        PREFIX = /usr
-    }
-
-    target.path=$$PREFIX/bin/
-    desktop.path=$$PREFIX/share/applications/
-    desktop.files+=qt/org.openrgb.OpenRGB.desktop
-    icon.path=$$PREFIX/share/icons/hicolor/128x128/apps/
-    icon.files+=qt/org.openrgb.OpenRGB.png
-    metainfo.path=$$PREFIX/share/metainfo/
-    metainfo.files+=qt/org.openrgb.OpenRGB.metainfo.xml
-    rules.path=$$PREFIX/lib/udev/rules.d/
-    rules.files+=60-openrgb.rules
-    INSTALLS += target desktop icon metainfo rules
-}
-
-unix:!macx:CONFIG(asan) {
-    message("ASan Mode")
-    QMAKE_CFLAGS=-fsanitize=address
-    QMAKE_CXXFLAGS=-fsanitize=address
-    QMAKE_LFLAGS=-fsanitize=address
-}
-
-#-----------------------------------------------------------------------------------------------#
-# MacOS-specific Configuration                                                                  #
-#-----------------------------------------------------------------------------------------------#
-QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.15
-
-#-----------------------------------------------------------------------------------------------#
-# Common MacOS definitions                                                                      #
-#-----------------------------------------------------------------------------------------------#
-macx {
-    CONFIG += link_pkgconfig
-
-    PKGCONFIG +=                                                                                \
-    libusb-1.0                                                                                  \
-    hidapi
-
-    DEFINES +=                                                                                  \
-    USE_HID_USAGE                                                                               \
-
-    QMAKE_CXXFLAGS +=                                                                           \
-    -Wno-narrowing                                                                              \
-
-    HEADERS +=                                                                                  \
-    AutoStart/AutoStart-MacOS.h                                                                 \
-    qt/macutils.h                                                                               \
-    SuspendResume/SuspendResume_MacOS.h                                                         \
-
-    HEADERS += $$CONTROLLER_H_MACOS
-
-    SOURCES +=                                                                                  \
-    dependencies/hueplusplus-1.1.0/src/LinHttpHandler.cpp                                       \
-    serial_port/find_usb_serial_port_macos.cpp                                                  \
-    AutoStart/AutoStart-MacOS.cpp                                                               \
-    qt/macutils.mm                                                                              \
-    SuspendResume/SuspendResume_MacOS.cpp                                                       \
-
-    SOURCES += $$CONTROLLER_CPP_MACOS
-
-    # Use mbedtls v2 instead of latest
-    MBEDTLS_PREFIX = $$system(brew --prefix mbedtls@2)
-
-    INCLUDEPATH +=                                                                              \
-    $$MBEDTLS_PREFIX/include                                                                    \
-
-    LIBS +=                                                                                     \
-    -lmbedx509                                                                                  \
-    -lmbedcrypto                                                                                \
-    -lmbedtls                                                                                   \
-    -L$$MBEDTLS_PREFIX/lib
-
-    ICON = qt/OpenRGB.icns
-
-    info_plist.input = mac/Info.plist.in
-    info_plist.output = $$OUT_PWD/Info.plist
-    QMAKE_SUBSTITUTES += info_plist
-    QMAKE_INFO_PLIST = $$OUT_PWD/Info.plist
 }
 
-#-----------------------------------------------------------------------------------------------#
-# Apple Silicon (arm64) Homebrew installs at /opt/homebrew                                      #
-#-----------------------------------------------------------------------------------------------#
-macx:contains(QMAKE_HOST.arch, arm64) {
-    INCLUDEPATH +=                                                                              \
-    /opt/homebrew/include                                                                       \
-
-    SOURCES +=                                                                                  \
-    scsiapi/scsiapi_macos.c                                                                     \
-
-    LIBS +=                                                                                     \
-    -L/opt/homebrew/lib                                                                         \
+SOURCES += $$CONTROLLER_CPP_LINUX
+
+SOURCES +=                                                                                  \
+dependencies/NVFC/nvapi.cpp                                                                 \
+i2c_smbus/i2c_smbus_linux.cpp                                                               \
+scsiapi/scsiapi_linux.c                                                                     \
+serial_port/find_usb_serial_port_linux.cpp                                                  \
+AutoStart/AutoStart-Linux.cpp                                                               \
+SuspendResume/SuspendResume_Linux_FreeBSD.cpp                                               \
+
+#-------------------------------------------------------------------------------------------#
+# Set up install paths                                                                      #
+# These install paths are used for AppImage and .deb packaging                              #
+#-------------------------------------------------------------------------------------------#
+isEmpty(PREFIX) {
+    PREFIX = /usr
 }
 
-#-----------------------------------------------------------------------------------------------#
-# Intel (x86_64) Homebrew installs at /usr/local/lib                                            #
-#-----------------------------------------------------------------------------------------------#
-macx:contains(QMAKE_HOST.arch, x86_64) {
-    INCLUDEPATH +=                                                                              \
-    dependencies/macUSPCIO                                                                      \
-    /usr/local/include                                                                          \
-    /usr/local/homebrew/include                                                                 \
-
-    SOURCES +=                                                                                  \
-    i2c_smbus/i2c_smbus_i801.cpp                                                                \
-    scsiapi/scsiapi_macos.c                                                                     \
-
-    HEADERS +=                                                                                  \
-    dependencies/macUSPCIO/macUSPCIOAccess.h                                                    \
-    i2c_smbus/i2c_smbus_i801.h                                                                  \
-
-    LIBS +=                                                                                     \
-    -L/usr/local/lib                                                                            \
-    -L/usr/local/homebrew/lib                                                                   \
-
-    DEFINES +=                                                                                  \
-    _MACOSX_X86_X64                                                                             \
+!defined(OPENRGB_SYSTEM_PLUGIN_DIRECTORY, var):OPENRGB_SYSTEM_PLUGIN_DIRECTORY =            \
+    "$$PREFIX/lib/openrgb/plugins"                                                          \
+
+DEFINES +=                                                                                  \
+    OPENRGB_SYSTEM_PLUGIN_DIRECTORY=\\"\"\"$$OPENRGB_SYSTEM_PLUGIN_DIRECTORY\\"\"\"         \
+
+#-------------------------------------------------------------------------------------------#
+# Custom target for dynamically created udev_rules                                          #
+#   Ordinarily you would add the 'udev_rules' target to both QMAKE_EXTRA_TARGETS to add a   #
+#   rule in the Makefile and PRE_TARGETDEPS to ensure it is a dependency of the TARGET      #
+#                                                                                           #
+#   ie. QMAKE_EXTRA_TARGETS += udev_rules                                                   #
+#       PRE_TARGETDEPS      += udev_rules                                                   #
+#-------------------------------------------------------------------------------------------#
+CONFIG(release, debug|release) {
+    udev_rules.CONFIG       = no_check_exist
+    udev_rules.target       = 60-openrgb.rules
+    udev_rules.path         = $$PREFIX/lib/udev/rules.d/
+
+    exists($$udev_rules.target) {
+        message($$udev_rules.target " - UDEV rules file exists. Removing from build")
+        udev_rules.files    = $$udev_rules.target
+    } else {
+        message($$udev_rules.target " - UDEV rules file missing. Adding script to build")
+        #-----------------------------------------------------------------------------------#
+        # This is a compiler config flag to save the preproccessed .ii & .s                 #
+        #   files so as to automatically process the UDEV rules and the Supported Devices   #
+        #-----------------------------------------------------------------------------------#
+        QMAKE_CXXFLAGS+=-save-temps
+        QMAKE_CXXFLAGS-=-pipe
+        udev_rules.extra    = $$PWD/scripts/build-udev-rules.sh $$PWD $$GIT_COMMIT_ID
+        udev_rules.files    = $$OUT_PWD/60-openrgb.rules
+    }
 }
 
-DISTFILES += \
-    debian/openrgb-udev.postinst \
-    debian/openrgb.postinst
+#-------------------------------------------------------------------------------------------#
+# Add static files to installation                                                          #
+#-------------------------------------------------------------------------------------------#
+target.path=$$PREFIX/bin/
+desktop.path=$$PREFIX/share/applications/
+desktop.files+=qt/org.openrgb.OpenRGB.desktop
+icon.path=$$PREFIX/share/icons/hicolor/128x128/apps/
+icon.files+=qt/org.openrgb.OpenRGB.png
+metainfo.path=$$PREFIX/share/metainfo/
+metainfo.files+=qt/org.openrgb.OpenRGB.metainfo.xml
+INSTALLS += target desktop icon metainfo udev_rules
diff --git a/PluginManager.cpp b/PluginManager.cpp
deleted file mode 100644
index dd4881f3..00000000
--- a/PluginManager.cpp
+++ /dev/null
@@ -1,485 +0,0 @@
-/*---------------------------------------------------------*\
-| PluginManager.cpp                                         |
-|                                                           |
-|   OpenRGB plugin manager                                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "LogManager.h"
-#include "filesystem.h"
-#include "PluginManager.h"
-#include "OpenRGBThemeManager.h"
-#include "SettingsManager.h"
-
-PluginManager::PluginManager()
-{
-    /*---------------------------------------------------------*\
-    | Initialize plugin manager class variables                 |
-    \*---------------------------------------------------------*/
-    AddPluginCallbackVal    = nullptr;
-    AddPluginCallbackArg    = nullptr;
-    RemovePluginCallbackVal = nullptr;
-    RemovePluginCallbackArg = nullptr;
-
-    /*-------------------------------------------------------------------------*\
-    | Create OpenRGB plugins directory                                          |
-    \*-------------------------------------------------------------------------*/
-    filesystem::path plugins_dir = ResourceManager::get()->GetConfigurationDirectory() / plugins_path;
-
-    filesystem::create_directories(plugins_dir);
-}
-
-void PluginManager::RegisterAddPluginCallback(AddPluginCallback new_callback, void * new_callback_arg)
-{
-    AddPluginCallbackVal    = new_callback;
-    AddPluginCallbackArg    = new_callback_arg;
-}
-
-void PluginManager::RegisterRemovePluginCallback(RemovePluginCallback new_callback, void * new_callback_arg)
-{
-    RemovePluginCallbackVal = new_callback;
-    RemovePluginCallbackArg = new_callback_arg;
-}
-
-void PluginManager::ScanAndLoadPlugins()
-{
-    /*---------------------------------------------------------*\
-    | Get the user plugins directory                            |
-    |                                                           |
-    | The user plugins directory is a directory named "plugins" |
-    | in the configuration directory                            |
-    \*---------------------------------------------------------*/
-    filesystem::path plugins_dir = ResourceManager::get()->GetConfigurationDirectory() / plugins_path;
-    ScanAndLoadPluginsFrom(plugins_dir, false);
-
-#ifdef OPENRGB_SYSTEM_PLUGIN_DIRECTORY
-    /*---------------------------------------------------------*\
-    | Get the system plugins directory                          |
-    |                                                           |
-    | The system plugin directory can be set during build time, |
-    | e.g. by the package maintainer to load plugins installed  |
-    | via package manager                                       |
-    \*---------------------------------------------------------*/
-    ScanAndLoadPluginsFrom(OPENRGB_SYSTEM_PLUGIN_DIRECTORY, true);
-#endif
-}
-
-void PluginManager::ScanAndLoadPluginsFrom(const filesystem::path & plugins_dir, bool is_system)
-{
-    if(is_system)
-    {
-        LOG_TRACE("[PluginManager] Scanning system plugin directory: %s", plugins_dir.generic_u8string().c_str());
-    }
-    else
-    {
-        LOG_TRACE("[PluginManager] Scanning user plugin directory: %s", plugins_dir.generic_u8string().c_str());
-    }
-
-    if(!filesystem::is_directory(plugins_dir))
-    {
-        return;
-    }
-
-    /*---------------------------------------------------------*\
-    | Get a list of all files in the plugins directory          |
-    \*---------------------------------------------------------*/
-
-    for(const filesystem::directory_entry& entry: filesystem::directory_iterator(plugins_dir))
-    {
-        if(filesystem::is_directory(entry.path()))
-        {
-            continue;
-        }
-
-        filesystem::path plugin_path = entry.path();
-        LOG_TRACE("[PluginManager] Found plugin file %s", plugin_path.filename().generic_u8string().c_str());
-        AddPlugin(plugin_path, is_system);
-    }
-}
-
-void PluginManager::AddPlugin(const filesystem::path& path, bool is_system)
-{
-    OpenRGBPluginInterface* plugin = nullptr;
-
-    unsigned int plugin_idx;
-
-    /*---------------------------------------------------------------------*\
-    | Search active plugins to see if this path already exists              |
-    \*---------------------------------------------------------------------*/
-    for(plugin_idx = 0; plugin_idx < ActivePlugins.size(); plugin_idx++)
-    {
-        if(path == ActivePlugins[plugin_idx].path)
-        {
-            break;
-        }
-    }
-
-    /*---------------------------------------------------------------------*\
-    | If the path does not match an existing entry, create a new entry      |
-    \*---------------------------------------------------------------------*/
-    if(plugin_idx == ActivePlugins.size())
-    {
-        /*-----------------------------------------------------------------*\
-        | Create a QPluginLoader and load the plugin                        |
-        \*-----------------------------------------------------------------*/
-        std::string     path_string = path.generic_u8string();
-        QPluginLoader*  loader      = new QPluginLoader(QString::fromStdString(path_string));
-        QObject*        instance    = loader->instance();
-
-        if(!loader->isLoaded())
-        {
-            LOG_WARNING("[PluginManager] Plugin %s cannot be loaded: %s", path.c_str(), loader->errorString().toStdString().c_str());
-        }
-
-        /*-----------------------------------------------------------------*\
-        | Check that the plugin is valid, then check the API version        |
-        \*-----------------------------------------------------------------*/
-        if(instance)
-        {
-            plugin = qobject_cast<OpenRGBPluginInterface*>(instance);
-
-            if(plugin)
-            {
-                if(plugin->GetPluginAPIVersion() == OPENRGB_PLUGIN_API_VERSION)
-                {
-                    LOG_TRACE("[PluginManager] Plugin %s has a compatible API version", path.c_str());
-
-                    /*-----------------------------------------------------*\
-                    | Get the plugin information                            |
-                    \*-----------------------------------------------------*/
-                    OpenRGBPluginInfo info = plugin->GetPluginInfo();
-
-                    /*-----------------------------------------------------*\
-                    | Search the settings to see if it is enabled           |
-                    \*-----------------------------------------------------*/
-                    std::string     name        = "";
-                    std::string     description = "";
-                    bool            enabled     = true;
-                    bool            found       = false;
-                    unsigned int    plugin_ct   = 0;
-
-                    /*-----------------------------------------------------*\
-                    | Open plugin list and check if plugin is in the list   |
-                    \*-----------------------------------------------------*/
-                    json plugin_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Plugins");
-
-                    if(plugin_settings.contains("plugins"))
-                    {
-                        plugin_ct = (unsigned int)plugin_settings["plugins"].size();
-
-                        for(unsigned int plugin_settings_idx = 0; plugin_settings_idx < plugin_settings["plugins"].size(); plugin_settings_idx++)
-                        {
-                            if(plugin_settings["plugins"][plugin_settings_idx].contains("name"))
-                            {
-                                name        = plugin_settings["plugins"][plugin_settings_idx]["name"];
-                            }
-
-                            if(plugin_settings["plugins"][plugin_settings_idx].contains("description"))
-                            {
-                                description = plugin_settings["plugins"][plugin_settings_idx]["description"];
-                            }
-
-                            if(plugin_settings["plugins"][plugin_settings_idx].contains("enabled"))
-                            {
-                                enabled     = plugin_settings["plugins"][plugin_settings_idx]["enabled"];
-                            }
-
-                            if((info.Name == name)
-                             &&(info.Description == description))
-                            {
-                                found = true;
-                                break;
-                            }
-                        }
-                    }
-
-                    /*-----------------------------------------------------*\
-                    | If the plugin was not in the list, add it to the list |
-                    | and default it to enabled, then save the settings     |
-                    \*-----------------------------------------------------*/
-                    if(!found)
-                    {
-                        plugin_settings["plugins"][plugin_ct]["name"]           = info.Name;
-                        plugin_settings["plugins"][plugin_ct]["description"]    = info.Description;
-                        plugin_settings["plugins"][plugin_ct]["enabled"]        = enabled;
-
-                        ResourceManager::get()->GetSettingsManager()->SetSettings("Plugins", plugin_settings);
-                        ResourceManager::get()->GetSettingsManager()->SaveSettings();
-                    }
-
-                    LOG_VERBOSE("Loaded plugin %s", info.Name.c_str());
-
-                    /*-----------------------------------------------------*\
-                    | Add the plugin to the PluginManager active plugins    |
-                    \*-----------------------------------------------------*/
-                    OpenRGBPluginEntry entry;
-
-                    entry.info          = info;
-                    entry.plugin        = plugin;
-                    entry.loader        = loader;
-                    entry.path          = path_string;
-                    entry.enabled       = enabled;
-                    entry.widget        = nullptr;
-                    entry.incompatible  = false;
-                    entry.api_version   = plugin->GetPluginAPIVersion();
-                    entry.is_system     = is_system;
-
-                    loader->unload();
-
-                    ActivePlugins.push_back(entry);
-
-                    if(entry.enabled)
-                    {
-                        LoadPlugin(&ActivePlugins.back());
-                    }
-                }
-                else
-                {
-                    /*-----------------------------------------------------*\
-                    | Fill in a plugin information object with text showing |
-                    | the plugin is incompatible                            |
-                    \*-----------------------------------------------------*/
-                    OpenRGBPluginInfo info;
-
-                    info.Name           = "Incompatible Plugin";
-                    info.Description    = "This plugin is not compatible with this version of OpenRGB.";
-
-                    /*-----------------------------------------------------*\
-                    | Add the plugin to the PluginManager active plugins    |
-                    | but mark it as incompatible                           |
-                    \*-----------------------------------------------------*/
-                    OpenRGBPluginEntry entry;
-
-                    entry.info          = info;
-                    entry.plugin        = plugin;
-                    entry.loader        = loader;
-                    entry.path          = path_string;
-                    entry.enabled       = false;
-                    entry.widget        = nullptr;
-                    entry.incompatible  = true;
-                    entry.api_version   = plugin->GetPluginAPIVersion();
-
-                    loader->unload();
-
-                    PluginManager::ActivePlugins.push_back(entry);
-
-                    bool unloaded = loader->unload();
-
-                    LOG_WARNING("[PluginManager] Plugin %s has an incompatible API version", path.c_str());
-
-                    if(!unloaded)
-                    {
-                        LOG_WARNING("[PluginManager] Plugin %s cannot be unloaded", path.c_str());
-                    }
-                }
-            }
-            else
-            {
-                LOG_WARNING("[PluginManager] Plugin %s cannot be casted to OpenRGBPluginInterface", path.c_str());
-            }
-        }
-        else
-        {
-            LOG_WARNING("[PluginManager] Plugin %s cannot be instantiated.", path.c_str());
-        }
-    }
-}
-
-void PluginManager::RemovePlugin(const filesystem::path& path)
-{
-    unsigned int plugin_idx;
-
-    LOG_TRACE("[PluginManager] Attempting to remove plugin %s", path.c_str());
-
-    /*---------------------------------------------------------------------*\
-    | Search active plugins to see if this path already exists              |
-    \*---------------------------------------------------------------------*/
-    for(plugin_idx = 0; plugin_idx < ActivePlugins.size(); plugin_idx++)
-    {
-        if(path == ActivePlugins[plugin_idx].path)
-        {
-            break;
-        }
-    }
-
-    /*---------------------------------------------------------------------*\
-    | If the plugin path does not exist in the active plugins list, return  |
-    \*---------------------------------------------------------------------*/
-    if(plugin_idx == ActivePlugins.size())
-    {
-        LOG_TRACE("[PluginManager] Plugin %s not active", path.c_str());
-        return;
-    }
-
-    /*---------------------------------------------------------------------*\
-    | If the selected plugin is in the list and loaded, unload it           |
-    \*---------------------------------------------------------------------*/
-    if(ActivePlugins[plugin_idx].loader->isLoaded())
-    {
-        LOG_TRACE("[PluginManager] Plugin %s is active, unloading", path.c_str());
-        UnloadPlugin(&ActivePlugins[plugin_idx]);
-    }
-
-    /*---------------------------------------------------------------------*\
-    | Remove the plugin from the active plugins list                        |
-    \*---------------------------------------------------------------------*/
-    ActivePlugins.erase(ActivePlugins.begin() + plugin_idx);
-}
-
-void PluginManager::EnablePlugin(const filesystem::path& path)
-{
-    unsigned int plugin_idx;
-
-    /*---------------------------------------------------------------------*\
-    | Search active plugins to see if this path already exists              |
-    \*---------------------------------------------------------------------*/
-    for(plugin_idx = 0; plugin_idx < ActivePlugins.size(); plugin_idx++)
-    {
-        if(path == ActivePlugins[plugin_idx].path)
-        {
-            break;
-        }
-    }
-
-    /*---------------------------------------------------------------------*\
-    | If the plugin path does not exist in the active plugins list, return  |
-    \*---------------------------------------------------------------------*/
-    if(plugin_idx == ActivePlugins.size())
-    {
-        return;
-    }
-
-    ActivePlugins[plugin_idx].enabled = true;
-    LoadPlugin(&ActivePlugins[plugin_idx]);
-}
-
-void PluginManager::LoadPlugin(OpenRGBPluginEntry* plugin_entry)
-{
-    /*---------------------------------------------------------------------*\
-    | If the plugin is in the list but is incompatible, return              |
-    \*---------------------------------------------------------------------*/
-    if(plugin_entry->incompatible)
-    {
-        return;
-    }
-
-    /*---------------------------------------------------------------------*\
-    | If the selected plugin is in the list but not loaded, load it         |
-    \*---------------------------------------------------------------------*/
-    if(!plugin_entry->loader->isLoaded())
-    {
-        plugin_entry->loader->load();
-
-        QObject* instance                = plugin_entry->loader->instance();
-
-        bool dark_theme = OpenRGBThemeManager::IsDarkTheme();
-
-        if(instance)
-        {
-            OpenRGBPluginInterface* plugin = qobject_cast<OpenRGBPluginInterface*>(instance);
-
-            if(plugin)
-            {
-                if(plugin->GetPluginAPIVersion() == OPENRGB_PLUGIN_API_VERSION)
-                {
-                    plugin_entry->plugin = plugin;
-
-                    plugin->Load(dark_theme, ResourceManager::get());
-
-                    /*-------------------------------------------------*\
-                    | Call the Add Plugin callback                      |
-                    \*-------------------------------------------------*/
-                    if(AddPluginCallbackArg != nullptr)
-                    {
-                        AddPluginCallbackVal(AddPluginCallbackArg, plugin_entry);
-                    }
-                }
-            }
-        }
-    }
-}
-
-void PluginManager::DisablePlugin(const filesystem::path& path)
-{
-    unsigned int plugin_idx;
-
-    /*---------------------------------------------------------------------*\
-    | Search active plugins to see if this path already exists              |
-    \*---------------------------------------------------------------------*/
-    for(plugin_idx = 0; plugin_idx < ActivePlugins.size(); plugin_idx++)
-    {
-        if(path == ActivePlugins[plugin_idx].path)
-        {
-            break;
-        }
-    }
-
-    /*---------------------------------------------------------------------*\
-    | If the plugin path does not exist in the active plugins list, return  |
-    \*---------------------------------------------------------------------*/
-    if(plugin_idx == ActivePlugins.size())
-    {
-        return;
-    }
-
-    ActivePlugins[plugin_idx].enabled = false;
-    UnloadPlugin(&ActivePlugins[plugin_idx]);
-}
-
-void PluginManager::UnloadPlugin(OpenRGBPluginEntry* plugin_entry)
-{
-    /*---------------------------------------------------------------------*\
-    | If the selected plugin is in the list and loaded, unload it           |
-    \*---------------------------------------------------------------------*/
-    if(plugin_entry->loader->isLoaded())
-    {
-        /*-------------------------------------------------*\
-        | Call plugin's Unload function before GUI removal  |
-        \*-------------------------------------------------*/
-        plugin_entry->plugin->Unload();
-
-        /*-------------------------------------------------*\
-        | Call the Remove Plugin callback                   |
-        \*-------------------------------------------------*/
-        if(RemovePluginCallbackVal != nullptr)
-        {
-            RemovePluginCallbackVal(RemovePluginCallbackArg, plugin_entry);
-        }
-
-        bool unloaded = plugin_entry->loader->unload();
-
-        if(!unloaded)
-        {
-            LOG_WARNING("[PluginManager] Plugin %s cannot be unloaded", plugin_entry->path.c_str());
-        }
-        else
-        {
-            LOG_TRACE("[PluginManager] Plugin %s successfully unloaded", plugin_entry->path.c_str());
-        }
-    }
-    else
-    {
-        LOG_TRACE("[PluginManager] Plugin %s was already unloaded", plugin_entry->path.c_str());
-    }
-}
-
-void PluginManager::LoadPlugins()
-{
-    for(OpenRGBPluginEntry& plugin_entry: ActivePlugins)
-    {
-        if(plugin_entry.enabled)
-        {
-            LoadPlugin(&plugin_entry);
-        }
-    }
-}
-
-void PluginManager::UnloadPlugins()
-{
-    for(OpenRGBPluginEntry& plugin_entry: ActivePlugins)
-    {
-        UnloadPlugin(&plugin_entry);
-    }
-}
diff --git a/PluginManager.h b/PluginManager.h
deleted file mode 100644
index 389e5fd1..00000000
--- a/PluginManager.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*---------------------------------------------------------*\
-| PluginManager.h                                           |
-|                                                           |
-|   OpenRGB plugin manager                                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <string>
-#include <iostream>
-#include <QPluginLoader>
-#include <QLabel>
-#include <QtPlugin>
-#include <QDir>
-#include "OpenRGBPluginInterface.h"
-
-typedef struct
-{
-    OpenRGBPluginInfo           info;
-    OpenRGBPluginInterface*     plugin;
-    QPluginLoader*              loader;
-    QWidget*                    widget;
-    QMenu*                      traymenu;
-    std::string                 path;
-    bool                        enabled;
-    bool                        incompatible;
-    bool                        is_system;
-    int                         api_version;
-} OpenRGBPluginEntry;
-
-typedef void (*AddPluginCallback)(void *, OpenRGBPluginEntry* plugin);
-typedef void (*RemovePluginCallback)(void *, OpenRGBPluginEntry* plugin);
-
-class PluginManager
-{
-public:
-    PluginManager();
-
-    void RegisterAddPluginCallback(AddPluginCallback new_callback, void * new_callback_arg);
-    void RegisterRemovePluginCallback(RemovePluginCallback new_callback, void * new_callback_arg);
-
-    void ScanAndLoadPlugins();
-
-    void AddPlugin(const filesystem::path& path, bool is_system);
-    void RemovePlugin(const filesystem::path& path);
-
-    void EnablePlugin(const filesystem::path& path);
-    void DisablePlugin(const filesystem::path& path);
-
-    void LoadPlugins();
-    void UnloadPlugins();
-
-    std::vector<OpenRGBPluginEntry> ActivePlugins;
-
-private:
-    void LoadPlugin(OpenRGBPluginEntry* plugin_entry);
-    void UnloadPlugin(OpenRGBPluginEntry* plugin_entry);
-
-    void ScanAndLoadPluginsFrom(const filesystem::path & plugins_dir, bool is_system);
-
-    AddPluginCallback       AddPluginCallbackVal;
-    void *                  AddPluginCallbackArg;
-
-    RemovePluginCallback    RemovePluginCallbackVal;
-    void *                  RemovePluginCallbackArg;
-
-    const char *            plugins_path = "plugins/";
-};
diff --git a/ResourceManager.cpp b/ResourceManager.cpp
index cf9c8263..f6e31287 100644
--- a/ResourceManager.cpp
+++ b/ResourceManager.cpp
@@ -16,656 +16,561 @@
 #include <locale>
 #endif
 
+#include <hidapi.h>
 #include <stdlib.h>
+
 #include <string>
-#include <hidapi.h>
-#include "cli.h"
-#include "pci_ids/pci_ids.h"
-#include "ResourceManager.h"
-#include "ProfileManager.h"
+
 #include "LogManager.h"
-#include "SettingsManager.h"
 #include "NetworkClient.h"
 #include "NetworkServer.h"
-#include "filesystem.h"
+#include "ProfileManager.h"
+#include "ResourceManager.h"
+#include "SettingsManager.h"
 #include "StringUtils.h"
+#include "cli.h"
+#include "filesystem.h"
+#include "pci_ids/pci_ids.h"
 
-const hidapi_wrapper default_wrapper =
-{
-    NULL,
-    (hidapi_wrapper_send_feature_report)        hid_send_feature_report,
-    (hidapi_wrapper_get_feature_report)         hid_get_feature_report,
-    (hidapi_wrapper_get_serial_number_string)   hid_get_serial_number_string,
-    (hidapi_wrapper_open_path)                  hid_open_path,
-    (hidapi_wrapper_enumerate)                  hid_enumerate,
-    (hidapi_wrapper_free_enumeration)           hid_free_enumeration,
-    (hidapi_wrapper_close)                      hid_close,
-    (hidapi_wrapper_error)                      hid_error
-};
-
-bool BasicHIDBlock::compare(hid_device_info* info)
-{
-    return ( (vid == info->vendor_id)
-        && (pid == info->product_id)
+const hidapi_wrapper default_wrapper = {NULL,
+										(hidapi_wrapper_send_feature_report)hid_send_feature_report,
+										(hidapi_wrapper_get_feature_report)hid_get_feature_report,
+										(hidapi_wrapper_get_serial_number_string)hid_get_serial_number_string,
+										(hidapi_wrapper_open_path)hid_open_path,
+										(hidapi_wrapper_enumerate)hid_enumerate,
+										(hidapi_wrapper_free_enumeration)hid_free_enumeration,
+										(hidapi_wrapper_close)hid_close,
+										(hidapi_wrapper_error)hid_error};
+
+bool BasicHIDBlock::compare(hid_device_info* info) {
+	return ((vid == info->vendor_id) && (pid == info->product_id)
 #ifdef USE_HID_USAGE
-        && ( (usage_page == HID_USAGE_PAGE_ANY)
-            || (usage_page == info->usage_page) )
-        && ( (usage      == HID_USAGE_ANY)
-            || (usage      == info->usage) )
-        && ( (interface  == HID_INTERFACE_ANY)
-            || (interface  == info->interface_number ) )
+			&& ((usage_page == HID_USAGE_PAGE_ANY) || (usage_page == info->usage_page)) && ((usage == HID_USAGE_ANY) || (usage == info->usage)) &&
+			((interface == HID_INTERFACE_ANY) || (interface == info->interface_number))
 #else
-        && ( (interface  == HID_INTERFACE_ANY)
-            || (interface  == info->interface_number ) )
+			&& ((interface == HID_INTERFACE_ANY) || (interface == info->interface_number))
 #endif
-            );
+	);
 }
 
 ResourceManager* ResourceManager::instance;
 
 using namespace std::chrono_literals;
 
-ResourceManager *ResourceManager::get()
-{
-    if(!instance)
-    {
-        instance = new ResourceManager();
-    }
+ResourceManager* ResourceManager::get() {
+	if (!instance) {
+		instance = new ResourceManager();
+	}
 
-    return instance;
+	return instance;
 }
 
-ResourceManager::ResourceManager()
-{
-    /*-------------------------------------------------------------------------*\
-    | Initialize Detection Variables                                            |
-    \*-------------------------------------------------------------------------*/
-    detection_enabled           = true;
-    detection_percent           = 100;
-    detection_string            = "";
-    detection_is_required       = false;
-    InitThread                  = nullptr;
-    DetectDevicesThread         = nullptr;
-    dynamic_detectors_processed = false;
-    init_finished               = false;
-
-    SetupConfigurationDirectory();
-
-    /*-------------------------------------------------------------------------*\
-    | Load settings from file                                                   |
-    \*-------------------------------------------------------------------------*/
-    settings_manager        = new SettingsManager();
-
-    settings_manager->LoadSettings(GetConfigurationDirectory() / "OpenRGB.json");
-
-    /*-------------------------------------------------------------------------*\
-    | Configure the log manager                                                 |
-    \*-------------------------------------------------------------------------*/
-    LogManager::get()->configure(settings_manager->GetSettings("LogManager"), GetConfigurationDirectory());
-
-    /*-------------------------------------------------------------------------*\
-    | Initialize Server Instance                                                |
-    |   If configured, pass through full controller list including clients      |
-    |   Otherwise, pass only local hardware controllers                         |
-    \*-------------------------------------------------------------------------*/
-    json server_settings    = settings_manager->GetSettings("Server");
-    bool all_controllers    = false;
-
-    if(server_settings.contains("all_controllers"))
-    {
-        all_controllers     = server_settings["all_controllers"];
-    }
-
-    if(all_controllers)
-    {
-        server              = new NetworkServer(rgb_controllers);
-    }
-    else
-    {
-        server              = new NetworkServer(rgb_controllers_hw);
-    }
-
-    /*-------------------------------------------------------------------------*\
-    | Initialize Saved Client Connections                                       |
-    \*-------------------------------------------------------------------------*/
-    json client_settings    = settings_manager->GetSettings("Client");
-
-    if(client_settings.contains("clients"))
-    {
-        for(unsigned int client_idx = 0; client_idx < client_settings["clients"].size(); client_idx++)
-        {
-            NetworkClient * client = new NetworkClient(rgb_controllers);
-
-            std::string titleString = "OpenRGB ";
-            titleString.append(VERSION_STRING);
-
-            std::string     client_ip   = client_settings["clients"][client_idx]["ip"];
-            unsigned short  client_port = client_settings["clients"][client_idx]["port"];
-
-            client->SetIP(client_ip.c_str());
-            client->SetName(titleString.c_str());
-            client->SetPort(client_port);
-
-            client->StartClient();
-
-            for(int timeout = 0; timeout < 100; timeout++)
-            {
-                if(client->GetConnected())
-                {
-                    break;
-                }
-                std::this_thread::sleep_for(10ms);
-            }
-
-            clients.push_back(client);
-        }
-    }
-
-    /*-------------------------------------------------------------------------*\
-    | Load sizes list from file                                                 |
-    \*-------------------------------------------------------------------------*/
-    profile_manager         = new ProfileManager(GetConfigurationDirectory());
-    server->SetProfileManager(profile_manager);
-    rgb_controllers_sizes   = profile_manager->LoadProfileToList("sizes", true);
+ResourceManager::ResourceManager() {
+	/*-------------------------------------------------------------------------*\
+	| Initialize Detection Variables                                            |
+	\*-------------------------------------------------------------------------*/
+	detection_enabled			= true;
+	detection_percent			= 100;
+	detection_string			= "";
+	detection_is_required		= false;
+	InitThread					= nullptr;
+	DetectDevicesThread			= nullptr;
+	dynamic_detectors_processed = false;
+	init_finished				= false;
+
+	SetupConfigurationDirectory();
+
+	/*-------------------------------------------------------------------------*\
+	| Load settings from file                                                   |
+	\*-------------------------------------------------------------------------*/
+	settings_manager = new SettingsManager();
+
+	settings_manager->LoadSettings(GetConfigurationDirectory() / "OpenRGB.json");
+
+	/*-------------------------------------------------------------------------*\
+	| Configure the log manager                                                 |
+	\*-------------------------------------------------------------------------*/
+	LogManager::get()->configure(settings_manager->GetSettings("LogManager"), GetConfigurationDirectory());
+
+	/*-------------------------------------------------------------------------*\
+	| Initialize Server Instance                                                |
+	|   If configured, pass through full controller list including clients      |
+	|   Otherwise, pass only local hardware controllers                         |
+	\*-------------------------------------------------------------------------*/
+	json server_settings = settings_manager->GetSettings("Server");
+	bool all_controllers = false;
+
+	if (server_settings.contains("all_controllers")) {
+		all_controllers = server_settings["all_controllers"];
+	}
+
+	if (all_controllers) {
+		server = new NetworkServer(rgb_controllers);
+	} else {
+		server = new NetworkServer(rgb_controllers_hw);
+	}
+
+	/*-------------------------------------------------------------------------*\
+	| Initialize Saved Client Connections                                       |
+	\*-------------------------------------------------------------------------*/
+	json client_settings = settings_manager->GetSettings("Client");
+
+	if (client_settings.contains("clients")) {
+		for (unsigned int client_idx = 0; client_idx < client_settings["clients"].size(); client_idx++) {
+			NetworkClient* client = new NetworkClient(rgb_controllers);
+
+			std::string titleString = "OpenRGB ";
+			titleString.append(VERSION_STRING);
+
+			std::string client_ip	   = client_settings["clients"][client_idx]["ip"];
+			unsigned short client_port = client_settings["clients"][client_idx]["port"];
+
+			client->SetIP(client_ip.c_str());
+			client->SetName(titleString.c_str());
+			client->SetPort(client_port);
+
+			client->StartClient();
+
+			for (int timeout = 0; timeout < 100; timeout++) {
+				if (client->GetConnected()) {
+					break;
+				}
+				std::this_thread::sleep_for(10ms);
+			}
+
+			clients.push_back(client);
+		}
+	}
+
+	/*-------------------------------------------------------------------------*\
+	| Load sizes list from file                                                 |
+	\*-------------------------------------------------------------------------*/
+	profile_manager = new ProfileManager(GetConfigurationDirectory());
+	server->SetProfileManager(profile_manager);
+	rgb_controllers_sizes = profile_manager->LoadProfileToList("sizes", true);
 }
 
-ResourceManager::~ResourceManager()
-{
-    Cleanup();
+ResourceManager::~ResourceManager() {
+	Cleanup();
 
-    if(InitThread)
-    {
-        DetectDevicesThread->join();
-        delete DetectDevicesThread;
-        DetectDevicesThread = nullptr;
-    }
+	if (InitThread) {
+		DetectDevicesThread->join();
+		delete DetectDevicesThread;
+		DetectDevicesThread = nullptr;
+	}
 }
 
-void ResourceManager::RegisterI2CBus(i2c_smbus_interface *bus)
-{
-    LOG_INFO("Registering I2C interface: %s Device %04X:%04X Subsystem: %04X:%04X", bus->device_name, bus->pci_vendor, bus->pci_device,bus->pci_subsystem_vendor,bus->pci_subsystem_device);
-    busses.push_back(bus);
+void ResourceManager::RegisterI2CBus(i2c_smbus_interface* bus) {
+	LOG_INFO("Registering I2C interface: %s Device %04X:%04X Subsystem: %04X:%04X", bus->device_name, bus->pci_vendor, bus->pci_device,
+			 bus->pci_subsystem_vendor, bus->pci_subsystem_device);
+	busses.push_back(bus);
 }
 
-std::vector<i2c_smbus_interface*> & ResourceManager::GetI2CBusses()
-{
-    return busses;
+std::vector<i2c_smbus_interface*>& ResourceManager::GetI2CBusses() {
+	return busses;
 }
 
-void ResourceManager::RegisterRGBController(RGBController *rgb_controller)
-{
-    LOG_INFO("[%s] Registering RGB controller", rgb_controller->name.c_str());
-    rgb_controllers_hw.push_back(rgb_controller);
-
-    /*-------------------------------------------------*\
-    | If the device list size has changed, call the     |
-    | device list changed callbacks                     |
-    |                                                   |
-    | TODO: If all detection is reworked to use         |
-    | RegisterRGBController, tracking of previous list  |
-    | size can be removed and profile can be loaded per |
-    | controller before adding to list                  |
-    \*-------------------------------------------------*/
-    if(rgb_controllers_hw.size() != detection_prev_size)
-    {
-        /*-------------------------------------------------*\
-        | First, load sizes for the new controllers         |
-        \*-------------------------------------------------*/
-        for(unsigned int controller_size_idx = detection_prev_size; controller_size_idx < rgb_controllers_hw.size(); controller_size_idx++)
-        {
-            profile_manager->LoadDeviceFromListWithOptions(rgb_controllers_sizes, detection_size_entry_used, rgb_controllers_hw[controller_size_idx], true, false);
-        }
-
-        UpdateDeviceList();
-    }
-
-    detection_prev_size = (unsigned int)rgb_controllers_hw.size();
-
-    UpdateDeviceList();
+void ResourceManager::RegisterRGBController(RGBController* rgb_controller) {
+	LOG_INFO("[%s] Registering RGB controller", rgb_controller->name.c_str());
+	rgb_controllers_hw.push_back(rgb_controller);
+
+	/*-------------------------------------------------*\
+	| If the device list size has changed, call the     |
+	| device list changed callbacks                     |
+	|                                                   |
+	| TODO: If all detection is reworked to use         |
+	| RegisterRGBController, tracking of previous list  |
+	| size can be removed and profile can be loaded per |
+	| controller before adding to list                  |
+	\*-------------------------------------------------*/
+	if (rgb_controllers_hw.size() != detection_prev_size) {
+		/*-------------------------------------------------*\
+		| First, load sizes for the new controllers         |
+		\*-------------------------------------------------*/
+		for (unsigned int controller_size_idx = detection_prev_size; controller_size_idx < rgb_controllers_hw.size(); controller_size_idx++) {
+			profile_manager->LoadDeviceFromListWithOptions(rgb_controllers_sizes, detection_size_entry_used, rgb_controllers_hw[controller_size_idx],
+														   true, false);
+		}
+
+		UpdateDeviceList();
+	}
+
+	detection_prev_size = (unsigned int)rgb_controllers_hw.size();
+
+	UpdateDeviceList();
 }
 
-void ResourceManager::UnregisterRGBController(RGBController* rgb_controller)
-{
-    LOG_INFO("[%s] Unregistering RGB controller", rgb_controller->name.c_str());
+void ResourceManager::UnregisterRGBController(RGBController* rgb_controller) {
+	LOG_INFO("[%s] Unregistering RGB controller", rgb_controller->name.c_str());
 
-    /*-------------------------------------------------------------------------*\
-    | Clear callbacks from the controller before removal                        |
-    \*-------------------------------------------------------------------------*/
-    rgb_controller->ClearCallbacks();
+	/*-------------------------------------------------------------------------*\
+	| Clear callbacks from the controller before removal                        |
+	\*-------------------------------------------------------------------------*/
+	rgb_controller->ClearCallbacks();
 
-    /*-------------------------------------------------------------------------*\
-    | Find the controller to remove and remove it from the hardware list        |
-    \*-------------------------------------------------------------------------*/
-    std::vector<RGBController*>::iterator hw_it = std::find(rgb_controllers_hw.begin(), rgb_controllers_hw.end(), rgb_controller);
+	/*-------------------------------------------------------------------------*\
+	| Find the controller to remove and remove it from the hardware list        |
+	\*-------------------------------------------------------------------------*/
+	std::vector<RGBController*>::iterator hw_it = std::find(rgb_controllers_hw.begin(), rgb_controllers_hw.end(), rgb_controller);
 
-    if (hw_it != rgb_controllers_hw.end())
-    {
-        rgb_controllers_hw.erase(hw_it);
-    }
+	if (hw_it != rgb_controllers_hw.end()) {
+		rgb_controllers_hw.erase(hw_it);
+	}
 
-    /*-------------------------------------------------------------------------*\
-    | Find the controller to remove and remove it from the master list          |
-    \*-------------------------------------------------------------------------*/
-    std::vector<RGBController*>::iterator rgb_it = std::find(rgb_controllers.begin(), rgb_controllers.end(), rgb_controller);
+	/*-------------------------------------------------------------------------*\
+	| Find the controller to remove and remove it from the master list          |
+	\*-------------------------------------------------------------------------*/
+	std::vector<RGBController*>::iterator rgb_it = std::find(rgb_controllers.begin(), rgb_controllers.end(), rgb_controller);
 
-    if (rgb_it != rgb_controllers.end())
-    {
-        rgb_controllers.erase(rgb_it);
-    }
+	if (rgb_it != rgb_controllers.end()) {
+		rgb_controllers.erase(rgb_it);
+	}
 
-    UpdateDeviceList();
+	UpdateDeviceList();
 }
 
-std::vector<RGBController*> & ResourceManager::GetRGBControllers()
-{
-    return rgb_controllers;
+std::vector<RGBController*>& ResourceManager::GetRGBControllers() {
+	return rgb_controllers;
 }
 
-void ResourceManager::RegisterI2CBusDetector(I2CBusDetectorFunction detector)
-{
-    i2c_bus_detectors.push_back(detector);
+void ResourceManager::RegisterI2CBusDetector(I2CBusDetectorFunction detector) {
+	i2c_bus_detectors.push_back(detector);
 }
 
-void ResourceManager::RegisterI2CDeviceDetector(std::string name, I2CDeviceDetectorFunction detector)
-{
-    i2c_device_detector_strings.push_back(name);
-    i2c_device_detectors.push_back(detector);
+void ResourceManager::RegisterI2CDeviceDetector(std::string name, I2CDeviceDetectorFunction detector) {
+	i2c_device_detector_strings.push_back(name);
+	i2c_device_detectors.push_back(detector);
 }
 
-void ResourceManager::RegisterI2CDIMMDeviceDetector(std::string name, I2CDIMMDeviceDetectorFunction detector, uint16_t jedec_id, uint8_t dimm_type)
-{
-    I2CDIMMDeviceDetectorBlock block;
+void ResourceManager::RegisterI2CDIMMDeviceDetector(std::string name, I2CDIMMDeviceDetectorFunction detector, uint16_t jedec_id, uint8_t dimm_type) {
+	I2CDIMMDeviceDetectorBlock block;
 
-    block.name          = name;
-    block.function      = detector;
-    block.jedec_id      = jedec_id;
-    block.dimm_type     = dimm_type;
+	block.name		= name;
+	block.function	= detector;
+	block.jedec_id	= jedec_id;
+	block.dimm_type = dimm_type;
 
-    i2c_dimm_device_detectors.push_back(block);
+	i2c_dimm_device_detectors.push_back(block);
 }
 
-void ResourceManager::RegisterI2CPCIDeviceDetector(std::string name, I2CPCIDeviceDetectorFunction detector, uint16_t ven_id, uint16_t dev_id, uint16_t subven_id, uint16_t subdev_id, uint8_t i2c_addr)
-{
-    I2CPCIDeviceDetectorBlock block;
+void ResourceManager::RegisterI2CPCIDeviceDetector(std::string name, I2CPCIDeviceDetectorFunction detector, uint16_t ven_id, uint16_t dev_id,
+												   uint16_t subven_id, uint16_t subdev_id, uint8_t i2c_addr) {
+	I2CPCIDeviceDetectorBlock block;
 
-    block.name          = name;
-    block.function      = detector;
-    block.ven_id        = ven_id;
-    block.dev_id        = dev_id;
-    block.subven_id     = subven_id;
-    block.subdev_id     = subdev_id;
-    block.i2c_addr      = i2c_addr;
+	block.name		= name;
+	block.function	= detector;
+	block.ven_id	= ven_id;
+	block.dev_id	= dev_id;
+	block.subven_id = subven_id;
+	block.subdev_id = subdev_id;
+	block.i2c_addr	= i2c_addr;
 
-    i2c_pci_device_detectors.push_back(block);
+	i2c_pci_device_detectors.push_back(block);
 }
 
-void ResourceManager::RegisterDeviceDetector(std::string name, DeviceDetectorFunction detector)
-{
-    device_detector_strings.push_back(name);
-    device_detectors.push_back(detector);
+void ResourceManager::RegisterDeviceDetector(std::string name, DeviceDetectorFunction detector) {
+	device_detector_strings.push_back(name);
+	device_detectors.push_back(detector);
 }
 
-void ResourceManager::RegisterHIDDeviceDetector(std::string name,
-                               HIDDeviceDetectorFunction  detector,
-                               uint16_t vid,
-                               uint16_t pid,
-                               int interface,
-                               int usage_page,
-                               int usage)
-{
-    HIDDeviceDetectorBlock block;
-
-    block.name          = name;
-    block.vid           = vid;
-    block.pid           = pid;
-    block.function      = detector;
-    block.interface     = interface;
-    block.usage_page    = usage_page;
-    block.usage         = usage;
-
-    hid_device_detectors.push_back(block);
+void ResourceManager::RegisterHIDDeviceDetector(std::string name, HIDDeviceDetectorFunction detector, uint16_t vid, uint16_t pid, int interface,
+												int usage_page, int usage) {
+	HIDDeviceDetectorBlock block;
+
+	block.name		 = name;
+	block.vid		 = vid;
+	block.pid		 = pid;
+	block.function	 = detector;
+	block.interface	 = interface;
+	block.usage_page = usage_page;
+	block.usage		 = usage;
+
+	hid_device_detectors.push_back(block);
 }
 
-void ResourceManager::RegisterHIDWrappedDeviceDetector(std::string name,
-                                                       HIDWrappedDeviceDetectorFunction  detector,
-                                                       uint16_t vid,
-                                                       uint16_t pid,
-                                                       int interface,
-                                                       int usage_page,
-                                                       int usage)
-{
-    HIDWrappedDeviceDetectorBlock block;
-
-    block.name          = name;
-    block.vid           = vid;
-    block.pid           = pid;
-    block.function      = detector;
-    block.interface     = interface;
-    block.usage_page    = usage_page;
-    block.usage         = usage;
-
-    hid_wrapped_device_detectors.push_back(block);
+void ResourceManager::RegisterHIDWrappedDeviceDetector(std::string name, HIDWrappedDeviceDetectorFunction detector, uint16_t vid, uint16_t pid,
+													   int interface, int usage_page, int usage) {
+	HIDWrappedDeviceDetectorBlock block;
+
+	block.name		 = name;
+	block.vid		 = vid;
+	block.pid		 = pid;
+	block.function	 = detector;
+	block.interface	 = interface;
+	block.usage_page = usage_page;
+	block.usage		 = usage;
+
+	hid_wrapped_device_detectors.push_back(block);
 }
 
-void ResourceManager::RegisterDynamicDetector(std::string name, DynamicDetectorFunction detector)
-{
-    dynamic_detector_strings.push_back(name);
-    dynamic_detectors.push_back(detector);
+void ResourceManager::RegisterDynamicDetector(std::string name, DynamicDetectorFunction detector) {
+	dynamic_detector_strings.push_back(name);
+	dynamic_detectors.push_back(detector);
 }
 
-void ResourceManager::RegisterPreDetectionHook(PreDetectionHookFunction hook)
-{
-    pre_detection_hooks.push_back(hook);
+void ResourceManager::RegisterPreDetectionHook(PreDetectionHookFunction hook) {
+	pre_detection_hooks.push_back(hook);
 }
 
-void ResourceManager::RegisterDeviceListChangeCallback(DeviceListChangeCallback new_callback, void * new_callback_arg)
-{
-    DeviceListChangeCallbacks.push_back(new_callback);
-    DeviceListChangeCallbackArgs.push_back(new_callback_arg);
+void ResourceManager::RegisterDeviceListChangeCallback(DeviceListChangeCallback new_callback, void* new_callback_arg) {
+	DeviceListChangeCallbacks.push_back(new_callback);
+	DeviceListChangeCallbackArgs.push_back(new_callback_arg);
 
-    LOG_TRACE("[ResourceManager] Registered device list change callback.  Total callbacks registered: %d", DeviceListChangeCallbacks.size());
+	LOG_TRACE("[ResourceManager] Registered device list change callback.  Total callbacks registered: %d", DeviceListChangeCallbacks.size());
 }
 
-void ResourceManager::UnregisterDeviceListChangeCallback(DeviceListChangeCallback callback, void * callback_arg)
-{
-    for(size_t idx = 0; idx < DeviceListChangeCallbacks.size(); idx++)
-    {
-        if(DeviceListChangeCallbacks[idx] == callback && DeviceListChangeCallbackArgs[idx] == callback_arg)
-        {
-            DeviceListChangeCallbacks.erase(DeviceListChangeCallbacks.begin() + idx);
-            DeviceListChangeCallbackArgs.erase(DeviceListChangeCallbackArgs.begin() + idx);
-        }
-    }
-
-    LOG_TRACE("[ResourceManager] Unregistered device list change callback.  Total callbacks registered: %d", DeviceListChangeCallbacks.size());
+void ResourceManager::UnregisterDeviceListChangeCallback(DeviceListChangeCallback callback, void* callback_arg) {
+	for (size_t idx = 0; idx < DeviceListChangeCallbacks.size(); idx++) {
+		if (DeviceListChangeCallbacks[idx] == callback && DeviceListChangeCallbackArgs[idx] == callback_arg) {
+			DeviceListChangeCallbacks.erase(DeviceListChangeCallbacks.begin() + idx);
+			DeviceListChangeCallbackArgs.erase(DeviceListChangeCallbackArgs.begin() + idx);
+		}
+	}
+
+	LOG_TRACE("[ResourceManager] Unregistered device list change callback.  Total callbacks registered: %d", DeviceListChangeCallbacks.size());
 }
 
-void ResourceManager::RegisterI2CBusListChangeCallback(I2CBusListChangeCallback new_callback, void * new_callback_arg)
-{
-    I2CBusListChangeCallbacks.push_back(new_callback);
-    I2CBusListChangeCallbackArgs.push_back(new_callback_arg);
+void ResourceManager::RegisterI2CBusListChangeCallback(I2CBusListChangeCallback new_callback, void* new_callback_arg) {
+	I2CBusListChangeCallbacks.push_back(new_callback);
+	I2CBusListChangeCallbackArgs.push_back(new_callback_arg);
 }
 
-void ResourceManager::UnregisterI2CBusListChangeCallback(I2CBusListChangeCallback callback, void * callback_arg)
-{
-    for(size_t idx = 0; idx < I2CBusListChangeCallbacks.size(); idx++)
-    {
-        if(I2CBusListChangeCallbacks[idx] == callback && I2CBusListChangeCallbackArgs[idx] == callback_arg)
-        {
-            I2CBusListChangeCallbacks.erase(I2CBusListChangeCallbacks.begin() + idx);
-            I2CBusListChangeCallbackArgs.erase(I2CBusListChangeCallbackArgs.begin() + idx);
-        }
-    }
+void ResourceManager::UnregisterI2CBusListChangeCallback(I2CBusListChangeCallback callback, void* callback_arg) {
+	for (size_t idx = 0; idx < I2CBusListChangeCallbacks.size(); idx++) {
+		if (I2CBusListChangeCallbacks[idx] == callback && I2CBusListChangeCallbackArgs[idx] == callback_arg) {
+			I2CBusListChangeCallbacks.erase(I2CBusListChangeCallbacks.begin() + idx);
+			I2CBusListChangeCallbackArgs.erase(I2CBusListChangeCallbackArgs.begin() + idx);
+		}
+	}
 }
 
-void ResourceManager::RegisterDetectionProgressCallback(DetectionProgressCallback new_callback, void *new_callback_arg)
-{
-    DetectionProgressCallbacks.push_back(new_callback);
-    DetectionProgressCallbackArgs.push_back(new_callback_arg);
+void ResourceManager::RegisterDetectionProgressCallback(DetectionProgressCallback new_callback, void* new_callback_arg) {
+	DetectionProgressCallbacks.push_back(new_callback);
+	DetectionProgressCallbackArgs.push_back(new_callback_arg);
 
-    LOG_TRACE("[ResourceManager] Registered detection progress callback.  Total callbacks registered: %d", DetectionProgressCallbacks.size());
+	LOG_TRACE("[ResourceManager] Registered detection progress callback.  Total callbacks registered: %d", DetectionProgressCallbacks.size());
 }
 
-void ResourceManager::UnregisterDetectionProgressCallback(DetectionProgressCallback callback, void *callback_arg)
-{
-    for(size_t idx = 0; idx < DetectionProgressCallbacks.size(); idx++)
-    {
-        if(DetectionProgressCallbacks[idx] == callback && DetectionProgressCallbackArgs[idx] == callback_arg)
-        {
-            DetectionProgressCallbacks.erase(DetectionProgressCallbacks.begin() + idx);
-            DetectionProgressCallbackArgs.erase(DetectionProgressCallbackArgs.begin() + idx);
-        }
-    }
-
-    LOG_TRACE("[ResourceManager] Unregistered detection progress callback.  Total callbacks registered: %d", DetectionProgressCallbacks.size());
+void ResourceManager::UnregisterDetectionProgressCallback(DetectionProgressCallback callback, void* callback_arg) {
+	for (size_t idx = 0; idx < DetectionProgressCallbacks.size(); idx++) {
+		if (DetectionProgressCallbacks[idx] == callback && DetectionProgressCallbackArgs[idx] == callback_arg) {
+			DetectionProgressCallbacks.erase(DetectionProgressCallbacks.begin() + idx);
+			DetectionProgressCallbackArgs.erase(DetectionProgressCallbackArgs.begin() + idx);
+		}
+	}
+
+	LOG_TRACE("[ResourceManager] Unregistered detection progress callback.  Total callbacks registered: %d", DetectionProgressCallbacks.size());
 }
 
-void ResourceManager::RegisterDetectionStartCallback(DetectionStartCallback new_callback, void *new_callback_arg)
-{
-    DetectionStartCallbacks.push_back(new_callback);
-    DetectionStartCallbackArgs.push_back(new_callback_arg);
+void ResourceManager::RegisterDetectionStartCallback(DetectionStartCallback new_callback, void* new_callback_arg) {
+	DetectionStartCallbacks.push_back(new_callback);
+	DetectionStartCallbackArgs.push_back(new_callback_arg);
 }
 
-void ResourceManager::UnregisterDetectionStartCallback(DetectionStartCallback callback, void *callback_arg)
-{
-    for(size_t idx = 0; idx < DetectionStartCallbacks.size(); idx++)
-    {
-        if(DetectionStartCallbacks[idx] == callback && DetectionStartCallbackArgs[idx] == callback_arg)
-        {
-            DetectionStartCallbacks.erase(DetectionStartCallbacks.begin() + idx);
-            DetectionStartCallbackArgs.erase(DetectionStartCallbackArgs.begin() + idx);
-        }
-    }
+void ResourceManager::UnregisterDetectionStartCallback(DetectionStartCallback callback, void* callback_arg) {
+	for (size_t idx = 0; idx < DetectionStartCallbacks.size(); idx++) {
+		if (DetectionStartCallbacks[idx] == callback && DetectionStartCallbackArgs[idx] == callback_arg) {
+			DetectionStartCallbacks.erase(DetectionStartCallbacks.begin() + idx);
+			DetectionStartCallbackArgs.erase(DetectionStartCallbackArgs.begin() + idx);
+		}
+	}
 }
 
-void ResourceManager::RegisterDetectionEndCallback(DetectionEndCallback new_callback, void *new_callback_arg)
-{
-    DetectionEndCallbacks.push_back(new_callback);
-    DetectionEndCallbackArgs.push_back(new_callback_arg);
+void ResourceManager::RegisterDetectionEndCallback(DetectionEndCallback new_callback, void* new_callback_arg) {
+	DetectionEndCallbacks.push_back(new_callback);
+	DetectionEndCallbackArgs.push_back(new_callback_arg);
 }
 
-void ResourceManager::UnregisterDetectionEndCallback(DetectionEndCallback callback, void *callback_arg)
-{
-    for(size_t idx = 0; idx < DetectionEndCallbacks.size(); idx++)
-    {
-        if(DetectionEndCallbacks[idx] == callback && DetectionEndCallbackArgs[idx] == callback_arg)
-        {
-            DetectionEndCallbacks.erase(DetectionEndCallbacks.begin() + idx);
-            DetectionEndCallbackArgs.erase(DetectionEndCallbackArgs.begin() + idx);
-        }
-    }
+void ResourceManager::UnregisterDetectionEndCallback(DetectionEndCallback callback, void* callback_arg) {
+	for (size_t idx = 0; idx < DetectionEndCallbacks.size(); idx++) {
+		if (DetectionEndCallbacks[idx] == callback && DetectionEndCallbackArgs[idx] == callback_arg) {
+			DetectionEndCallbacks.erase(DetectionEndCallbacks.begin() + idx);
+			DetectionEndCallbackArgs.erase(DetectionEndCallbackArgs.begin() + idx);
+		}
+	}
 }
 
-void ResourceManager::UpdateDeviceList()
-{
-    DeviceListChangeMutex.lock();
-
-    /*-------------------------------------------------*\
-    | Insert hardware controllers into controller list  |
-    \*-------------------------------------------------*/
-    for(unsigned int hw_controller_idx = 0; hw_controller_idx < rgb_controllers_hw.size(); hw_controller_idx++)
-    {
-        /*-------------------------------------------------*\
-        | Check if the controller is already in the list    |
-        | at the correct index                              |
-        \*-------------------------------------------------*/
-        if(hw_controller_idx < rgb_controllers.size())
-        {
-            if(rgb_controllers[hw_controller_idx] == rgb_controllers_hw[hw_controller_idx])
-            {
-                continue;
-            }
-        }
-
-        /*-------------------------------------------------*\
-        | If not, check if the controller is already in the |
-        | list at a different index                         |
-        \*-------------------------------------------------*/
-        for(unsigned int controller_idx = 0; controller_idx < rgb_controllers.size(); controller_idx++)
-        {
-            if(rgb_controllers[controller_idx] == rgb_controllers_hw[hw_controller_idx])
-            {
-                rgb_controllers.erase(rgb_controllers.begin() + controller_idx);
-                rgb_controllers.insert(rgb_controllers.begin() + hw_controller_idx, rgb_controllers_hw[hw_controller_idx]);
-                break;
-            }
-        }
-
-        /*-------------------------------------------------*\
-        | If it still hasn't been found, add it to the list |
-        \*-------------------------------------------------*/
-        rgb_controllers.insert(rgb_controllers.begin() + hw_controller_idx, rgb_controllers_hw[hw_controller_idx]);
-    }
-
-    /*-------------------------------------------------*\
-    | Device list has changed, call the callbacks       |
-    \*-------------------------------------------------*/
-    DeviceListChanged();
-
-    /*-------------------------------------------------*\
-    | Device list has changed, inform all clients       |
-    | connected to this server                          |
-    \*-------------------------------------------------*/
-    server->DeviceListChanged();
-
-    DeviceListChangeMutex.unlock();
+void ResourceManager::UpdateDeviceList() {
+	DeviceListChangeMutex.lock();
+
+	/*-------------------------------------------------*\
+	| Insert hardware controllers into controller list  |
+	\*-------------------------------------------------*/
+	for (unsigned int hw_controller_idx = 0; hw_controller_idx < rgb_controllers_hw.size(); hw_controller_idx++) {
+		/*-------------------------------------------------*\
+		| Check if the controller is already in the list    |
+		| at the correct index                              |
+		\*-------------------------------------------------*/
+		if (hw_controller_idx < rgb_controllers.size()) {
+			if (rgb_controllers[hw_controller_idx] == rgb_controllers_hw[hw_controller_idx]) {
+				continue;
+			}
+		}
+
+		/*-------------------------------------------------*\
+		| If not, check if the controller is already in the |
+		| list at a different index                         |
+		\*-------------------------------------------------*/
+		for (unsigned int controller_idx = 0; controller_idx < rgb_controllers.size(); controller_idx++) {
+			if (rgb_controllers[controller_idx] == rgb_controllers_hw[hw_controller_idx]) {
+				rgb_controllers.erase(rgb_controllers.begin() + controller_idx);
+				rgb_controllers.insert(rgb_controllers.begin() + hw_controller_idx, rgb_controllers_hw[hw_controller_idx]);
+				break;
+			}
+		}
+
+		/*-------------------------------------------------*\
+		| If it still hasn't been found, add it to the list |
+		\*-------------------------------------------------*/
+		rgb_controllers.insert(rgb_controllers.begin() + hw_controller_idx, rgb_controllers_hw[hw_controller_idx]);
+	}
+
+	/*-------------------------------------------------*\
+	| Device list has changed, call the callbacks       |
+	\*-------------------------------------------------*/
+	DeviceListChanged();
+
+	/*-------------------------------------------------*\
+	| Device list has changed, inform all clients       |
+	| connected to this server                          |
+	\*-------------------------------------------------*/
+	server->DeviceListChanged();
+
+	DeviceListChangeMutex.unlock();
 }
 
-void ResourceManager::DeviceListChanged()
-{
-    /*-------------------------------------------------*\
-    | Device list has changed, call the callbacks       |
-    \*-------------------------------------------------*/
-    LOG_TRACE("[ResourceManager] Calling device list change callbacks.");
-
-    for(std::size_t callback_idx = 0; callback_idx < (unsigned int)DeviceListChangeCallbacks.size(); callback_idx++)
-    {
-        ResourceManager::DeviceListChangeCallbacks[callback_idx](DeviceListChangeCallbackArgs[callback_idx]);
-    }
+void ResourceManager::DeviceListChanged() {
+	/*-------------------------------------------------*\
+	| Device list has changed, call the callbacks       |
+	\*-------------------------------------------------*/
+	LOG_TRACE("[ResourceManager] Calling device list change callbacks.");
+
+	for (std::size_t callback_idx = 0; callback_idx < (unsigned int)DeviceListChangeCallbacks.size(); callback_idx++) {
+		ResourceManager::DeviceListChangeCallbacks[callback_idx](DeviceListChangeCallbackArgs[callback_idx]);
+	}
 }
 
-void ResourceManager::DetectionProgressChanged()
-{
-    DetectionProgressMutex.lock();
+void ResourceManager::DetectionProgressChanged() {
+	DetectionProgressMutex.lock();
 
-    /*-------------------------------------------------*\
-    | Detection progress has changed, call the callbacks|
-    \*-------------------------------------------------*/
-    LOG_TRACE("[ResourceManager] Calling detection progress callbacks.");
+	/*-------------------------------------------------*\
+	| Detection progress has changed, call the callbacks|
+	\*-------------------------------------------------*/
+	LOG_TRACE("[ResourceManager] Calling detection progress callbacks.");
 
-    for(std::size_t callback_idx = 0; callback_idx < (unsigned int)DetectionProgressCallbacks.size(); callback_idx++)
-    {
-        DetectionProgressCallbacks[callback_idx](DetectionProgressCallbackArgs[callback_idx]);
-    }
+	for (std::size_t callback_idx = 0; callback_idx < (unsigned int)DetectionProgressCallbacks.size(); callback_idx++) {
+		DetectionProgressCallbacks[callback_idx](DetectionProgressCallbackArgs[callback_idx]);
+	}
 
-    DetectionProgressMutex.unlock();
+	DetectionProgressMutex.unlock();
 }
 
-void ResourceManager::I2CBusListChanged()
-{
-    I2CBusListChangeMutex.lock();
+void ResourceManager::I2CBusListChanged() {
+	I2CBusListChangeMutex.lock();
 
-    /*-------------------------------------------------*\
-    | Detection progress has changed, call the callbacks|
-    \*-------------------------------------------------*/
-    for(std::size_t callback_idx = 0; callback_idx < (unsigned int)I2CBusListChangeCallbacks.size(); callback_idx++)
-    {
-        I2CBusListChangeCallbacks[callback_idx](I2CBusListChangeCallbackArgs[callback_idx]);
-    }
+	/*-------------------------------------------------*\
+	| Detection progress has changed, call the callbacks|
+	\*-------------------------------------------------*/
+	for (std::size_t callback_idx = 0; callback_idx < (unsigned int)I2CBusListChangeCallbacks.size(); callback_idx++) {
+		I2CBusListChangeCallbacks[callback_idx](I2CBusListChangeCallbackArgs[callback_idx]);
+	}
 
-    I2CBusListChangeMutex.unlock();
+	I2CBusListChangeMutex.unlock();
 }
 
-void ResourceManager::SetupConfigurationDirectory()
-{
-    config_dir.clear();
+void ResourceManager::SetupConfigurationDirectory() {
+	config_dir.clear();
 #ifdef _WIN32
-    const wchar_t* appdata = _wgetenv(L"APPDATA");
-    if(appdata != NULL)
-    {
-        config_dir = appdata;
-    }
+	const wchar_t* appdata = _wgetenv(L"APPDATA");
+	if (appdata != NULL) {
+		config_dir = appdata;
+	}
 #else
-    const char* xdg_config_home = getenv("XDG_CONFIG_HOME");
-    const char* home            = getenv("HOME");
-    /*-----------------------------------------------------*\
-    | Check both XDG_CONFIG_HOME and APPDATA environment    |
-    | variables.  If neither exist, use current directory   |
-    \*-----------------------------------------------------*/
-    if(xdg_config_home != NULL)
-    {
-        config_dir = xdg_config_home;
-    }
-    else if(home != NULL)
-    {
-        config_dir = home;
-        config_dir /= ".config";
-    }
+	const char* xdg_config_home = getenv("XDG_CONFIG_HOME");
+	const char* home			= getenv("HOME");
+	/*-----------------------------------------------------*\
+	| Check both XDG_CONFIG_HOME and APPDATA environment    |
+	| variables.  If neither exist, use current directory   |
+	\*-----------------------------------------------------*/
+	if (xdg_config_home != NULL) {
+		config_dir = xdg_config_home;
+	} else if (home != NULL) {
+		config_dir = home;
+		config_dir /= ".config";
+	}
 #endif
 
-
-    /*-----------------------------------------------------*\
-    | If a configuration directory was found, append OpenRGB|
-    \*-----------------------------------------------------*/
-    if(config_dir != "")
-    {
-        config_dir.append("OpenRGB");
-
-        /*-------------------------------------------------------------------------*\
-        | Create OpenRGB configuration directory if it doesn't exist                |
-        \*-------------------------------------------------------------------------*/
-        filesystem::create_directories(config_dir);
-    }
-    else
-    {
-        config_dir = "./";
-    }
+	/*-----------------------------------------------------*\
+	| If a configuration directory was found, append OpenRGB|
+	\*-----------------------------------------------------*/
+	if (config_dir != "") {
+		config_dir.append("OpenRGB");
+
+		/*-------------------------------------------------------------------------*\
+		| Create OpenRGB configuration directory if it doesn't exist                |
+		\*-------------------------------------------------------------------------*/
+		filesystem::create_directories(config_dir);
+	} else {
+		config_dir = "./";
+	}
 }
 
-filesystem::path ResourceManager::GetConfigurationDirectory()
-{
-    return(config_dir);
+filesystem::path ResourceManager::GetConfigurationDirectory() {
+	return (config_dir);
 }
 
-void ResourceManager::SetConfigurationDirectory(const filesystem::path &directory)
-{
-    config_dir = directory;
-    settings_manager->LoadSettings(directory / "OpenRGB.json");
-    profile_manager->SetConfigurationDirectory(directory);
+void ResourceManager::SetConfigurationDirectory(const filesystem::path& directory) {
+	config_dir = directory;
+	settings_manager->LoadSettings(directory / "OpenRGB.json");
+	profile_manager->SetConfigurationDirectory(directory);
 
-    rgb_controllers_sizes.clear();
-    rgb_controllers_sizes   = profile_manager->LoadProfileToList("sizes", true);
+	rgb_controllers_sizes.clear();
+	rgb_controllers_sizes = profile_manager->LoadProfileToList("sizes", true);
 }
 
-NetworkServer* ResourceManager::GetServer()
-{
-    return(server);
+NetworkServer* ResourceManager::GetServer() {
+	return (server);
 }
 
-static void NetworkClientInfoChangeCallback(void* this_ptr)
-{
-    ResourceManager* this_obj = (ResourceManager*)this_ptr;
+static void NetworkClientInfoChangeCallback(void* this_ptr) {
+	ResourceManager* this_obj = (ResourceManager*)this_ptr;
 
-    this_obj->DeviceListChanged();
+	this_obj->DeviceListChanged();
 }
 
-void ResourceManager::RegisterNetworkClient(NetworkClient* new_client)
-{
-    new_client->RegisterClientInfoChangeCallback(NetworkClientInfoChangeCallback, this);
+void ResourceManager::RegisterNetworkClient(NetworkClient* new_client) {
+	new_client->RegisterClientInfoChangeCallback(NetworkClientInfoChangeCallback, this);
 
-    clients.push_back(new_client);
+	clients.push_back(new_client);
 }
 
-void ResourceManager::UnregisterNetworkClient(NetworkClient* network_client)
-{
-    /*-------------------------------------------------------------------------*\
-    | Stop the disconnecting client                                             |
-    \*-------------------------------------------------------------------------*/
-    network_client->StopClient();
-
-    /*-------------------------------------------------------------------------*\
-    | Clear callbacks from the client before removal                            |
-    \*-------------------------------------------------------------------------*/
-    network_client->ClearCallbacks();
-
-    /*-------------------------------------------------------------------------*\
-    | Find the client to remove and remove it from the clients list             |
-    \*-------------------------------------------------------------------------*/
-    std::vector<NetworkClient*>::iterator client_it = std::find(clients.begin(), clients.end(), network_client);
-
-    if(client_it != clients.end())
-    {
-        clients.erase(client_it);
-    }
-
-    /*-------------------------------------------------------------------------*\
-    | Delete the client                                                         |
-    \*-------------------------------------------------------------------------*/
-    delete network_client;
-
-    UpdateDeviceList();
-}
+void ResourceManager::UnregisterNetworkClient(NetworkClient* network_client) {
+	/*-------------------------------------------------------------------------*\
+	| Stop the disconnecting client                                             |
+	\*-------------------------------------------------------------------------*/
+	network_client->StopClient();
+
+	/*-------------------------------------------------------------------------*\
+	| Clear callbacks from the client before removal                            |
+	\*-------------------------------------------------------------------------*/
+	network_client->ClearCallbacks();
+
+	/*-------------------------------------------------------------------------*\
+	| Find the client to remove and remove it from the clients list             |
+	\*-------------------------------------------------------------------------*/
+	std::vector<NetworkClient*>::iterator client_it = std::find(clients.begin(), clients.end(), network_client);
 
+	if (client_it != clients.end()) {
+		clients.erase(client_it);
+	}
+
+	/*-------------------------------------------------------------------------*\
+	| Delete the client                                                         |
+	\*-------------------------------------------------------------------------*/
+	delete network_client;
+
+	UpdateDeviceList();
+}
 
 /******************************************************************************************\
 *                                                                                          *
@@ -675,167 +580,142 @@ void ResourceManager::UnregisterNetworkClient(NetworkClient* network_client)
 *                                                                                          *
 \******************************************************************************************/
 
-bool ResourceManager::AttemptLocalConnection()
-{
-    detection_percent = 0;
-    detection_string  = "Attempting local server connection...";
-    DetectionProgressChanged();
-
-    LOG_DEBUG("[ResourceManager] Attempting server connection...");
-
-    bool success = false;
-
-    NetworkClient * client = new NetworkClient(ResourceManager::get()->GetRGBControllers());
-
-    std::string titleString = "OpenRGB ";
-    titleString.append(VERSION_STRING);
-
-    client->SetName(titleString.c_str());
-    client->StartClient();
-
-    for(int timeout = 0; timeout < 10; timeout++)
-    {
-        if(client->GetConnected())
-        {
-            break;
-        }
-        std::this_thread::sleep_for(5ms);
-    }
-
-    if(!client->GetConnected())
-    {
-        LOG_TRACE("[main] Client failed to connect");
-        client->StopClient();
-        LOG_TRACE("[main] Client stopped");
-
-        delete client;
-
-        client = NULL;
-    }
-    else
-    {
-        ResourceManager::get()->RegisterNetworkClient(client);
-        LOG_TRACE("[main] Registered network client");
-
-        success = true;
-
-        /*-----------------------------------------------------*\
-        | Wait up to 5 seconds for the client connection to     |
-        | retrieve all controllers                              |
-        \*-----------------------------------------------------*/
-        for(int timeout = 0; timeout < 1000; timeout++)
-        {
-            if(client->GetOnline())
-            {
-                break;
-            }
-            std::this_thread::sleep_for(5ms);
-        }
-    }
-
-    return success;
+bool ResourceManager::AttemptLocalConnection() {
+	detection_percent = 0;
+	detection_string  = "Attempting local server connection...";
+	DetectionProgressChanged();
+
+	LOG_DEBUG("[ResourceManager] Attempting server connection...");
+
+	bool success = false;
+
+	NetworkClient* client = new NetworkClient(ResourceManager::get()->GetRGBControllers());
+
+	std::string titleString = "OpenRGB ";
+	titleString.append(VERSION_STRING);
+
+	client->SetName(titleString.c_str());
+	client->StartClient();
+
+	for (int timeout = 0; timeout < 10; timeout++) {
+		if (client->GetConnected()) {
+			break;
+		}
+		std::this_thread::sleep_for(5ms);
+	}
+
+	if (!client->GetConnected()) {
+		LOG_TRACE("[main] Client failed to connect");
+		client->StopClient();
+		LOG_TRACE("[main] Client stopped");
+
+		delete client;
+
+		client = NULL;
+	} else {
+		ResourceManager::get()->RegisterNetworkClient(client);
+		LOG_TRACE("[main] Registered network client");
+
+		success = true;
+
+		/*-----------------------------------------------------*\
+		| Wait up to 5 seconds for the client connection to     |
+		| retrieve all controllers                              |
+		\*-----------------------------------------------------*/
+		for (int timeout = 0; timeout < 1000; timeout++) {
+			if (client->GetOnline()) {
+				break;
+			}
+			std::this_thread::sleep_for(5ms);
+		}
+	}
+
+	return success;
 }
 
-std::vector<NetworkClient*>& ResourceManager::GetClients()
-{
-    return(clients);
+std::vector<NetworkClient*>& ResourceManager::GetClients() {
+	return (clients);
 }
 
-ProfileManager* ResourceManager::GetProfileManager()
-{
-    return(profile_manager);
+ProfileManager* ResourceManager::GetProfileManager() {
+	return (profile_manager);
 }
 
-SettingsManager* ResourceManager::GetSettingsManager()
-{
-    return(settings_manager);
+SettingsManager* ResourceManager::GetSettingsManager() {
+	return (settings_manager);
 }
 
-bool ResourceManager::GetDetectionEnabled()
-{
-    return(detection_enabled);
+bool ResourceManager::GetDetectionEnabled() {
+	return (detection_enabled);
 }
 
-unsigned int ResourceManager::GetDetectionPercent()
-{
-    return (detection_percent.load());
+unsigned int ResourceManager::GetDetectionPercent() {
+	return (detection_percent.load());
 }
 
-const char *ResourceManager::GetDetectionString()
-{
-    return (detection_string);
+const char* ResourceManager::GetDetectionString() {
+	return (detection_string);
 }
 
-void ResourceManager::Cleanup()
-{
-    ResourceManager::get()->WaitForDeviceDetection();
-
-    std::vector<RGBController *> rgb_controllers_hw_copy = rgb_controllers_hw;
-
-    for(std::size_t hw_controller_idx = 0; hw_controller_idx < rgb_controllers_hw.size(); hw_controller_idx++)
-    {
-        for(std::size_t controller_idx = 0; controller_idx < rgb_controllers.size(); controller_idx++)
-        {
-            if(rgb_controllers[controller_idx] == rgb_controllers_hw[hw_controller_idx])
-            {
-                rgb_controllers.erase(rgb_controllers.begin() + controller_idx);
-                break;
-            }
-        }
-    }
-
-    /*-------------------------------------------------*\
-    | Clear the hardware controllers list and set the   |
-    | previous hardware controllers list size to zero   |
-    \*-------------------------------------------------*/
-    rgb_controllers_hw.clear();
-    detection_prev_size = 0;
-
-    for(RGBController* rgb_controller : rgb_controllers_hw_copy)
-    {
-        delete rgb_controller;
-    }
-
-    std::vector<i2c_smbus_interface *> busses_copy = busses;
-
-    busses.clear();
-
-    for(i2c_smbus_interface* bus : busses_copy)
-    {
-        delete bus;
-    }
-
-    /*-------------------------------------------------*\
-    | Cleanup HID interface                             |
-    \*-------------------------------------------------*/
-    int hid_status = hid_exit();
-
-    LOG_DEBUG("Closing HID interfaces: %s", ((hid_status == 0) ? "Success" : "Failed"));
-
-    if(DetectDevicesThread)
-    {
-        DetectDevicesThread->join();
-        delete DetectDevicesThread;
-        DetectDevicesThread = nullptr;
-    }
+void ResourceManager::Cleanup() {
+	ResourceManager::get()->WaitForDeviceDetection();
+
+	std::vector<RGBController*> rgb_controllers_hw_copy = rgb_controllers_hw;
+
+	for (std::size_t hw_controller_idx = 0; hw_controller_idx < rgb_controllers_hw.size(); hw_controller_idx++) {
+		for (std::size_t controller_idx = 0; controller_idx < rgb_controllers.size(); controller_idx++) {
+			if (rgb_controllers[controller_idx] == rgb_controllers_hw[hw_controller_idx]) {
+				rgb_controllers.erase(rgb_controllers.begin() + controller_idx);
+				break;
+			}
+		}
+	}
+
+	/*-------------------------------------------------*\
+	| Clear the hardware controllers list and set the   |
+	| previous hardware controllers list size to zero   |
+	\*-------------------------------------------------*/
+	rgb_controllers_hw.clear();
+	detection_prev_size = 0;
+
+	for (RGBController* rgb_controller : rgb_controllers_hw_copy) {
+		delete rgb_controller;
+	}
+
+	std::vector<i2c_smbus_interface*> busses_copy = busses;
+
+	busses.clear();
+
+	for (i2c_smbus_interface* bus : busses_copy) {
+		delete bus;
+	}
+
+	/*-------------------------------------------------*\
+	| Cleanup HID interface                             |
+	\*-------------------------------------------------*/
+	int hid_status = hid_exit();
+
+	LOG_DEBUG("Closing HID interfaces: %s", ((hid_status == 0) ? "Success" : "Failed"));
+
+	if (DetectDevicesThread) {
+		DetectDevicesThread->join();
+		delete DetectDevicesThread;
+		DetectDevicesThread = nullptr;
+	}
 }
 
-void ResourceManager::ProcessPreDetectionHooks()
-{
-    for(std::size_t hook_idx = 0; hook_idx < pre_detection_hooks.size(); hook_idx++)
-    {
-        pre_detection_hooks[hook_idx]();
-    }
+void ResourceManager::ProcessPreDetectionHooks() {
+	for (std::size_t hook_idx = 0; hook_idx < pre_detection_hooks.size(); hook_idx++) {
+		pre_detection_hooks[hook_idx]();
+	}
 }
 
-void ResourceManager::ProcessDynamicDetectors()
-{
-    for(std::size_t detector_idx = 0; detector_idx < dynamic_detectors.size(); detector_idx++)
-    {
-        dynamic_detectors[detector_idx]();
-    }
+void ResourceManager::ProcessDynamicDetectors() {
+	for (std::size_t detector_idx = 0; detector_idx < dynamic_detectors.size(); detector_idx++) {
+		dynamic_detectors[detector_idx]();
+	}
 
-    dynamic_detectors_processed = true;
+	dynamic_detectors_processed = true;
 }
 
 /*-----------------------------------------------------*\
@@ -843,982 +723,839 @@ void ResourceManager::ProcessDynamicDetectors()
 | The system should be ready to start a detection thread|
 | (returns false if detection can not proceed)          |
 \*-----------------------------------------------------*/
-bool ResourceManager::ProcessPreDetection()
-{
-    /*-----------------------------------------------------*\
-    | Process pre-detection hooks                           |
-    \*-----------------------------------------------------*/
-    ProcessPreDetectionHooks();
-
-    /*-----------------------------------------------------*\
-    | Process Dynamic Detectors                             |
-    \*-----------------------------------------------------*/
-    if(!dynamic_detectors_processed)
-    {
-        ProcessDynamicDetectors();
-    }
-
-    /*-----------------------------------------------------*\
-    | Call detection start callbacks                        |
-    \*-----------------------------------------------------*/
-    LOG_TRACE("[ResourceManager] Calling detection start callbacks.");
-
-    for(std::size_t callback_idx = 0; callback_idx < DetectionStartCallbacks.size(); callback_idx++)
-    {
-        DetectionStartCallbacks[callback_idx](DetectionStartCallbackArgs[callback_idx]);
-    }
-
-    /*-----------------------------------------------------*\
-    | Update the detector settings                          |
-    \*-----------------------------------------------------*/
-    UpdateDetectorSettings();
-    if(detection_enabled)
-    {
-        /*-------------------------------------------------*\
-        | Do nothing is it is already detecting devices     |
-        \*-------------------------------------------------*/
-        if(detection_is_required.load())
-        {
-            return false;
-        }
-
-        /*-------------------------------------------------*\
-        | If there's anything left from the last time,      |
-        | we shall remove it first                          |
-        \*-------------------------------------------------*/
-        detection_percent = 0;
-        detection_string  = "";
-
-        DetectionProgressChanged();
-
-        Cleanup();
-
-        UpdateDeviceList();
-
-        /*-------------------------------------------------*\
-        | Initialize HID interface for detection            |
-        \*-------------------------------------------------*/
-        int hid_status = hid_init();
-
-        LOG_INFO("Initializing HID interfaces: %s", ((hid_status == 0) ? "Success" : "Failed"));
-
-        /*-------------------------------------------------*\
-        | Start the device detection thread                 |
-        \*-------------------------------------------------*/
-        detection_is_required = true;
-
-        return true;
-    }
-    return false;
+bool ResourceManager::ProcessPreDetection() {
+	/*-----------------------------------------------------*\
+	| Process pre-detection hooks                           |
+	\*-----------------------------------------------------*/
+	ProcessPreDetectionHooks();
+
+	/*-----------------------------------------------------*\
+	| Process Dynamic Detectors                             |
+	\*-----------------------------------------------------*/
+	if (!dynamic_detectors_processed) {
+		ProcessDynamicDetectors();
+	}
+
+	/*-----------------------------------------------------*\
+	| Call detection start callbacks                        |
+	\*-----------------------------------------------------*/
+	LOG_TRACE("[ResourceManager] Calling detection start callbacks.");
+
+	for (std::size_t callback_idx = 0; callback_idx < DetectionStartCallbacks.size(); callback_idx++) {
+		DetectionStartCallbacks[callback_idx](DetectionStartCallbackArgs[callback_idx]);
+	}
+
+	/*-----------------------------------------------------*\
+	| Update the detector settings                          |
+	\*-----------------------------------------------------*/
+	UpdateDetectorSettings();
+	if (detection_enabled) {
+		/*-------------------------------------------------*\
+		| Do nothing is it is already detecting devices     |
+		\*-------------------------------------------------*/
+		if (detection_is_required.load()) {
+			return false;
+		}
+
+		/*-------------------------------------------------*\
+		| If there's anything left from the last time,      |
+		| we shall remove it first                          |
+		\*-------------------------------------------------*/
+		detection_percent = 0;
+		detection_string  = "";
+
+		DetectionProgressChanged();
+
+		Cleanup();
+
+		UpdateDeviceList();
+
+		/*-------------------------------------------------*\
+		| Initialize HID interface for detection            |
+		\*-------------------------------------------------*/
+		int hid_status = hid_init();
+
+		LOG_INFO("Initializing HID interfaces: %s", ((hid_status == 0) ? "Success" : "Failed"));
+
+		/*-------------------------------------------------*\
+		| Start the device detection thread                 |
+		\*-------------------------------------------------*/
+		detection_is_required = true;
+
+		return true;
+	}
+	return false;
 }
 
-void ResourceManager::DetectDevices()
-{
-    if(ProcessPreDetection())
-    {
-        DetectDevicesThread = new std::thread(&ResourceManager::DetectDevicesThreadFunction, this);
-
-        /*-------------------------------------------------*\
-        | Release the current thread to allow detection     |
-        | thread to start                                   |
-        \*-------------------------------------------------*/
-        std::this_thread::sleep_for(1ms);
-    }
-
-    if(!detection_enabled)
-    {
-        ProcessPostDetection();
-    }
+void ResourceManager::DetectDevices() {
+	if (ProcessPreDetection()) {
+		DetectDevicesThread = new std::thread(&ResourceManager::DetectDevicesThreadFunction, this);
+
+		/*-------------------------------------------------*\
+		| Release the current thread to allow detection     |
+		| thread to start                                   |
+		\*-------------------------------------------------*/
+		std::this_thread::sleep_for(1ms);
+	}
+
+	if (!detection_enabled) {
+		ProcessPostDetection();
+	}
 }
 
-void ResourceManager::ProcessPostDetection()
-{
-    /*-------------------------------------------------*\
-    | Signal that detection is complete                 |
-    \*-------------------------------------------------*/
-    detection_percent     = 100;
-    DetectionProgressChanged();
-
-    LOG_INFO("[ResourceManager] Calling Post-detection callbacks");
-    /*-----------------------------------------------------*\
-    | Call detection end callbacks                          |
-    \*-----------------------------------------------------*/
-    for(std::size_t callback_idx = 0; callback_idx < DetectionEndCallbacks.size(); callback_idx++)
-    {
-        DetectionEndCallbacks[callback_idx](DetectionEndCallbackArgs[callback_idx]);
-    }
-
-    detection_is_required = false;
-
-    LOG_INFO("------------------------------------------------------");
-    LOG_INFO("|                Detection completed                 |");
-    LOG_INFO("------------------------------------------------------");
+void ResourceManager::ProcessPostDetection() {
+	/*-------------------------------------------------*\
+	| Signal that detection is complete                 |
+	\*-------------------------------------------------*/
+	detection_percent = 100;
+	DetectionProgressChanged();
+
+	LOG_INFO("[ResourceManager] Calling Post-detection callbacks");
+	/*-----------------------------------------------------*\
+	| Call detection end callbacks                          |
+	\*-----------------------------------------------------*/
+	for (std::size_t callback_idx = 0; callback_idx < DetectionEndCallbacks.size(); callback_idx++) {
+		DetectionEndCallbacks[callback_idx](DetectionEndCallbackArgs[callback_idx]);
+	}
+
+	detection_is_required = false;
+
+	LOG_INFO("------------------------------------------------------");
+	LOG_INFO("|                Detection completed                 |");
+	LOG_INFO("------------------------------------------------------");
 }
 
-void ResourceManager::DisableDetection()
-{
-    detection_enabled = false;
+void ResourceManager::DisableDetection() {
+	detection_enabled = false;
 }
 
-void ResourceManager::DetectDevicesThreadFunction()
-{
-    DetectDeviceMutex.lock();
-
-    hid_device_info*    current_hid_device;
-    float               percent             = 0.0f;
-    float               percent_denominator = 0.0f;
-    json                detector_settings;
-    unsigned int        hid_device_count    = 0;
-    hid_device_info*    hid_devices         = NULL;
-    bool                hid_safe_mode       = false;
-
-    LOG_INFO("------------------------------------------------------");
-    LOG_INFO("|               Start device detection               |");
-    LOG_INFO("------------------------------------------------------");
-
-    /*-------------------------------------------------*\
-    | Reset the size entry used flags vector            |
-    \*-------------------------------------------------*/
-    detection_size_entry_used.resize(rgb_controllers_sizes.size());
-
-    for(std::size_t size_idx = 0; size_idx < (unsigned int)detection_size_entry_used.size(); size_idx++)
-    {
-        detection_size_entry_used[size_idx] = false;
-    }
-
-    /*-------------------------------------------------*\
-    | Open device disable list and read in disabled     |
-    | device strings                                    |
-    \*-------------------------------------------------*/
-    detector_settings = settings_manager->GetSettings("Detectors");
-
-    /*-------------------------------------------------*\
-    | Check HID safe mode setting                       |
-    \*-------------------------------------------------*/
-    if(detector_settings.contains("hid_safe_mode"))
-    {
-        hid_safe_mode = detector_settings["hid_safe_mode"];
-    }
-
-    /*-------------------------------------------------*\
-    | Calculate the percentage denominator by adding    |
-    | the number of I2C and miscellaneous detectors and |
-    | the number of enumerated HID devices              |
-    |                                                   |
-    | Start by iterating through all HID devices in     |
-    | list to get a total count                         |
-    \*-------------------------------------------------*/
-    if(!hid_safe_mode)
-    {
-        hid_devices = hid_enumerate(0, 0);
-    }
-
-    current_hid_device = hid_devices;
-
-    while(current_hid_device)
-    {
-        hid_device_count++;
-
-        current_hid_device = current_hid_device->next;
-    }
-
-    percent_denominator = (float)(i2c_device_detectors.size() + i2c_dimm_device_detectors.size() + i2c_pci_device_detectors.size() + device_detectors.size()) + (float)hid_device_count;
-
-    /*-------------------------------------------------*\
-    | Start at 0% detection progress                    |
-    \*-------------------------------------------------*/
-    detection_percent = 0;
+void ResourceManager::DetectDevicesThreadFunction() {
+	DetectDeviceMutex.lock();
+
+	hid_device_info* current_hid_device;
+	float percent			  = 0.0f;
+	float percent_denominator = 0.0f;
+	json detector_settings;
+	unsigned int hid_device_count = 0;
+	hid_device_info* hid_devices  = NULL;
+	bool hid_safe_mode			  = false;
+
+	LOG_INFO("------------------------------------------------------");
+	LOG_INFO("|               Start device detection               |");
+	LOG_INFO("------------------------------------------------------");
+
+	/*-------------------------------------------------*\
+	| Reset the size entry used flags vector            |
+	\*-------------------------------------------------*/
+	detection_size_entry_used.resize(rgb_controllers_sizes.size());
+
+	for (std::size_t size_idx = 0; size_idx < (unsigned int)detection_size_entry_used.size(); size_idx++) {
+		detection_size_entry_used[size_idx] = false;
+	}
+
+	/*-------------------------------------------------*\
+	| Open device disable list and read in disabled     |
+	| device strings                                    |
+	\*-------------------------------------------------*/
+	detector_settings = settings_manager->GetSettings("Detectors");
+
+	/*-------------------------------------------------*\
+	| Check HID safe mode setting                       |
+	\*-------------------------------------------------*/
+	if (detector_settings.contains("hid_safe_mode")) {
+		hid_safe_mode = detector_settings["hid_safe_mode"];
+	}
+
+	/*-------------------------------------------------*\
+	| Calculate the percentage denominator by adding    |
+	| the number of I2C and miscellaneous detectors and |
+	| the number of enumerated HID devices              |
+	|                                                   |
+	| Start by iterating through all HID devices in     |
+	| list to get a total count                         |
+	\*-------------------------------------------------*/
+	if (!hid_safe_mode) {
+		hid_devices = hid_enumerate(0, 0);
+	}
+
+	current_hid_device = hid_devices;
+
+	while (current_hid_device) {
+		hid_device_count++;
+
+		current_hid_device = current_hid_device->next;
+	}
+
+	percent_denominator =
+		(float)(i2c_device_detectors.size() + i2c_dimm_device_detectors.size() + i2c_pci_device_detectors.size() + device_detectors.size()) +
+		(float)hid_device_count;
+
+	/*-------------------------------------------------*\
+	| Start at 0% detection progress                    |
+	\*-------------------------------------------------*/
+	detection_percent = 0;
 
 #ifdef __linux__
-    /*-------------------------------------------------*\
-    | Check if the udev rules exist                     |
-    \*-------------------------------------------------*/
-    bool udev_not_exist     = false;
-    bool udev_multiple      = false;
-
-    if(access("/etc/udev/rules.d/60-openrgb.rules", F_OK) != 0)
-    {
-        if(access("/usr/lib/udev/rules.d/60-openrgb.rules", F_OK) != 0)
-        {
-            udev_not_exist  = true;
-        }
-    }
-    else
-    {
-        if(access("/usr/lib/udev/rules.d/60-openrgb.rules", F_OK) == 0)
-        {
-            udev_multiple   = true;
-        }
-    }
+	/*-------------------------------------------------*\
+	| Check if the udev rules exist                     |
+	\*-------------------------------------------------*/
+	bool udev_not_exist = false;
+	bool udev_multiple	= false;
+
+	if (access("/etc/udev/rules.d/60-openrgb.rules", F_OK) != 0) {
+		if (access("/usr/lib/udev/rules.d/60-openrgb.rules", F_OK) != 0) {
+			udev_not_exist = true;
+		}
+	} else {
+		if (access("/usr/lib/udev/rules.d/60-openrgb.rules", F_OK) == 0) {
+			udev_multiple = true;
+		}
+	}
 #endif
 
-    /*-------------------------------------------------*\
-    | Detect i2c interfaces                             |
-    \*-------------------------------------------------*/
-    LOG_INFO("------------------------------------------------------");
-    LOG_INFO("|             Detecting I2C interfaces               |");
-    LOG_INFO("------------------------------------------------------");
-
-    bool i2c_interface_fail = false;
-
-    for(unsigned int i2c_bus_detector_idx = 0; i2c_bus_detector_idx < (unsigned int)i2c_bus_detectors.size() && detection_is_required.load(); i2c_bus_detector_idx++)
-    {
-        if(i2c_bus_detectors[i2c_bus_detector_idx]() == false)
-        {
-            i2c_interface_fail = true;
-        }
-
-        I2CBusListChanged();
-    }
-
-    /*-------------------------------------------------*\
-    | Detect i2c devices                                |
-    \*-------------------------------------------------*/
-    LOG_INFO("------------------------------------------------------");
-    LOG_INFO("|               Detecting I2C devices                |");
-    LOG_INFO("------------------------------------------------------");
-    for(unsigned int i2c_detector_idx = 0; i2c_detector_idx < (unsigned int)i2c_device_detectors.size() && detection_is_required.load(); i2c_detector_idx++)
-    {
-        unsigned int controller_size = rgb_controllers_hw.size();
-        detection_string = i2c_device_detector_strings[i2c_detector_idx].c_str();
-
-        /*-------------------------------------------------*\
-        | Check if this detector is enabled                 |
-        \*-------------------------------------------------*/
-        bool this_device_enabled = true;
-        if(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))
-        {
-            this_device_enabled = detector_settings["detectors"][detection_string];
-        }
-
-        LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
-        if(this_device_enabled)
-        {
-            DetectionProgressChanged();
-
-            i2c_device_detectors[i2c_detector_idx](busses);
-        }
-
-        /*-------------------------------------------------*\
-        | If the device list size has changed, call the     |
-        | device list changed callbacks                     |
-        \*-------------------------------------------------*/
-        if(rgb_controllers_hw.size() == controller_size)
-        {
-            LOG_DEBUG("[%s] no devices found", detection_string);
-        }
-
-        LOG_TRACE("[%s] detection end", detection_string);
-
-        /*-------------------------------------------------*\
-        | Update detection percent                          |
-        \*-------------------------------------------------*/
-        percent = ((float)i2c_detector_idx + 1.0f) / percent_denominator;
-
-        detection_percent = (unsigned int)(percent * 100.0f);
-    }
-
-    /*-------------------------------------------------*\
-    | Detect i2c DIMM modules                           |
-    \*-------------------------------------------------*/
-    LOG_INFO("------------------------------------------------------");
-    LOG_INFO("|            Detecting I2C DIMM modules              |");
-    LOG_INFO("------------------------------------------------------");
-    for(unsigned int bus = 0; bus < busses.size(); bus++)
-    {
-        IF_DRAM_SMBUS(busses[bus]->pci_vendor, busses[bus]->pci_device)
-        {
-            std::vector<SPDWrapper> slots;
-            SPDMemoryType dimm_type = SPD_RESERVED;
-
-            for(uint8_t spd_addr = 0x50; spd_addr < 0x58; spd_addr++)
-            {
-                SPDDetector spd(busses[bus], spd_addr, dimm_type);
-                if(spd.is_valid())
-                {
-                    SPDWrapper accessor(spd);
-                    dimm_type = spd.memory_type();
-                    LOG_INFO("Detected occupied slot %d, bus %d, type %s", spd_addr - 0x50 + 1, bus, spd_memory_type_name[dimm_type]);
-                    LOG_DEBUG("Jedec ID: 0x%04x", accessor.jedec_id());
-                    slots.push_back(accessor);
-                }
-            }
-
-            for(unsigned int i2c_detector_idx = 0; i2c_detector_idx < i2c_dimm_device_detectors.size() && detection_is_required.load(); i2c_detector_idx++)
-            {
-                if(i2c_dimm_device_detectors[i2c_detector_idx].dimm_type == dimm_type &&
-                   is_jedec_in_slots(slots, i2c_dimm_device_detectors[i2c_detector_idx].jedec_id))
-                {
-                    detection_string = i2c_dimm_device_detectors[i2c_detector_idx].name.c_str();
-
-                    /*-------------------------------------------------*\
-                    | Check if this detector is enabled                 |
-                    \*-------------------------------------------------*/
-                    bool this_device_enabled = true;
-                    if(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))
-                    {
-                        this_device_enabled = detector_settings["detectors"][detection_string];
-                    }
-
-                    LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
-                    if(this_device_enabled)
-                    {
-                        DetectionProgressChanged();
-
-                        std::vector<SPDWrapper*> matching_slots = slots_with_jedec(slots, i2c_dimm_device_detectors[i2c_detector_idx].jedec_id);
-                        i2c_dimm_device_detectors[i2c_detector_idx].function(busses[bus], matching_slots);
-                    }
-
-                    LOG_TRACE("[%s] detection end", detection_string);
-                }
-
-                /*-------------------------------------------------*\
-                | Update detection percent                          |
-                \*-------------------------------------------------*/
-                percent = ((float)i2c_detector_idx + 1.0f) / percent_denominator;
-
-                detection_percent = (unsigned int)(percent * 100.0f);
-            }
-        }
-    }
-
-    /*-------------------------------------------------*\
-    | Detect i2c PCI devices                            |
-    \*-------------------------------------------------*/
-    LOG_INFO("------------------------------------------------------");
-    LOG_INFO("|               Detecting I2C PCI devices            |");
-    LOG_INFO("------------------------------------------------------");
-    for(unsigned int i2c_detector_idx = 0; i2c_detector_idx < (unsigned int)i2c_pci_device_detectors.size() && detection_is_required.load(); i2c_detector_idx++)
-    {
-        detection_string = i2c_pci_device_detectors[i2c_detector_idx].name.c_str();
-
-        /*-------------------------------------------------*\
-        | Check if this detector is enabled                 |
-        \*-------------------------------------------------*/
-        bool this_device_enabled = true;
-        if(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))
-        {
-            this_device_enabled = detector_settings["detectors"][detection_string];
-        }
-
-        LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
-        if(this_device_enabled)
-        {
-            DetectionProgressChanged();
-
-            for(unsigned int bus = 0; bus < busses.size(); bus++)
-            {
-                if(busses[bus]->pci_vendor           == i2c_pci_device_detectors[i2c_detector_idx].ven_id    &&
-                   busses[bus]->pci_device           == i2c_pci_device_detectors[i2c_detector_idx].dev_id    &&
-                   busses[bus]->pci_subsystem_vendor == i2c_pci_device_detectors[i2c_detector_idx].subven_id &&
-                   busses[bus]->pci_subsystem_device == i2c_pci_device_detectors[i2c_detector_idx].subdev_id)
-                {
-                    i2c_pci_device_detectors[i2c_detector_idx].function(busses[bus], i2c_pci_device_detectors[i2c_detector_idx].i2c_addr, i2c_pci_device_detectors[i2c_detector_idx].name);
-                }
-            }
-        }
-
-        LOG_TRACE("[%s] detection end", detection_string);
-
-        /*-------------------------------------------------*\
-        | Update detection percent                          |
-        \*-------------------------------------------------*/
-        percent = (i2c_device_detectors.size() + i2c_detector_idx + 1.0f) / percent_denominator;
-
-        detection_percent = (unsigned int)(percent * 100.0f);
-    }
-
-    /*-------------------------------------------------*\
-    | Detect HID devices                                |
-    |                                                   |
-    | Reset current device pointer to first device      |
-    \*-------------------------------------------------*/
-    LOG_INFO("------------------------------------------------------");
-    LOG_INFO("|               Detecting HID devices                |");
-    if (hid_safe_mode)
-    LOG_INFO("|                  with safe mode                    |");
-    LOG_INFO("------------------------------------------------------");
-    current_hid_device = hid_devices;
-
-    if(hid_safe_mode)
-    {
-        /*-----------------------------------------------------------------------------*\
-        | Loop through all available detectors.  If all required information matches,   |
-        | run the detector                                                              |
-        \*-----------------------------------------------------------------------------*/
-        for(unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_device_detectors.size() && detection_is_required.load(); hid_detector_idx++)
-        {
-            HIDDeviceDetectorBlock & detector = hid_device_detectors[hid_detector_idx];
-            hid_devices = hid_enumerate(detector.vid, detector.pid);
-
-            LOG_VERBOSE("Trying to run detector for [%s] (for %04x:%04x)", detector.name.c_str(), detector.vid, detector.pid);
-
-            current_hid_device = hid_devices;
-
-            while(current_hid_device)
-            {
-
-                if(detector.compare(current_hid_device))
-                {
-                    detection_string = detector.name.c_str();
-
-                    /*-------------------------------------------------*\
-                    | Check if this detector is enabled or needs to be  |
-                    | added to the settings list                        |
-                    \*-------------------------------------------------*/
-                    bool this_device_enabled = true;
-                    if(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))
-                    {
-                        this_device_enabled = detector_settings["detectors"][detection_string];
-                    }
-
-                    LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
-
-                    if(this_device_enabled)
-                    {
-                        DetectionProgressChanged();
-
-                        detector.function(current_hid_device, hid_device_detectors[hid_detector_idx].name);
-
-                        LOG_TRACE("[%s] detection end", detection_string);
-                    }
-                }
-
-                current_hid_device = current_hid_device->next;
-            }
-
-            hid_free_enumeration(hid_devices);
-        }
-    }
-    else
-    {
-        /*-------------------------------------------------*\
-        | Iterate through all devices in list and run       |
-        | detectors                                         |
-        \*-------------------------------------------------*/
-        hid_device_count = 0;
-
-        while(current_hid_device)
-        {
-            if(LogManager::get()->getLoglevel() >= LL_DEBUG)
-            {
-                const char* manu_name = StringUtils::wchar_to_char(current_hid_device->manufacturer_string);
-                const char* prod_name = StringUtils::wchar_to_char(current_hid_device->product_string);
-                LOG_DEBUG("[%04X:%04X U=%04X P=0x%04X I=%d] %-25s - %s", current_hid_device->vendor_id, current_hid_device->product_id, current_hid_device->usage, current_hid_device->usage_page, current_hid_device->interface_number, manu_name, prod_name);
-            }
-            detection_string = "";
-            DetectionProgressChanged();
-
-            /*-----------------------------------------------------------------------------*\
-            | Loop through all available detectors.  If all required information matches,   |
-            | run the detector                                                              |
-            \*-----------------------------------------------------------------------------*/
-            for(unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_device_detectors.size() && detection_is_required.load(); hid_detector_idx++)
-            {
-                HIDDeviceDetectorBlock & detector = hid_device_detectors[hid_detector_idx];
-                if(detector.compare(current_hid_device))
-                {
-                    detection_string = detector.name.c_str();
-
-                    /*-------------------------------------------------*\
-                    | Check if this detector is enabled or needs to be  |
-                    | added to the settings list                        |
-                    \*-------------------------------------------------*/
-                    bool this_device_enabled = true;
-                    if(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))
-                    {
-                        this_device_enabled = detector_settings["detectors"][detection_string];
-                    }
-
-                    LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
-
-                    if(this_device_enabled)
-                    {
-                        DetectionProgressChanged();
-
-                        detector.function(current_hid_device, hid_device_detectors[hid_detector_idx].name);
-                    }
-                }
-            }
-
-            /*-----------------------------------------------------------------------------*\
-            | Loop through all available wrapped HID detectors.  If all required            |
-            | information matches, run the detector                                         |
-            \*-----------------------------------------------------------------------------*/
-            for(unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_wrapped_device_detectors.size() && detection_is_required.load(); hid_detector_idx++)
-            {
-                HIDWrappedDeviceDetectorBlock & detector = hid_wrapped_device_detectors[hid_detector_idx];
-                if(detector.compare(current_hid_device))
-                {
-                    detection_string = detector.name.c_str();
-
-                    /*-------------------------------------------------*\
-                    | Check if this detector is enabled or needs to be  |
-                    | added to the settings list                        |
-                    \*-------------------------------------------------*/
-                    bool this_device_enabled = true;
-                    if(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))
-                    {
-                        this_device_enabled = detector_settings["detectors"][detection_string];
-                    }
-
-                    LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
-
-                    if(this_device_enabled)
-                    {
-                        DetectionProgressChanged();
-
-                        detector.function(default_wrapper, current_hid_device, hid_wrapped_device_detectors[hid_detector_idx].name);
-                    }
-                }
-            }
-
-            /*-------------------------------------------------*\
-            | Update detection percent                          |
-            \*-------------------------------------------------*/
-            hid_device_count++;
-
-            percent = (i2c_device_detectors.size() + i2c_pci_device_detectors.size() + hid_device_count) / percent_denominator;
-
-            detection_percent = (unsigned int)(percent * 100.0f);
-
-            /*-------------------------------------------------*\
-            | Move on to the next HID device                    |
-            \*-------------------------------------------------*/
-            current_hid_device = current_hid_device->next;
-        }
-
-        /*-------------------------------------------------*\
-        | Done using the device list, free it               |
-        \*-------------------------------------------------*/
-        hid_free_enumeration(hid_devices);
-    }
-
-    /*-------------------------------------------------*\
-    | Detect HID devices                                |
-    |                                                   |
-    | Reset current device pointer to first device      |
-    \*-------------------------------------------------*/
+	/*-------------------------------------------------*\
+	| Detect i2c interfaces                             |
+	\*-------------------------------------------------*/
+	LOG_INFO("------------------------------------------------------");
+	LOG_INFO("|             Detecting I2C interfaces               |");
+	LOG_INFO("------------------------------------------------------");
+
+	bool i2c_interface_fail = false;
+
+	for (unsigned int i2c_bus_detector_idx = 0; i2c_bus_detector_idx < (unsigned int)i2c_bus_detectors.size() && detection_is_required.load();
+		 i2c_bus_detector_idx++) {
+		if (i2c_bus_detectors[i2c_bus_detector_idx]() == false) {
+			i2c_interface_fail = true;
+		}
+
+		I2CBusListChanged();
+	}
+
+	/*-------------------------------------------------*\
+	| Detect i2c devices                                |
+	\*-------------------------------------------------*/
+	LOG_INFO("------------------------------------------------------");
+	LOG_INFO("|               Detecting I2C devices                |");
+	LOG_INFO("------------------------------------------------------");
+	for (unsigned int i2c_detector_idx = 0; i2c_detector_idx < (unsigned int)i2c_device_detectors.size() && detection_is_required.load();
+		 i2c_detector_idx++) {
+		unsigned int controller_size = rgb_controllers_hw.size();
+		detection_string			 = i2c_device_detector_strings[i2c_detector_idx].c_str();
+
+		/*-------------------------------------------------*\
+		| Check if this detector is enabled                 |
+		\*-------------------------------------------------*/
+		bool this_device_enabled = true;
+		if (detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string)) {
+			this_device_enabled = detector_settings["detectors"][detection_string];
+		}
+
+		LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
+		if (this_device_enabled) {
+			DetectionProgressChanged();
+
+			i2c_device_detectors[i2c_detector_idx](busses);
+		}
+
+		/*-------------------------------------------------*\
+		| If the device list size has changed, call the     |
+		| device list changed callbacks                     |
+		\*-------------------------------------------------*/
+		if (rgb_controllers_hw.size() == controller_size) {
+			LOG_DEBUG("[%s] no devices found", detection_string);
+		}
+
+		LOG_TRACE("[%s] detection end", detection_string);
+
+		/*-------------------------------------------------*\
+		| Update detection percent                          |
+		\*-------------------------------------------------*/
+		percent = ((float)i2c_detector_idx + 1.0f) / percent_denominator;
+
+		detection_percent = (unsigned int)(percent * 100.0f);
+	}
+
+	/*-------------------------------------------------*\
+	| Detect i2c PCI devices                            |
+	\*-------------------------------------------------*/
+	LOG_INFO("------------------------------------------------------");
+	LOG_INFO("|               Detecting I2C PCI devices            |");
+	LOG_INFO("------------------------------------------------------");
+	for (unsigned int i2c_detector_idx = 0; i2c_detector_idx < (unsigned int)i2c_pci_device_detectors.size() && detection_is_required.load();
+		 i2c_detector_idx++) {
+		detection_string = i2c_pci_device_detectors[i2c_detector_idx].name.c_str();
+
+		/*-------------------------------------------------*\
+		| Check if this detector is enabled                 |
+		\*-------------------------------------------------*/
+		bool this_device_enabled = true;
+		if (detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string)) {
+			this_device_enabled = detector_settings["detectors"][detection_string];
+		}
+
+		LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
+		if (this_device_enabled) {
+			DetectionProgressChanged();
+
+			for (unsigned int bus = 0; bus < busses.size(); bus++) {
+				if (busses[bus]->pci_vendor == i2c_pci_device_detectors[i2c_detector_idx].ven_id &&
+					busses[bus]->pci_device == i2c_pci_device_detectors[i2c_detector_idx].dev_id &&
+					busses[bus]->pci_subsystem_vendor == i2c_pci_device_detectors[i2c_detector_idx].subven_id &&
+					busses[bus]->pci_subsystem_device == i2c_pci_device_detectors[i2c_detector_idx].subdev_id) {
+					i2c_pci_device_detectors[i2c_detector_idx].function(busses[bus], i2c_pci_device_detectors[i2c_detector_idx].i2c_addr,
+																		i2c_pci_device_detectors[i2c_detector_idx].name);
+				}
+			}
+		}
+
+		LOG_TRACE("[%s] detection end", detection_string);
+
+		/*-------------------------------------------------*\
+		| Update detection percent                          |
+		\*-------------------------------------------------*/
+		percent = (i2c_device_detectors.size() + i2c_detector_idx + 1.0f) / percent_denominator;
+
+		detection_percent = (unsigned int)(percent * 100.0f);
+	}
+
+	/*-------------------------------------------------*\
+	| Detect HID devices                                |
+	|                                                   |
+	| Reset current device pointer to first device      |
+	\*-------------------------------------------------*/
+	LOG_INFO("------------------------------------------------------");
+	LOG_INFO("|               Detecting HID devices                |");
+	if (hid_safe_mode) {
+		LOG_INFO("|                  with safe mode                    |");
+	}
+	LOG_INFO("------------------------------------------------------");
+	current_hid_device = hid_devices;
+
+	if (hid_safe_mode) {
+		/*-----------------------------------------------------------------------------*\
+		| Loop through all available detectors.  If all required information matches,   |
+		| run the detector                                                              |
+		\*-----------------------------------------------------------------------------*/
+		for (unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_device_detectors.size() && detection_is_required.load();
+			 hid_detector_idx++) {
+			HIDDeviceDetectorBlock& detector = hid_device_detectors[hid_detector_idx];
+			hid_devices						 = hid_enumerate(detector.vid, detector.pid);
+
+			LOG_VERBOSE("Trying to run detector for [%s] (for %04x:%04x)", detector.name.c_str(), detector.vid, detector.pid);
+
+			current_hid_device = hid_devices;
+
+			while (current_hid_device) {
+				if (detector.compare(current_hid_device)) {
+					detection_string = detector.name.c_str();
+
+					/*-------------------------------------------------*\
+					| Check if this detector is enabled or needs to be  |
+					| added to the settings list                        |
+					\*-------------------------------------------------*/
+					bool this_device_enabled = true;
+					if (detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string)) {
+						this_device_enabled = detector_settings["detectors"][detection_string];
+					}
+
+					LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
+
+					if (this_device_enabled) {
+						DetectionProgressChanged();
+
+						detector.function(current_hid_device, hid_device_detectors[hid_detector_idx].name);
+
+						LOG_TRACE("[%s] detection end", detection_string);
+					}
+				}
+
+				current_hid_device = current_hid_device->next;
+			}
+
+			hid_free_enumeration(hid_devices);
+		}
+	} else {
+		/*-------------------------------------------------*\
+		| Iterate through all devices in list and run       |
+		| detectors                                         |
+		\*-------------------------------------------------*/
+		hid_device_count = 0;
+
+		while (current_hid_device) {
+			if (LogManager::get()->getLoglevel() >= LL_DEBUG) {
+				const char* manu_name = StringUtils::wchar_to_char(current_hid_device->manufacturer_string);
+				const char* prod_name = StringUtils::wchar_to_char(current_hid_device->product_string);
+				LOG_DEBUG("[%04X:%04X U=%04X P=0x%04X I=%d] %-25s - %s", current_hid_device->vendor_id, current_hid_device->product_id,
+						  current_hid_device->usage, current_hid_device->usage_page, current_hid_device->interface_number, manu_name, prod_name);
+			}
+			detection_string = "";
+			DetectionProgressChanged();
+
+			/*-----------------------------------------------------------------------------*\
+			| Loop through all available detectors.  If all required information matches,   |
+			| run the detector                                                              |
+			\*-----------------------------------------------------------------------------*/
+			for (unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_device_detectors.size() && detection_is_required.load();
+				 hid_detector_idx++) {
+				HIDDeviceDetectorBlock& detector = hid_device_detectors[hid_detector_idx];
+				if (detector.compare(current_hid_device)) {
+					detection_string = detector.name.c_str();
+
+					/*-------------------------------------------------*\
+					| Check if this detector is enabled or needs to be  |
+					| added to the settings list                        |
+					\*-------------------------------------------------*/
+					bool this_device_enabled = true;
+					if (detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string)) {
+						this_device_enabled = detector_settings["detectors"][detection_string];
+					}
+
+					LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
+
+					if (this_device_enabled) {
+						DetectionProgressChanged();
+
+						detector.function(current_hid_device, hid_device_detectors[hid_detector_idx].name);
+					}
+				}
+			}
+
+			/*-----------------------------------------------------------------------------*\
+			| Loop through all available wrapped HID detectors.  If all required            |
+			| information matches, run the detector                                         |
+			\*-----------------------------------------------------------------------------*/
+			for (unsigned int hid_detector_idx = 0;
+				 hid_detector_idx < (unsigned int)hid_wrapped_device_detectors.size() && detection_is_required.load(); hid_detector_idx++) {
+				HIDWrappedDeviceDetectorBlock& detector = hid_wrapped_device_detectors[hid_detector_idx];
+				if (detector.compare(current_hid_device)) {
+					detection_string = detector.name.c_str();
+
+					/*-------------------------------------------------*\
+					| Check if this detector is enabled or needs to be  |
+					| added to the settings list                        |
+					\*-------------------------------------------------*/
+					bool this_device_enabled = true;
+					if (detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string)) {
+						this_device_enabled = detector_settings["detectors"][detection_string];
+					}
+
+					LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
+
+					if (this_device_enabled) {
+						DetectionProgressChanged();
+
+						detector.function(default_wrapper, current_hid_device, hid_wrapped_device_detectors[hid_detector_idx].name);
+					}
+				}
+			}
+
+			/*-------------------------------------------------*\
+			| Update detection percent                          |
+			\*-------------------------------------------------*/
+			hid_device_count++;
+
+			percent = (i2c_device_detectors.size() + i2c_pci_device_detectors.size() + hid_device_count) / percent_denominator;
+
+			detection_percent = (unsigned int)(percent * 100.0f);
+
+			/*-------------------------------------------------*\
+			| Move on to the next HID device                    |
+			\*-------------------------------------------------*/
+			current_hid_device = current_hid_device->next;
+		}
+
+		/*-------------------------------------------------*\
+		| Done using the device list, free it               |
+		\*-------------------------------------------------*/
+		hid_free_enumeration(hid_devices);
+	}
+
+	/*-------------------------------------------------*\
+	| Detect HID devices                                |
+	|                                                   |
+	| Reset current device pointer to first device      |
+	\*-------------------------------------------------*/
 #ifdef __linux__
 #ifdef __GLIBC__
-    LOG_INFO("------------------------------------------------------");
-    LOG_INFO("|            Detecting libusb HID devices            |");
-    LOG_INFO("------------------------------------------------------");
+	LOG_INFO("------------------------------------------------------");
+	LOG_INFO("|            Detecting libusb HID devices            |");
+	LOG_INFO("------------------------------------------------------");
 
-    void *         dyn_handle = NULL;
-    hidapi_wrapper wrapper;
+	void* dyn_handle = NULL;
+	hidapi_wrapper wrapper;
 
-    /*-------------------------------------------------*\
-    | Load the libhidapi-libusb library                 |
-    \*-------------------------------------------------*/
+	/*-------------------------------------------------*\
+	| Load the libhidapi-libusb library                 |
+	\*-------------------------------------------------*/
 #ifdef __GLIBC__
-    if((dyn_handle = dlopen("libhidapi-libusb.so", RTLD_NOW | RTLD_NODELETE | RTLD_DEEPBIND)))
+	if ((dyn_handle = dlopen("libhidapi-libusb.so", RTLD_NOW | RTLD_NODELETE | RTLD_DEEPBIND)))
 #else
-    if(dyn_handle = dlopen("libhidapi-libusb.so", RTLD_NOW | RTLD_NODELETE ))
+	if (dyn_handle = dlopen("libhidapi-libusb.so", RTLD_NOW | RTLD_NODELETE))
 #endif
-    {
-        /*-------------------------------------------------*\
-        | Create a wrapper with the libusb functions        |
-        \*-------------------------------------------------*/
-        wrapper =
-        {
-            .dyn_handle                     = dyn_handle,
-            .hid_send_feature_report        = (hidapi_wrapper_send_feature_report)          dlsym(dyn_handle,"hid_send_feature_report"),
-            .hid_get_feature_report         = (hidapi_wrapper_get_feature_report)           dlsym(dyn_handle,"hid_get_feature_report"),
-            .hid_get_serial_number_string   = (hidapi_wrapper_get_serial_number_string)     dlsym(dyn_handle,"hid_get_serial_number_string"),
-            .hid_open_path                  = (hidapi_wrapper_open_path)                    dlsym(dyn_handle,"hid_open_path"),
-            .hid_enumerate                  = (hidapi_wrapper_enumerate)                    dlsym(dyn_handle,"hid_enumerate"),
-            .hid_free_enumeration           = (hidapi_wrapper_free_enumeration)             dlsym(dyn_handle,"hid_free_enumeration"),
-            .hid_close                      = (hidapi_wrapper_close)                        dlsym(dyn_handle,"hid_close"),
-            .hid_error                      = (hidapi_wrapper_error)                        dlsym(dyn_handle,"hid_free_enumeration")
-        };
-
-        hid_devices = wrapper.hid_enumerate(0, 0);
-
-        current_hid_device = hid_devices;
-
-        /*-------------------------------------------------*\
-        | Iterate through all devices in list and run       |
-        | detectors                                         |
-        \*-------------------------------------------------*/
-        hid_device_count = 0;
-
-        while(current_hid_device)
-        {
-            if(LogManager::get()->getLoglevel() >= LL_DEBUG)
-            {
-                const char* manu_name = StringUtils::wchar_to_char(current_hid_device->manufacturer_string);
-                const char* prod_name = StringUtils::wchar_to_char(current_hid_device->product_string);
-                LOG_DEBUG("[%04X:%04X U=%04X P=0x%04X I=%d] %-25s - %s", current_hid_device->vendor_id, current_hid_device->product_id, current_hid_device->usage, current_hid_device->usage_page, current_hid_device->interface_number, manu_name, prod_name);
-            }
-            detection_string = "";
-            DetectionProgressChanged();
-
-            /*-----------------------------------------------------------------------------*\
-            | Loop through all available wrapped HID detectors.  If all required            |
-            | information matches, run the detector                                         |
-            \*-----------------------------------------------------------------------------*/
-            for(unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_wrapped_device_detectors.size() && detection_is_required.load(); hid_detector_idx++)
-            {
-                HIDWrappedDeviceDetectorBlock & detector = hid_wrapped_device_detectors[hid_detector_idx];
-                if(detector.compare(current_hid_device))
-                {
-                    detection_string = detector.name.c_str();
-
-                    /*-------------------------------------------------*\
-                    | Check if this detector is enabled or needs to be  |
-                    | added to the settings list                        |
-                    \*-------------------------------------------------*/
-                    bool this_device_enabled = true;
-                    if(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))
-                    {
-                        this_device_enabled = detector_settings["detectors"][detection_string];
-                    }
-
-                    LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
-
-                    if(this_device_enabled)
-                    {
-                        DetectionProgressChanged();
-
-                        detector.function(wrapper, current_hid_device, detector.name);
-                    }
-                }
-            }
-
-            /*-------------------------------------------------*\
-            | Update detection percent                          |
-            \*-------------------------------------------------*/
-            hid_device_count++;
-
-            percent = (i2c_device_detectors.size() + i2c_pci_device_detectors.size() + hid_device_count) / percent_denominator;
-
-            detection_percent = percent * 100.0f;
-
-            /*-------------------------------------------------*\
-            | Move on to the next HID device                    |
-            \*-------------------------------------------------*/
-            current_hid_device = current_hid_device->next;
-        }
-
-        /*-------------------------------------------------*\
-        | Done using the device list, free it               |
-        \*-------------------------------------------------*/
-        wrapper.hid_free_enumeration(hid_devices);
-    }
+	{
+		/*-------------------------------------------------*\
+		| Create a wrapper with the libusb functions        |
+		\*-------------------------------------------------*/
+		wrapper = {.dyn_handle					 = dyn_handle,
+				   .hid_send_feature_report		 = (hidapi_wrapper_send_feature_report)dlsym(dyn_handle, "hid_send_feature_report"),
+				   .hid_get_feature_report		 = (hidapi_wrapper_get_feature_report)dlsym(dyn_handle, "hid_get_feature_report"),
+				   .hid_get_serial_number_string = (hidapi_wrapper_get_serial_number_string)dlsym(dyn_handle, "hid_get_serial_number_string"),
+				   .hid_open_path				 = (hidapi_wrapper_open_path)dlsym(dyn_handle, "hid_open_path"),
+				   .hid_enumerate				 = (hidapi_wrapper_enumerate)dlsym(dyn_handle, "hid_enumerate"),
+				   .hid_free_enumeration		 = (hidapi_wrapper_free_enumeration)dlsym(dyn_handle, "hid_free_enumeration"),
+				   .hid_close					 = (hidapi_wrapper_close)dlsym(dyn_handle, "hid_close"),
+				   .hid_error					 = (hidapi_wrapper_error)dlsym(dyn_handle, "hid_free_enumeration")};
+
+		hid_devices = wrapper.hid_enumerate(0, 0);
+
+		current_hid_device = hid_devices;
+
+		/*-------------------------------------------------*\
+		| Iterate through all devices in list and run       |
+		| detectors                                         |
+		\*-------------------------------------------------*/
+		hid_device_count = 0;
+
+		while (current_hid_device) {
+			if (LogManager::get()->getLoglevel() >= LL_DEBUG) {
+				const char* manu_name = StringUtils::wchar_to_char(current_hid_device->manufacturer_string);
+				const char* prod_name = StringUtils::wchar_to_char(current_hid_device->product_string);
+				LOG_DEBUG("[%04X:%04X U=%04X P=0x%04X I=%d] %-25s - %s", current_hid_device->vendor_id, current_hid_device->product_id,
+						  current_hid_device->usage, current_hid_device->usage_page, current_hid_device->interface_number, manu_name, prod_name);
+			}
+			detection_string = "";
+			DetectionProgressChanged();
+
+			/*-----------------------------------------------------------------------------*\
+			| Loop through all available wrapped HID detectors.  If all required            |
+			| information matches, run the detector                                         |
+			\*-----------------------------------------------------------------------------*/
+			for (unsigned int hid_detector_idx = 0;
+				 hid_detector_idx < (unsigned int)hid_wrapped_device_detectors.size() && detection_is_required.load(); hid_detector_idx++) {
+				HIDWrappedDeviceDetectorBlock& detector = hid_wrapped_device_detectors[hid_detector_idx];
+				if (detector.compare(current_hid_device)) {
+					detection_string = detector.name.c_str();
+
+					/*-------------------------------------------------*\
+					| Check if this detector is enabled or needs to be  |
+					| added to the settings list                        |
+					\*-------------------------------------------------*/
+					bool this_device_enabled = true;
+					if (detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string)) {
+						this_device_enabled = detector_settings["detectors"][detection_string];
+					}
+
+					LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
+
+					if (this_device_enabled) {
+						DetectionProgressChanged();
+
+						detector.function(wrapper, current_hid_device, detector.name);
+					}
+				}
+			}
+
+			/*-------------------------------------------------*\
+			| Update detection percent                          |
+			\*-------------------------------------------------*/
+			hid_device_count++;
+
+			percent = (i2c_device_detectors.size() + i2c_pci_device_detectors.size() + hid_device_count) / percent_denominator;
+
+			detection_percent = percent * 100.0f;
+
+			/*-------------------------------------------------*\
+			| Move on to the next HID device                    |
+			\*-------------------------------------------------*/
+			current_hid_device = current_hid_device->next;
+		}
+
+		/*-------------------------------------------------*\
+		| Done using the device list, free it               |
+		\*-------------------------------------------------*/
+		wrapper.hid_free_enumeration(hid_devices);
+	}
 #endif
 #endif
 
-    /*-------------------------------------------------*\
-    | Detect other devices                              |
-    \*-------------------------------------------------*/
-    LOG_INFO("------------------------------------------------------");
-    LOG_INFO("|              Detecting other devices               |");
-    LOG_INFO("------------------------------------------------------");
+	/*-------------------------------------------------*\
+	| Detect other devices                              |
+	\*-------------------------------------------------*/
+	LOG_INFO("------------------------------------------------------");
+	LOG_INFO("|              Detecting other devices               |");
+	LOG_INFO("------------------------------------------------------");
 
-    for(unsigned int detector_idx = 0; detector_idx < (unsigned int)device_detectors.size() && detection_is_required.load(); detector_idx++)
-    {
-        detection_string = device_detector_strings[detector_idx].c_str();
+	for (unsigned int detector_idx = 0; detector_idx < (unsigned int)device_detectors.size() && detection_is_required.load(); detector_idx++) {
+		detection_string = device_detector_strings[detector_idx].c_str();
 
-        /*-------------------------------------------------*\
-        | Check if this detector is enabled                 |
-        \*-------------------------------------------------*/
-        bool this_device_enabled = true;
-        if(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))
-        {
-            this_device_enabled = detector_settings["detectors"][detection_string];
-        }
+		/*-------------------------------------------------*\
+		| Check if this detector is enabled                 |
+		\*-------------------------------------------------*/
+		bool this_device_enabled = true;
+		if (detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string)) {
+			this_device_enabled = detector_settings["detectors"][detection_string];
+		}
 
-        LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
+		LOG_DEBUG("[%s] is %s", detection_string, ((this_device_enabled == true) ? "enabled" : "disabled"));
 
-        if(this_device_enabled)
-        {
-            DetectionProgressChanged();
+		if (this_device_enabled) {
+			DetectionProgressChanged();
 
-            device_detectors[detector_idx]();
-        }
+			device_detectors[detector_idx]();
+		}
 
-        LOG_TRACE("[%s] detection end", detection_string);
+		LOG_TRACE("[%s] detection end", detection_string);
 
-        /*-------------------------------------------------*\
-        | Update detection percent                          |
-        \*-------------------------------------------------*/
-        percent = (i2c_device_detectors.size() + hid_device_count + detector_idx + 1.0f) / percent_denominator;
+		/*-------------------------------------------------*\
+		| Update detection percent                          |
+		\*-------------------------------------------------*/
+		percent = (i2c_device_detectors.size() + hid_device_count + detector_idx + 1.0f) / percent_denominator;
 
-        detection_percent = (unsigned int)(percent * 100.0f);
-    }
+		detection_percent = (unsigned int)(percent * 100.0f);
+	}
 
-    /*-------------------------------------------------*\
-    | Make sure that when the detection is done,        |
-    | progress bar is set to 100%                       |
-    \*-------------------------------------------------*/
-    ProcessPostDetection();
+	/*-------------------------------------------------*\
+	| Make sure that when the detection is done,        |
+	| progress bar is set to 100%                       |
+	\*-------------------------------------------------*/
+	ProcessPostDetection();
 
-    DetectDeviceMutex.unlock();
+	DetectDeviceMutex.unlock();
 
 #ifdef __linux__
-    /*-------------------------------------------------*\
-    | If the udev rules file is not installed, show a   |
-    | dialog                                            |
-    \*-------------------------------------------------*/
-    if(udev_not_exist)
-    {
-        const char* message =  "<h2>WARNING:</h2>"
-                                "<p>The OpenRGB udev rules are not installed.</p>"
-                                "<p>Most devices will not be available unless running OpenRGB as root.</p>"
-                                "<p>If using AppImage, Flatpak, or self-compiled versions of OpenRGB you must install the udev rules manually</p>"
-                                "<p>See <a href='https://openrgb.org/udev'>https://openrgb.org/udev</a> to install the udev rules manually</p>";
-
-        LOG_DIALOG("%s", message);
-
-        udev_multiple       = false;
-        i2c_interface_fail  = false;
-    }
-
-    /*-------------------------------------------------*\
-    | If multiple udev rules files are installed, show  |
-    | a dialog                                          |
-    \*-------------------------------------------------*/
-    if(udev_multiple)
-    {
-        const char* message =  "<h2>WARNING:</h2>"
-                                "<p>Multiple OpenRGB udev rules are installed.</p>"
-                                "<p>The udev rules file 60-openrgb.rules is installed in both /etc/udev/rules.d and /usr/lib/udev/rules.d.</p>"
-                                "<p>Multiple udev rules files can conflict, it is recommended to remove one of them.</p>";
-
-        LOG_DIALOG("%s", message);
-
-        i2c_interface_fail  = false;
-    }
+	/*-------------------------------------------------*\
+	| If the udev rules file is not installed, show a   |
+	| dialog                                            |
+	\*-------------------------------------------------*/
+	if (udev_not_exist) {
+		const char* message = "<h2>WARNING:</h2>"
+							  "<p>The OpenRGB udev rules are not installed.</p>"
+							  "<p>Most devices will not be available unless running OpenRGB as root.</p>"
+							  "<p>If using AppImage, Flatpak, or self-compiled versions of OpenRGB you must install the udev rules manually</p>"
+							  "<p>See <a href='https://openrgb.org/udev'>https://openrgb.org/udev</a> to install the udev rules manually</p>";
+
+		LOG_DIALOG("%s", message);
+
+		udev_multiple	   = false;
+		i2c_interface_fail = false;
+	}
+
+	/*-------------------------------------------------*\
+	| If multiple udev rules files are installed, show  |
+	| a dialog                                          |
+	\*-------------------------------------------------*/
+	if (udev_multiple) {
+		const char* message = "<h2>WARNING:</h2>"
+							  "<p>Multiple OpenRGB udev rules are installed.</p>"
+							  "<p>The udev rules file 60-openrgb.rules is installed in both /etc/udev/rules.d and /usr/lib/udev/rules.d.</p>"
+							  "<p>Multiple udev rules files can conflict, it is recommended to remove one of them.</p>";
+
+		LOG_DIALOG("%s", message);
+
+		i2c_interface_fail = false;
+	}
 
 #endif
 
-    /*-------------------------------------------------*\
-    | If any i2c interfaces failed to detect due to an  |
-    | error condition, show a dialog                    |
-    \*-------------------------------------------------*/
-    if(i2c_interface_fail)
-    {
-        const char* message =   "<h2>Some internal devices may not be detected:</h2>"
-                                "<p>One or more I2C or SMBus interfaces failed to initialize.</p>"
-                                "<p><b>RGB DRAM modules, some motherboards' onboard RGB lighting, and RGB Graphics Cards, will not be available in OpenRGB</b> without I2C or SMBus.</p>"
-
-                                "<h4>How to fix this:</h4>"
+	/*-------------------------------------------------*\
+	| If any i2c interfaces failed to detect due to an  |
+	| error condition, show a dialog                    |
+	\*-------------------------------------------------*/
+	if (i2c_interface_fail) {
+		const char* message = "<h2>Some internal devices may not be detected:</h2>"
+							  "<p>One or more I2C or SMBus interfaces failed to initialize.</p>"
+							  "<p><b>RGB DRAM modules, some motherboards' onboard RGB lighting, and RGB Graphics Cards, will not be available in "
+							  "OpenRGB</b> without I2C or SMBus.</p>"
+
+							  "<h4>How to fix this:</h4>"
 #ifdef _WIN32
-                                "<p>On Windows, this is usually caused by a failure to load the WinRing0 driver.</p>"
-                                "<p>You must run OpenRGB as administrator at least once to allow WinRing0 to set up.</p>"
+							  "<p>On Windows, this is usually caused by a failure to load the WinRing0 driver.</p>"
+							  "<p>You must run OpenRGB as administrator at least once to allow WinRing0 to set up.</p>"
 #endif
 #ifdef __linux__
-                                "<p>On Linux, this is usually because the i2c-dev module is not loaded.</p>"
-                                "<p>You must load the i2c-dev module along with the correct i2c driver for your motherboard. "
-                                "This is usually i2c-piix4 for AMD systems and i2c-i801 for Intel systems.</p>"
+							  "<p>On Linux, this is usually because the i2c-dev module is not loaded.</p>"
+							  "<p>You must load the i2c-dev module along with the correct i2c driver for your motherboard. "
+							  "This is usually i2c-piix4 for AMD systems and i2c-i801 for Intel systems.</p>"
 #endif
-                                "<p>See <a href='https://help.openrgb.org/'>help.openrgb.org</a> for additional troubleshooting steps if you keep seeing this message.<br></p>"
-                                "<h3>If you are not using internal RGB on a desktop this message is not important to you.</h3>";
+							  "<p>See <a href='https://help.openrgb.org/'>help.openrgb.org</a> for additional troubleshooting steps if you keep "
+							  "seeing this message.<br></p>"
+							  "<h3>If you are not using internal RGB on a desktop this message is not important to you.</h3>";
 
-        LOG_DIALOG("%s", message);
-    }
+		LOG_DIALOG("%s", message);
+	}
 }
 
-void ResourceManager::StopDeviceDetection()
-{
-    LOG_INFO("Detection abort requested");
-    detection_is_required = false;
-    detection_percent = 100;
-    detection_string = "Stopping";
+void ResourceManager::StopDeviceDetection() {
+	LOG_INFO("Detection abort requested");
+	detection_is_required = false;
+	detection_percent	  = 100;
+	detection_string	  = "Stopping";
 }
 
-void ResourceManager::Initialize(bool tryConnect, bool detectDevices, bool startServer, bool applyPostOptions)
-{
-    // Cache the parameters
-    // TODO: Possibly cache them in the CLI file somewhere
-    tryAutoConnect     = tryConnect;
-    detection_enabled  = detectDevices;
-    start_server       = startServer;
-    apply_post_options = applyPostOptions;
+void ResourceManager::Initialize(bool tryConnect, bool detectDevices, bool startServer, bool applyPostOptions) {
+	// Cache the parameters
+	// TODO: Possibly cache them in the CLI file somewhere
+	tryAutoConnect	   = tryConnect;
+	detection_enabled  = detectDevices;
+	start_server	   = startServer;
+	apply_post_options = applyPostOptions;
 
-    InitThread = new std::thread(&ResourceManager::InitThreadFunction, this);
+	InitThread = new std::thread(&ResourceManager::InitThreadFunction, this);
 }
 
-void ResourceManager::InitThreadFunction()
-{
-    if(tryAutoConnect)
-    {
-        detection_percent = 0;
-        detection_string  = "Attempting server connection...";
-        DetectionProgressChanged();
-
-        // Disable detection if a local server was found
-        if(AttemptLocalConnection())
-        {
-            DisableDetection();
-        }
-        else
-        {
-            LOG_DEBUG("[ResourceManager] Local OpenRGB server connected, running in client mode");
-        }
-        tryAutoConnect = false;
-    }
-
-    /*---------------------------------------------------------*\
-    | Perform actual detection                                  |
-    | Done in the same thread (InitThread), as we need to wait  |
-    | for completion anyway                                     |
-    \*---------------------------------------------------------*/
-    if(detection_enabled)
-    {
-        LOG_DEBUG("[ResourceManager] Running standalone");
-        if(ProcessPreDetection())
-        {
-            DetectDevicesThreadFunction();
-        }
-    }
-    else
-    {
-        ProcessPostDetection();
-    }
-
-    if(start_server)
-    {
-        detection_percent = 100;
-        detection_string = "Starting server";
-        DetectionProgressChanged();
-
-        GetServer()->StartServer();
-        if(!GetServer()->GetOnline())
-        {
-            LOG_DEBUG("[ResourceManager] Server failed to start");
-        }
-    }
-
-    /*---------------------------------------------------------*\
-    | Process command line arguments after detection only if the|
-    | pre-detection parsing indicated it should be run          |
-    \*---------------------------------------------------------*/
-    if(apply_post_options)
-    {
-        cli_post_detection();
-    }
-
-    init_finished = true;
+void ResourceManager::InitThreadFunction() {
+	if (tryAutoConnect) {
+		detection_percent = 0;
+		detection_string  = "Attempting server connection...";
+		DetectionProgressChanged();
+
+		// Disable detection if a local server was found
+		if (AttemptLocalConnection()) {
+			DisableDetection();
+		} else {
+			LOG_DEBUG("[ResourceManager] Local OpenRGB server connected, running in client mode");
+		}
+		tryAutoConnect = false;
+	}
+
+	/*---------------------------------------------------------*\
+	| Perform actual detection                                  |
+	| Done in the same thread (InitThread), as we need to wait  |
+	| for completion anyway                                     |
+	\*---------------------------------------------------------*/
+	if (detection_enabled) {
+		LOG_DEBUG("[ResourceManager] Running standalone");
+		if (ProcessPreDetection()) {
+			DetectDevicesThreadFunction();
+		}
+	} else {
+		ProcessPostDetection();
+	}
+
+	if (start_server) {
+		detection_percent = 100;
+		detection_string  = "Starting server";
+		DetectionProgressChanged();
+
+		GetServer()->StartServer();
+		if (!GetServer()->GetOnline()) {
+			LOG_DEBUG("[ResourceManager] Server failed to start");
+		}
+	}
+
+	/*---------------------------------------------------------*\
+	| Process command line arguments after detection only if the|
+	| pre-detection parsing indicated it should be run          |
+	\*---------------------------------------------------------*/
+	if (apply_post_options) {
+		cli_post_detection();
+	}
+
+	init_finished = true;
 }
 
-void ResourceManager::UpdateDetectorSettings()
-{
-    json                detector_settings;
-    bool                save_settings       = false;
-
-    /*-------------------------------------------------*\
-    | Open device disable list and read in disabled     |
-    | device strings                                    |
-    \*-------------------------------------------------*/
-    detector_settings = settings_manager->GetSettings("Detectors");
-
-    /*-------------------------------------------------*\
-    | Loop through all I2C detectors and see if any     |
-    | need to be saved to the settings                  |
-    \*-------------------------------------------------*/
-    for(unsigned int i2c_detector_idx = 0; i2c_detector_idx < (unsigned int)i2c_device_detectors.size(); i2c_detector_idx++)
-    {
-        detection_string = i2c_device_detector_strings[i2c_detector_idx].c_str();
-
-        if(!(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string)))
-        {
-            detector_settings["detectors"][detection_string] = true;
-            save_settings = true;
-        }
-    }
-
-    /*-------------------------------------------------*\
-    | Loop through all I2C PCI detectors and see if any |
-    | need to be saved to the settings                  |
-    \*-------------------------------------------------*/
-    for(unsigned int i2c_pci_detector_idx = 0; i2c_pci_detector_idx < (unsigned int)i2c_pci_device_detectors.size(); i2c_pci_detector_idx++)
-    {
-        detection_string = i2c_pci_device_detectors[i2c_pci_detector_idx].name.c_str();
-
-        if(!(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string)))
-        {
-            detector_settings["detectors"][detection_string] = true;
-            save_settings = true;
-        }
-    }
-
-    /*-------------------------------------------------*\
-    | Loop through all HID detectors and see if any     |
-    | need to be saved to the settings                  |
-    \*-------------------------------------------------*/
-    for(unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_device_detectors.size(); hid_detector_idx++)
-    {
-        detection_string = hid_device_detectors[hid_detector_idx].name.c_str();
-
-        if(!(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string)))
-        {
-            detector_settings["detectors"][detection_string] = true;
-            save_settings = true;
-        }
-    }
-
-    /*-------------------------------------------------*\
-    | Loop through all HID wrapped detectors and see if |
-    | any need to be saved to the settings              |
-    \*-------------------------------------------------*/
-    for(unsigned int hid_wrapped_detector_idx = 0; hid_wrapped_detector_idx < (unsigned int)hid_wrapped_device_detectors.size(); hid_wrapped_detector_idx++)
-    {
-        detection_string = hid_wrapped_device_detectors[hid_wrapped_detector_idx].name.c_str();
-
-        if(!(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string)))
-        {
-            detector_settings["detectors"][detection_string] = true;
-            save_settings = true;
-        }
-    }
-
-    /*-------------------------------------------------*\
-    | Loop through remaining detectors and see if any   |
-    | need to be saved to the settings                  |
-    \*-------------------------------------------------*/
-    for(unsigned int detector_idx = 0; detector_idx < (unsigned int)device_detectors.size(); detector_idx++)
-    {
-        detection_string = device_detector_strings[detector_idx].c_str();
-
-        if(!(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string)))
-        {
-            detector_settings["detectors"][detection_string] = true;
-            save_settings = true;
-        }
-    }
-
-    /*-------------------------------------------------*\
-    | If there were any setting changes that need to be |
-    | saved, set the settings in the settings manager   |
-    | and save them.                                    |
-    \*-------------------------------------------------*/
-    if(save_settings)
-    {
-        LOG_INFO("Saving detector settings");
-
-        settings_manager->SetSettings("Detectors", detector_settings);
-
-        settings_manager->SaveSettings();
-    }
+void ResourceManager::UpdateDetectorSettings() {
+	json detector_settings;
+	bool save_settings = false;
+
+	/*-------------------------------------------------*\
+	| Open device disable list and read in disabled     |
+	| device strings                                    |
+	\*-------------------------------------------------*/
+	detector_settings = settings_manager->GetSettings("Detectors");
+
+	/*-------------------------------------------------*\
+	| Loop through all I2C detectors and see if any     |
+	| need to be saved to the settings                  |
+	\*-------------------------------------------------*/
+	for (unsigned int i2c_detector_idx = 0; i2c_detector_idx < (unsigned int)i2c_device_detectors.size(); i2c_detector_idx++) {
+		detection_string = i2c_device_detector_strings[i2c_detector_idx].c_str();
+
+		if (!(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))) {
+			detector_settings["detectors"][detection_string] = true;
+			save_settings									 = true;
+		}
+	}
+
+	/*-------------------------------------------------*\
+	| Loop through all I2C PCI detectors and see if any |
+	| need to be saved to the settings                  |
+	\*-------------------------------------------------*/
+	for (unsigned int i2c_pci_detector_idx = 0; i2c_pci_detector_idx < (unsigned int)i2c_pci_device_detectors.size(); i2c_pci_detector_idx++) {
+		detection_string = i2c_pci_device_detectors[i2c_pci_detector_idx].name.c_str();
+
+		if (!(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))) {
+			detector_settings["detectors"][detection_string] = true;
+			save_settings									 = true;
+		}
+	}
+
+	/*-------------------------------------------------*\
+	| Loop through all HID detectors and see if any     |
+	| need to be saved to the settings                  |
+	\*-------------------------------------------------*/
+	for (unsigned int hid_detector_idx = 0; hid_detector_idx < (unsigned int)hid_device_detectors.size(); hid_detector_idx++) {
+		detection_string = hid_device_detectors[hid_detector_idx].name.c_str();
+
+		if (!(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))) {
+			detector_settings["detectors"][detection_string] = true;
+			save_settings									 = true;
+		}
+	}
+
+	/*-------------------------------------------------*\
+	| Loop through all HID wrapped detectors and see if |
+	| any need to be saved to the settings              |
+	\*-------------------------------------------------*/
+	for (unsigned int hid_wrapped_detector_idx = 0; hid_wrapped_detector_idx < (unsigned int)hid_wrapped_device_detectors.size();
+		 hid_wrapped_detector_idx++) {
+		detection_string = hid_wrapped_device_detectors[hid_wrapped_detector_idx].name.c_str();
+
+		if (!(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))) {
+			detector_settings["detectors"][detection_string] = true;
+			save_settings									 = true;
+		}
+	}
+
+	/*-------------------------------------------------*\
+	| Loop through remaining detectors and see if any   |
+	| need to be saved to the settings                  |
+	\*-------------------------------------------------*/
+	for (unsigned int detector_idx = 0; detector_idx < (unsigned int)device_detectors.size(); detector_idx++) {
+		detection_string = device_detector_strings[detector_idx].c_str();
+
+		if (!(detector_settings.contains("detectors") && detector_settings["detectors"].contains(detection_string))) {
+			detector_settings["detectors"][detection_string] = true;
+			save_settings									 = true;
+		}
+	}
+
+	/*-------------------------------------------------*\
+	| If there were any setting changes that need to be |
+	| saved, set the settings in the settings manager   |
+	| and save them.                                    |
+	\*-------------------------------------------------*/
+	if (save_settings) {
+		LOG_INFO("Saving detector settings");
+
+		settings_manager->SetSettings("Detectors", detector_settings);
+
+		settings_manager->SaveSettings();
+	}
 }
 
-void ResourceManager::WaitForInitialization()
-{
-    /*-------------------------------------------------*\
-    | A reliable sychronization of this kind is         |
-    | impossible without the use of a `barrier`         |
-    | implementation, which is only introduced in C++20 |
-    \*-------------------------------------------------*/
-    while (!init_finished)
-    {
-        std::this_thread::sleep_for(1ms);
-    };
+void ResourceManager::WaitForInitialization() {
+	/*-------------------------------------------------*\
+	| A reliable sychronization of this kind is         |
+	| impossible without the use of a `barrier`         |
+	| implementation, which is only introduced in C++20 |
+	\*-------------------------------------------------*/
+	while (!init_finished) {
+		std::this_thread::sleep_for(1ms);
+	};
 }
 
-void ResourceManager::WaitForDeviceDetection()
-{
-    DetectDeviceMutex.lock();
-    DetectDeviceMutex.unlock();
+void ResourceManager::WaitForDeviceDetection() {
+	DetectDeviceMutex.lock();
+	DetectDeviceMutex.unlock();
 }
diff --git a/build.sh b/build.sh
index ebc7370d..e6b8840f 100755
--- a/build.sh
+++ b/build.sh
@@ -1,9 +1,15 @@
-podman build -t openrgb-build .
-rm -R ./build
-mkdir build
-podman run --rm --privileged --cpus=$(nproc) -v $(pwd):/input openrgb-build
-if [ -f ./build/openrgb ]; then
-    ./OpenRGB.AppImage --appimage-extract
-    cp ./build/openrgb squashfs-root/usr/bin/OpenRGB
-    ./appimagetool squashfs-root/ ./OpenRGB.AppImage
-fi
\ No newline at end of file
+#!/bin/sh
+
+set -e
+
+rm -rf build squashfs-root
+mkdir -p build
+cd build
+
+cmake -DCMAKE_BUILD_TYPE=Release -G Ninja ..
+cmake --build . -j$(nproc)
+
+cd ..
+
+chmod +x scripts/build-udev-rules.sh .
+./scripts/build-udev-rules.sh .
\ No newline at end of file
diff --git a/dependencies/ColorWheel/ColorWheel.cpp b/dependencies/ColorWheel/ColorWheel.cpp
deleted file mode 100644
index 9a91c034..00000000
--- a/dependencies/ColorWheel/ColorWheel.cpp
+++ /dev/null
@@ -1,518 +0,0 @@
-/*-----------------------------------------------------*\
-| ColorWheel.cpp                                        |
-|                                                       |
-|  Color wheel selector widget for Qt                   |
-|                                                       |
-|  Original: https://github.com/liuyanghejerry/Qt-Plus  |
-|                                                       |
-|  Modified by Adam Honse (calcprogrammer1@gmail.com)   |
-\*-----------------------------------------------------*/
-
-#include "ColorWheel.h"
-#include <QPainter>
-#include <QResizeEvent>
-#include <QStyleOption>
-#include <QtCore/qmath.h>
-#include <QDebug>
-#include <QPainterPath>
-
-ColorWheel::ColorWheel(QWidget *parent) :
-    QWidget(parent),
-    initSize(128,128),
-    mouseDown(false),
-    margin(0),
-    wheelWidth(10),
-    current(Qt::red),
-    inWheel(false),
-    inSquare(false)
-{
-    current = current.toHsv();
-}
-
-QColor ColorWheel::color()
-{
-    return current;
-}
-
-void ColorWheel::setColor(const QColor &color)
-{
-    if(color == current) return;
-    if(color.hue() != current.hue())
-    {
-        hueChanged(color.hue());
-    }
-
-    if((color.saturation() != current.saturation()) || (color.value() != current.value()))
-    {
-        svChanged(color);
-    }
-
-    update();
-    emit colorChanged(color);
-}
-
-
-QColor ColorWheel::posColor(const QPoint &point)
-{
-    /*-----------------------------------------------------*\
-    | Subtract offsets from point value                     |
-    \*-----------------------------------------------------*/
-    int point_x = point.x() - x_offset;
-    int point_y = point.y() - y_offset;
-
-    /*-----------------------------------------------------*\
-    | If point is not within widget, don't process          |
-    \*-----------------------------------------------------*/
-    if(!wheel.rect().contains(point))
-    {
-        return QColor();
-    }
-
-    /*-----------------------------------------------------*\
-    | If within wheel region, update hue from point         |
-    | position                                              |
-    \*-----------------------------------------------------*/
-    if(inWheel)
-    {
-        qreal hue = 0;
-        int r = qMin(width() - x_offset, height() - y_offset) / 2;
-        if( point_x > r )
-        {
-            if(point_y < r )
-            {
-                //1
-                hue = 90 - (qAtan2( (point_x - r) , (r - point_y) )  / 3.14 / 2 * 360);
-            }
-            else
-            {
-                //4
-                hue = 270 + (qAtan2( (point_x - r) , (point_y - r ) )  / 3.14 / 2 * 360);
-            }
-        }
-        else
-        {
-            if(point_y < r )
-            {
-                //2
-                hue =  90 + (qAtan2( (r - point_x) , (r - point_y) )  / 3.14 / 2 * 360);
-            }
-            else
-            {
-                //3
-                hue =  270 - (qAtan2( (r - point_x) , (point_y - r ))  / 3.14 / 2 * 360);
-            }
-        }
-
-        /*-----------------------------------------------------*\
-        | Restrict hue to range 0-359                           |
-        \*-----------------------------------------------------*/
-        hue = (hue > 359) ? 359 : hue;
-        hue = hue < 0 ? 0 : hue;
-
-        return QColor::fromHsv(hue,
-                               current.saturation(),
-                               current.value());
-    }
-
-    /*-----------------------------------------------------*\
-    | If within square region, update saturation and value  |
-    | from point position                                   |
-    \*-----------------------------------------------------*/
-    if(inSquare)
-    {
-        // region of the widget
-        int w = qMin(width() - x_offset, height() - y_offset);
-
-        // radius of outer circle
-        qreal r = w/2 - margin;
-
-        // radius of inner circle
-        qreal ir = r - wheelWidth;
-
-        // left corner of square
-        qreal m = w/2.0 - ir/qSqrt(2);
-
-        QPoint p = point - QPoint(x_offset, y_offset) - QPoint(m, m);
-        qreal SquareWidth = 2*ir/qSqrt(2);
-        return QColor::fromHsvF( current.hueF(),
-                                 p.x()/SquareWidth,
-                                 p.y()/SquareWidth);
-    }
-    return QColor();
-}
-
-QSize ColorWheel::sizeHint () const
-{
-    return QSize(height(),height());
-}
-
-QSize ColorWheel::minimumSizeHint () const
-{
-    return initSize;
-}
-
-void ColorWheel::mousePressEvent(QMouseEvent *event)
-{
-    /*-----------------------------------------------------*\
-    | Update last position                                  |
-    \*-----------------------------------------------------*/
-    lastPos = event->pos();
-
-    /*-----------------------------------------------------*\
-    | If mouse is within wheel region, process wheel (hue)  |
-    \*-----------------------------------------------------*/
-    if(wheelRegion.contains(lastPos))
-    {
-        inWheel = true;
-        inSquare = false;
-        QColor color = posColor(lastPos);
-        hueChanged(color.hue());
-    }
-
-    /*-----------------------------------------------------*\
-    | If mouse is within square region, process square      |
-    | (saturation and value)                                |
-    \*-----------------------------------------------------*/
-    else if(squareRegion.contains(lastPos))
-    {
-        inWheel = false;
-        inSquare = true;
-        QColor color = posColor(lastPos);
-        svChanged(color);
-    }
-
-    /*-----------------------------------------------------*\
-    | Set the mouse down flag                               |
-    \*-----------------------------------------------------*/
-    mouseDown = true;
-}
-
-void ColorWheel::mouseMoveEvent(QMouseEvent *event)
-{
-    /*-----------------------------------------------------*\
-    | Update last position                                  |
-    \*-----------------------------------------------------*/
-    lastPos = event->pos();
-
-    /*-----------------------------------------------------*\
-    | Don't process if mouse button is not down             |
-    \*-----------------------------------------------------*/
-    if(!mouseDown)
-    {
-        return;
-    }
-
-    /*-----------------------------------------------------*\
-    | If mouse is within wheel region, process wheel (hue)  |
-    \*-----------------------------------------------------*/
-    if(wheelRegion.contains(lastPos) && inWheel)
-    {
-        QColor color = posColor(lastPos);
-        hueChanged(color.hue());
-    }
-
-    /*-----------------------------------------------------*\
-    | If mouse is within square region, process square      |
-    | (saturation and value)                                |
-    \*-----------------------------------------------------*/
-    else if(squareRegion.contains(lastPos) && inSquare)
-    {
-        QColor color = posColor(lastPos);
-        svChanged(color);
-    }
-    else
-    {
-        // TODO: due with cursor out of region after press
-        //        int length = qMin(width(), height());
-        //        QPoint center(length/2, length/2);
-        //        int R = qSqrt(qPow(qAbs(lastPos.x()), 2)
-        //                      + qPow(qAbs(lastPos.y()), 2));
-        //        if(inWheel){
-        //            int r =  length / 2;
-        //            r += qSqrt(qPow(center.x(), 2) + qPow(center.y(), 2));
-        //            int x0 = r/R * qAbs(lastPos.x());
-        //            int y0 = r/R * qAbs(lastPos.y());
-        //            QColor color = posColor(QPoint(x0, y0));
-        //            hueChanged(color.hue());
-        //        }else if(inSquare){
-        //            //
-        //        }
-    }
-}
-
-void ColorWheel::mouseReleaseEvent(QMouseEvent *)
-{
-    /*-----------------------------------------------------*\
-    | Clear mouse down and in-region flags                  |
-    \*-----------------------------------------------------*/
-    mouseDown   = false;
-    inWheel     = false;
-    inSquare    = false;
-}
-
-void ColorWheel::resizeEvent(QResizeEvent *event)
-{
-    unsigned int size = 0;
-
-    if(event->size().width() < event->size().height())
-    {
-        size = event->size().width();
-    }
-    else
-    {
-        size = event->size().height();
-    }
-
-    wheelWidth = 0.1 * size;
-
-    wheel = QPixmap(event->size());
-    wheel.fill(Qt::transparent);
-    drawWheelImage(event->size());
-    drawSquareImage(current.hue());
-    update();
-}
-
-void ColorWheel::paintEvent(QPaintEvent *)
-{
-    QPainter painter(this);
-    QStyleOption opt;
-    opt.initFrom(this);
-    composeWheel();
-    painter.drawPixmap(0,0,wheel);
-    style()->drawPrimitive(QStyle::PE_Widget, &opt, &painter, this);
-}
-
-void ColorWheel::drawWheelImage(const QSize &newSize)
-{
-    /*-----------------------------------------------------*\
-    | Create image canvas                                   |
-    \*-----------------------------------------------------*/
-    wheelImage = QImage(newSize, QImage::Format_ARGB32_Premultiplied);
-
-    /*-----------------------------------------------------*\
-    | Paint the background                                  |
-    \*-----------------------------------------------------*/
-    wheelImage.fill(Qt::transparent);
-
-    /*-----------------------------------------------------*\
-    | Create rainbow gradient for wheel                     |
-    \*-----------------------------------------------------*/
-    QConicalGradient conicalGradient(0, 0, 0);
-    conicalGradient.setColorAt(0.0,           Qt::red);
-    conicalGradient.setColorAt(60.0  / 360.0, Qt::yellow);
-    conicalGradient.setColorAt(120.0 / 360.0, Qt::green);
-    conicalGradient.setColorAt(180.0 / 360.0, Qt::cyan);
-    conicalGradient.setColorAt(240.0 / 360.0, Qt::blue);
-    conicalGradient.setColorAt(300.0 / 360.0, Qt::magenta);
-    conicalGradient.setColorAt(1.0,           Qt::red);
-
-    /*-----------------------------------------------------*\
-    | Set up painter with antialiasing                      |
-    \*-----------------------------------------------------*/
-    QPainter painter(&wheelImage);
-    painter.setRenderHint(QPainter::Antialiasing);
-
-    /*-----------------------------------------------------*\
-    | Paint the wheel                                       |
-    \*-----------------------------------------------------*/
-    int size = qMin(newSize.width(), newSize.height());
-    x_offset = (newSize.width() - size) / 2;
-    y_offset = (newSize.height() - size) / 2;
-    int r = size;
-
-    QPainterPath painterpath;
-    painterpath.addEllipse(QPoint(0,0),r/2-margin,r/2-margin);
-    painterpath.addEllipse(QPoint(0,0),r/2-margin-wheelWidth,r/2-margin-wheelWidth);
-
-    painter.translate(x_offset + (size / 2), y_offset + (size / 2));
-
-    QBrush brush(conicalGradient);
-    painter.setPen(Qt::NoPen);
-    painter.setBrush(brush);
-
-    painter.drawPath(painterpath);
-
-    /*-----------------------------------------------------*\
-    | Calculate wheel region and subtract out the inner     |
-    | region                                                |
-    \*-----------------------------------------------------*/
-    wheelRegion = QRegion(r/2, r/2, r-2*margin, r-2*margin, QRegion::Ellipse);
-    wheelRegion.translate(x_offset - (r-2*margin)/2, y_offset - (r-2*margin)/2);
-
-    int tmp = 2*(margin+wheelWidth);
-    QRegion subRe( r/2, r/2, r-tmp, r-tmp, QRegion::Ellipse );
-    subRe.translate( x_offset - (r-tmp)/2, y_offset - (r-tmp)/2);
-    wheelRegion -= subRe;
-
-    CleanWheel = QPixmap().fromImage(wheelImage);
-}
-
-void ColorWheel::drawSquareImage(const int &hue)
-{
-//    QPainter painter(&squarePixmap);
-//    painter.setRenderHint(QPainter::Antialiasing);
-
-    /*-----------------------------------------------------*\
-    | Calculate dimensions                                  |
-    \*-----------------------------------------------------*/
-    int w = qMin(width(), height());
-
-    // radius of outer circle
-    qreal r = w/2-margin;
-
-    // radius of inner circle
-    qreal ir = r-wheelWidth;
-
-    // left corner of square
-    qreal m = w/2.0-ir/qSqrt(2);
-
-    /*-----------------------------------------------------*\
-    | Create image canvas                                   |
-    \*-----------------------------------------------------*/
-    QImage square(255,255, QImage::Format_ARGB32_Premultiplied);
-
-    /*-----------------------------------------------------*\
-    | Paint the square.  X axis is saturation and Y axis is |
-    | value                                                 |
-    \*-----------------------------------------------------*/
-    QColor color;
-    QRgb qrgb;
-
-    for(int x = 0; x < 255; x++)
-    {
-        for(int y = 0; y < 255; y++)
-        {
-            color = QColor::fromHsv(hue, x, y);
-
-            qrgb = qRgb(color.red(),color.green(),color.blue());
-
-            square.setPixel(x, y, qrgb);
-        }
-    }
-
-    /*-----------------------------------------------------*\
-    | Copy the fixed-size square image on to the scaled     |
-    | canvas                                                |
-    \*-----------------------------------------------------*/
-    qreal SquareWidth = 2*ir/qSqrt(2);
-    squareImage = square.scaled(SquareWidth, SquareWidth);
-
-    /*-----------------------------------------------------*\
-    | Calculate square region                               |
-    \*-----------------------------------------------------*/
-    squareRegion = QRegion(x_offset + m, y_offset + m, SquareWidth, SquareWidth);
-    CleanSquare = squareImage;
-}
-
-void ColorWheel::drawIndicator(const int &hue)
-{
-    QPainter painter(&wheel);
-    painter.setRenderHint(QPainter::Antialiasing);
-    if(hue > 20 && hue < 200)
-    {
-        painter.setPen(Qt::black);
-    }
-    else
-    {
-        painter.setPen(Qt::white);
-    }
-    painter.setBrush(Qt::NoBrush);
-
-    QPen pen = painter.pen();
-    pen.setWidth(3);
-    painter.setPen(pen);
-    qreal r = qMin(height(), width()) / 2.0;
-    painter.translate(x_offset + r, y_offset + r);
-    painter.rotate( -hue );
-    r = qMin(height(), width()) / 2.0 - margin - wheelWidth/2;
-    painter.drawEllipse(QPointF(r,0.0),5,5);
-}
-
-void ColorWheel::drawPicker(const QColor &color)
-{
-    QPainter painter(&wheel);
-    painter.setRenderHint(QPainter::Antialiasing);
-    QPen pen;
-
-    // region of the widget
-    int w = qMin(width(), height());
-
-    // radius of outer circle
-    qreal r = w/2-margin;
-
-    // radius of inner circle
-    qreal ir = r-wheelWidth;
-
-    // left corner of square
-    qreal m = w/2.0-ir/qSqrt(2);
-
-    painter.translate(x_offset + m-5, y_offset + m-5);
-
-    qreal SquareWidth = 2*ir/qSqrt(2);
-    qreal S = color.saturationF()*SquareWidth;
-    qreal V = color.valueF()*SquareWidth;
-
-    if(color.saturation() > 30 ||color.value() < 50)
-    {
-        pen.setColor(Qt::white);
-    }
-
-    pen.setWidth(3);
-    painter.setPen(pen);
-    painter.drawEllipse(S,V,10,10);
-}
-
-void ColorWheel::composeWheel()
-{
-    wheel = CleanWheel;
-    squareImage = CleanSquare;
-    QPainter composePainter(&wheel);
-    composePainter.drawImage(0, 0, wheelImage);
-    composePainter.drawImage(squareRegion.boundingRect().topLeft(), squareImage);
-    composePainter.end();
-    drawIndicator(current.hue());
-    drawPicker(current);
-}
-
-void ColorWheel::hueChanged(const int &hue)
-{
-    if((hue < 0) || (hue > 359))
-    {
-        return;
-    }
-
-    int s = current.saturation();
-    int v = current.value();
-    current.setHsv(hue, s, v);
-
-    drawSquareImage(hue);
-
-    if(!isVisible())
-    {
-        return;
-    }
-    repaint();
-
-    emit colorChanged(current);
-}
-
-void ColorWheel::svChanged(const QColor &newcolor)
-{
-    int hue = current.hue();
-
-    current.setHsv
-            (
-            hue,
-            newcolor.saturation(),
-            newcolor.value()
-            );
-
-    if(!isVisible())
-    {
-        return;
-    }
-
-    repaint();
-
-    emit colorChanged(current);
-}
diff --git a/dependencies/ColorWheel/ColorWheel.h b/dependencies/ColorWheel/ColorWheel.h
deleted file mode 100644
index 3394f3ff..00000000
--- a/dependencies/ColorWheel/ColorWheel.h
+++ /dev/null
@@ -1,59 +0,0 @@
-#ifndef COLORWHEEL_H
-#define COLORWHEEL_H
-
-#include <QWidget>
-
-class ColorWheel : public QWidget
-{
-    Q_OBJECT
-public:
-    explicit ColorWheel(QWidget *parent = 0);
-
-    virtual QSize sizeHint () const;
-    virtual QSize minimumSizeHint () const;
-    QColor color();
-
-signals:
-    void colorChanged(const QColor color);
-    
-public slots:
-    void setColor(const QColor &color);
-
-protected:
-    void mousePressEvent(QMouseEvent *event);
-    void mouseMoveEvent(QMouseEvent *event);
-    void mouseReleaseEvent(QMouseEvent *);
-    void resizeEvent(QResizeEvent *event);
-    void paintEvent(QPaintEvent *);
-private:
-    QSize initSize;
-    QImage wheelImage;
-    QImage squareImage;
-    QPixmap wheel;
-    bool mouseDown;
-    QPoint lastPos;
-    int margin;
-    int wheelWidth;
-    QRegion wheelRegion;
-    QRegion squareRegion;
-    QColor current;
-    bool inWheel;
-    bool inSquare;
-    int x_offset;
-    int y_offset;
-
-    QPixmap CleanWheel;
-    QImage CleanSquare;
-
-    QColor posColor(const QPoint &point);
-    void drawWheelImage(const QSize &newSize);
-    void drawIndicator(const int &hue);
-    void drawPicker(const QColor &color);
-    void drawSquareImage(const int &hue);
-    void composeWheel();
-private slots:
-    void hueChanged(const int &hue);
-    void svChanged(const QColor &newcolor);
-};
-
-#endif // COLORWHEEL_H
diff --git a/dependencies/NVFC/nvapi.cpp b/dependencies/NVFC/nvapi.cpp
index 632b2e08..3cf47262 100644
--- a/dependencies/NVFC/nvapi.cpp
+++ b/dependencies/NVFC/nvapi.cpp
@@ -268,7 +268,7 @@ static bool QueryInterfaceOpaque(nvapi_QueryInterface_t query_interface, NV_U32
 template<typename F>
 static void QueryInterfaceCast(nvapi_QueryInterface_t query_interface, NV_U32 id, const char */*function_name*/, F &function_pointer)
 {
-	const bool result = QueryInterfaceOpaque(query_interface, id, (void **)&function_pointer);
+	QueryInterfaceOpaque(query_interface, id, (void **)&function_pointer);
     ////Log::write("%s querying interface '0x%08x' '%s'", result ? "success" : "failure", id, function_name);
 }
 
diff --git a/main.cpp b/main.cpp
index 781e99ab..0ffd8324 100644
--- a/main.cpp
+++ b/main.cpp
@@ -7,26 +7,26 @@
 |   SPDX-License-Identifier: GPL-2.0-only                   |
 \*---------------------------------------------------------*/
 
-#include <vector>
 #include <stdio.h>
 #include <stdlib.h>
+
 #include <thread>
-#include "cli.h"
-#include "ResourceManager.h"
+#include <vector>
+
+#include "LogManager.h"
 #include "NetworkClient.h"
 #include "NetworkServer.h"
 #include "ProfileManager.h"
 #include "RGBController.h"
+#include "ResourceManager.h"
+#include "cli.h"
 #include "i2c_smbus.h"
-#include "LogManager.h"
 
 #ifdef _MACOSX_X86_X64
 #include "macUSPCIOAccess.h"
 io_connect_t macUSPCIO_driver_connection;
 #endif
 
-#include "OpenRGBDialog2.h"
-
 #ifdef __APPLE__
 #include "macutils.h"
 #endif
@@ -46,36 +46,31 @@ using namespace std::chrono_literals;
 typedef unsigned int NTSTATUS;
 typedef NTSTATUS (*NTSETTIMERRESOLUTION)(ULONG DesiredResolution, BOOLEAN SetResolution, PULONG CurrentResolution);
 
-void InitializeTimerResolution()
-{
-    NTSETTIMERRESOLUTION NtSetTimerResolution;
-    HMODULE              NtDllHandle;
-    ULONG                CurrentResolution;
+void InitializeTimerResolution() {
+	NTSETTIMERRESOLUTION NtSetTimerResolution;
+	HMODULE NtDllHandle;
+	ULONG CurrentResolution;
 
-    NtDllHandle = LoadLibrary("ntdll.dll");
+	NtDllHandle = LoadLibrary("ntdll.dll");
 
-    NtSetTimerResolution = (NTSETTIMERRESOLUTION)GetProcAddress(NtDllHandle, "NtSetTimerResolution");
+	NtSetTimerResolution = (NTSETTIMERRESOLUTION)GetProcAddress(NtDllHandle, "NtSetTimerResolution");
 
-    NtSetTimerResolution(5000, TRUE, &CurrentResolution);
+	NtSetTimerResolution(5000, TRUE, &CurrentResolution);
 }
 
-void InitializeTimerResolutionThreadFunction()
-{
-    while(1)
-    {
-        InitializeTimerResolution();
+void InitializeTimerResolutionThreadFunction() {
+	while (1) {
+		InitializeTimerResolution();
 
-        std::this_thread::sleep_for(500ms);
-    }
+		std::this_thread::sleep_for(500ms);
+	}
 }
 #endif
 
-void WaitWhileServerOnline(NetworkServer* srv)
-{
-    while (srv->GetOnline())
-    {
-        std::this_thread::sleep_for(1s);
-    };
+void WaitWhileServerOnline(NetworkServer* srv) {
+	while (srv->GetOnline()) {
+		std::this_thread::sleep_for(1s);
+	};
 }
 
 /******************************************************************************************\
@@ -84,71 +79,52 @@ void WaitWhileServerOnline(NetworkServer* srv)
 *                                                                                          *
 \******************************************************************************************/
 #ifdef _WIN32
-void InstallWinRing0()
-{
-    TCHAR winring0_install_location[MAX_PATH]; // driver final location usually C:\windows\system32\drivers\WinRing0x64.sys
-    uint system_path_length = GetSystemDirectory(winring0_install_location, MAX_PATH);
-    std::string winring0_filename = "WinRing0.sys";
-    BOOL bIsWow64 = false;
+void InstallWinRing0() {
+	TCHAR winring0_install_location[MAX_PATH];	// driver final location usually C:\windows\system32\drivers\WinRing0x64.sys
+	uint system_path_length		  = GetSystemDirectory(winring0_install_location, MAX_PATH);
+	std::string winring0_filename = "WinRing0.sys";
+	BOOL bIsWow64				  = false;
 #if _WIN64
-    winring0_filename = "WinRing0x64.sys";
+	winring0_filename = "WinRing0x64.sys";
 #else
-    BOOL (*fnIsWow64Process)(HANDLE, PBOOL) = (BOOL (__cdecl *)(HANDLE, PBOOL))GetProcAddress(GetModuleHandle(TEXT("kernel32")),"IsWow64Process");
-    if (fnIsWow64Process)
-    {
-        fnIsWow64Process(GetCurrentProcess(),&bIsWow64);
-    }
-    if(bIsWow64)
-    {
-        winring0_filename = "WinRing0x64.sys";
-    }
+	BOOL (*fnIsWow64Process)(HANDLE, PBOOL) = (BOOL(__cdecl*)(HANDLE, PBOOL))GetProcAddress(GetModuleHandle(TEXT("kernel32")), "IsWow64Process");
+	if (fnIsWow64Process) {
+		fnIsWow64Process(GetCurrentProcess(), &bIsWow64);
+	}
+	if (bIsWow64) {
+		winring0_filename = "WinRing0x64.sys";
+	}
 #endif
-    std::strncat(winring0_install_location, "\\drivers\\", MAX_PATH - system_path_length - 1);
-    std::strncat(winring0_install_location, winring0_filename.c_str(), MAX_PATH - system_path_length - 10);
-
-    std::string driver_name = winring0_filename.substr(0, winring0_filename.size() - 4); // driver name: WinRing0 or WinRing0x64
-    SC_HANDLE manager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
-    if (manager)
-    {
-        PVOID wow64_fsredirection_OldValue = NULL;
-        if(bIsWow64)
-        {
-            Wow64DisableWow64FsRedirection(&wow64_fsredirection_OldValue);
-        }
-        if(INVALID_FILE_ATTRIBUTES == GetFileAttributes(winring0_install_location) && GetLastError()==ERROR_FILE_NOT_FOUND)
-        {
-            char module_path_buffer[MAX_PATH];
-            GetModuleFileNameA(NULL, module_path_buffer, MAX_PATH);
-            std::string::size_type exe_loc = std::string(module_path_buffer).find_last_of("\\/");
-            std::string driver_source_path = std::string(module_path_buffer).substr(0, exe_loc + 1) + winring0_filename;
-            CopyFile(driver_source_path.c_str(), winring0_install_location, true);
-        }
-        if(bIsWow64)
-        {
-            Wow64RevertWow64FsRedirection(wow64_fsredirection_OldValue);
-        }
-
-        SC_HANDLE service = OpenService(manager, driver_name.c_str(), SERVICE_ALL_ACCESS);
-        if(!service)
-        {
-            std::string service_sys_path = "System32\\Drivers\\" + winring0_filename;
-            service = CreateService(manager,
-               driver_name.c_str(),
-               driver_name.c_str(),
-               SERVICE_ALL_ACCESS,
-               SERVICE_KERNEL_DRIVER,
-               SERVICE_AUTO_START,
-               SERVICE_ERROR_NORMAL,
-               service_sys_path.c_str(),
-               NULL,
-               NULL,
-               NULL,
-               NULL,
-               NULL);
-        }
-        CloseServiceHandle(service);
-        CloseServiceHandle(manager);
-    }
+	std::strncat(winring0_install_location, "\\drivers\\", MAX_PATH - system_path_length - 1);
+	std::strncat(winring0_install_location, winring0_filename.c_str(), MAX_PATH - system_path_length - 10);
+
+	std::string driver_name = winring0_filename.substr(0, winring0_filename.size() - 4);  // driver name: WinRing0 or WinRing0x64
+	SC_HANDLE manager		= OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
+	if (manager) {
+		PVOID wow64_fsredirection_OldValue = NULL;
+		if (bIsWow64) {
+			Wow64DisableWow64FsRedirection(&wow64_fsredirection_OldValue);
+		}
+		if (INVALID_FILE_ATTRIBUTES == GetFileAttributes(winring0_install_location) && GetLastError() == ERROR_FILE_NOT_FOUND) {
+			char module_path_buffer[MAX_PATH];
+			GetModuleFileNameA(NULL, module_path_buffer, MAX_PATH);
+			std::string::size_type exe_loc = std::string(module_path_buffer).find_last_of("\\/");
+			std::string driver_source_path = std::string(module_path_buffer).substr(0, exe_loc + 1) + winring0_filename;
+			CopyFile(driver_source_path.c_str(), winring0_install_location, true);
+		}
+		if (bIsWow64) {
+			Wow64RevertWow64FsRedirection(wow64_fsredirection_OldValue);
+		}
+
+		SC_HANDLE service = OpenService(manager, driver_name.c_str(), SERVICE_ALL_ACCESS);
+		if (!service) {
+			std::string service_sys_path = "System32\\Drivers\\" + winring0_filename;
+			service = CreateService(manager, driver_name.c_str(), driver_name.c_str(), SERVICE_ALL_ACCESS, SERVICE_KERNEL_DRIVER, SERVICE_AUTO_START,
+									SERVICE_ERROR_NORMAL, service_sys_path.c_str(), NULL, NULL, NULL, NULL, NULL);
+		}
+		CloseServiceHandle(service);
+		CloseServiceHandle(manager);
+	}
 }
 #endif
 
@@ -160,138 +136,74 @@ void InstallWinRing0()
 *                                                                                          *
 \******************************************************************************************/
 
-int main(int argc, char* argv[])
-{
+int main(int argc, char* argv[]) {
 #ifdef _WIN32
-    /*---------------------------------------------------------*\
-    | Windows only - Attach console output                      |
-    \*---------------------------------------------------------*/
-    if (AttachConsole(ATTACH_PARENT_PROCESS))
-    {
-        /*---------------------------------------------------------*\
-        | We are running under some terminal context; otherwise     |
-        | leave the GUI and CRT alone                               |
-        \*---------------------------------------------------------*/
-        freopen("CONIN$",  "r", stdin);
-        freopen("CONOUT$", "w", stdout);
-        freopen("CONOUT$", "w", stderr);
-    }
-
-    /*---------------------------------------------------------*\
-    | Windows only - Start timer resolution correction thread   |
-    \*---------------------------------------------------------*/
-    std::thread * InitializeTimerResolutionThread;
-    InitializeTimerResolutionThread = new std::thread(InitializeTimerResolutionThreadFunction);
-    InitializeTimerResolutionThread->detach();
-
-    /*---------------------------------------------------------*\
-    | Windows only - Install SMBus Driver WinRing0              |
-    \*---------------------------------------------------------*/
-    InstallWinRing0();
+	/*---------------------------------------------------------*\
+	| Windows only - Attach console output                      |
+	\*---------------------------------------------------------*/
+	if (AttachConsole(ATTACH_PARENT_PROCESS)) {
+		/*---------------------------------------------------------*\
+		| We are running under some terminal context; otherwise     |
+		| leave the GUI and CRT alone                               |
+		\*---------------------------------------------------------*/
+		freopen("CONIN$", "r", stdin);
+		freopen("CONOUT$", "w", stdout);
+		freopen("CONOUT$", "w", stderr);
+	}
+
+	/*---------------------------------------------------------*\
+	| Windows only - Start timer resolution correction thread   |
+	\*---------------------------------------------------------*/
+	std::thread* InitializeTimerResolutionThread;
+	InitializeTimerResolutionThread = new std::thread(InitializeTimerResolutionThreadFunction);
+	InitializeTimerResolutionThread->detach();
+
+	/*---------------------------------------------------------*\
+	| Windows only - Install SMBus Driver WinRing0              |
+	\*---------------------------------------------------------*/
+	InstallWinRing0();
 #endif
 
-    /*---------------------------------------------------------*\
-    | Mac x86/x64 only - Install SMBus Driver macUSPCIO         |
-    \*---------------------------------------------------------*/
+	/*---------------------------------------------------------*\
+	| Mac x86/x64 only - Install SMBus Driver macUSPCIO         |
+	\*---------------------------------------------------------*/
 #ifdef _MACOSX_X86_X64
-    InitMacUSPCIODriver();
+	InitMacUSPCIODriver();
 #endif
 
-    /*---------------------------------------------------------*\
-    | Process command line arguments before detection           |
-    \*---------------------------------------------------------*/
-    unsigned int ret_flags = cli_pre_detection(argc, argv);
-
-    ResourceManager::get()->Initialize(
-        !(ret_flags & RET_FLAG_NO_AUTO_CONNECT),
-        !(ret_flags & RET_FLAG_NO_DETECT),
-        ret_flags & RET_FLAG_START_SERVER,
-        ret_flags & RET_FLAG_CLI_POST_DETECTION);
-
-    /*---------------------------------------------------------*\
-    | If the command line parser indicates that the GUI should  |
-    | run, or if there were no command line arguments, start the|
-    | GUI.                                                      |
-    \*---------------------------------------------------------*/
-    if(ret_flags & RET_FLAG_START_GUI)
-    {
-        LOG_TRACE("[main] initializing GUI");
-        QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
-        QApplication a(argc, argv);
-        QGuiApplication::setDesktopFileName("org.openrgb.OpenRGB");
-        LOG_TRACE("[main] QApplication created");
-
-        /*---------------------------------------------------------*\
-        | Main UI widget                                            |
-        \*---------------------------------------------------------*/
-        Ui::OpenRGBDialog2 dlg;
-        LOG_TRACE("[main] Dialog created");
+	/*---------------------------------------------------------*\
+	| Process command line arguments before detection           |
+	\*---------------------------------------------------------*/
+	unsigned int ret_flags = cli_pre_detection(argc, argv);
 
-        if(ret_flags & RET_FLAG_I2C_TOOLS)
-        {
-            dlg.AddI2CToolsPage();
-        }
-
-        dlg.AddClientTab();
-
-        if(ret_flags & RET_FLAG_START_MINIMIZED)
-        {
-#ifdef _WIN32
-            /*---------------------------------------------------------*\
-            | Show the window always, even if it will immediately be    |
-            | hidden.  On Windows, events are not delivered to          |
-            | nativeEventFilter (for SuspendResume) until the window    |
-            | has been shown once.                                      |
-            \*---------------------------------------------------------*/
-            dlg.showMinimized();
-#endif
-#ifdef __APPLE__
-            MacUtils::ToggleApplicationDocklessState(false);
-#endif
-            dlg.hide();
-        }
-        else
-        {
-            dlg.show();
-        }
+	ResourceManager::get()->Initialize(!(ret_flags & RET_FLAG_NO_AUTO_CONNECT), !(ret_flags & RET_FLAG_NO_DETECT), ret_flags & RET_FLAG_START_SERVER,
+									   ret_flags & RET_FLAG_CLI_POST_DETECTION);
 
-        LOG_TRACE("[main] Ready to exec() the dialog");
-        return a.exec();
-    }
-    else
-    {
-        /*---------------------------------------------------------*\
-        | If no GUI is needed, we let the background threads run    |
-        | as long as they need, but we need to AT LEAST wait for    |
-        | initialization to finish                                  |
-        \*---------------------------------------------------------*/
-        ResourceManager::get()->WaitForInitialization();
+	/*---------------------------------------------------------*\
+	| If no GUI is needed, we let the background threads run    |
+	| as long as they need, but we need to AT LEAST wait for    |
+	| initialization to finish                                  |
+	\*---------------------------------------------------------*/
+	ResourceManager::get()->WaitForInitialization();
 
-        if(ret_flags & RET_FLAG_START_SERVER)
-        {
-            NetworkServer* server = ResourceManager::get()->GetServer();
+	if (ret_flags & RET_FLAG_START_SERVER) {
+		NetworkServer* server = ResourceManager::get()->GetServer();
 
-            if(!server->GetOnline())
-            {
+		if (!server->GetOnline()) {
 #ifdef _MACOSX_X86_X64
-                CloseMacUSPCIODriver();
+			CloseMacUSPCIODriver();
 #endif
-                return 1;
-            }
-            else
-            {
-                WaitWhileServerOnline(server);
+			return 1;
+		} else {
+			WaitWhileServerOnline(server);
 #ifdef _MACOSX_X86_X64
-                CloseMacUSPCIODriver();
+			CloseMacUSPCIODriver();
 #endif
-            }
-        }
-        else
-        {
+		}
+	} else {
 #ifdef _MACOSX_X86_X64
-            CloseMacUSPCIODriver();
+		CloseMacUSPCIODriver();
 #endif
-            return 0;
-        }
-    }
+		return 0;
+	}
 }
diff --git a/qt/DetectorTableModel.cpp b/qt/DetectorTableModel.cpp
deleted file mode 100644
index 2bac1e00..00000000
--- a/qt/DetectorTableModel.cpp
+++ /dev/null
@@ -1,168 +0,0 @@
-/*---------------------------------------------------------*\
-| DetectorTableModel.cpp                                    |
-|                                                           |
-|   Table model for detector list                           |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "DetectorTableModel.h"
-#include "SettingsManager.h"
-
-DetectorTableModel::DetectorTableModel(QObject* parent) : QAbstractTableModel(parent)
-{
-    detectors.clear();
-
-    /*-----------------------------------------------------*\
-    | Read the detector list from the settings manager      |
-    \*-----------------------------------------------------*/
-    json settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Detectors");
-
-    if(settings.contains("detectors"))
-    {
-        for(json::const_iterator it = settings["detectors"].begin(); it != settings["detectors"].end(); it++)
-        {
-            DetectorTableValue new_entry;
-
-            new_entry.key   = it.key();
-            new_entry.value = it.value();
-
-            detectors.push_back(new_entry);
-        }
-    }
-
-    /*-----------------------------------------------------*\
-    | If settings contains the detectors list, fill in rows |
-    \*-----------------------------------------------------*/
-    beginInsertRows(QModelIndex(), 0, (int)detectors.size());
-    endInsertRows();
-}
-
-int DetectorTableModel::columnCount(const QModelIndex&) const
-{
-    /*-----------------------------------------------------*\
-    | The table has two columns - detector name and enable  |
-    \*-----------------------------------------------------*/
-    return(2);
-}
-
-int DetectorTableModel::rowCount(const QModelIndex&) const
-{
-    /*-----------------------------------------------------*\
-    | The number of rows is equal to the number of detectors|
-    \*-----------------------------------------------------*/
-    return((int)detectors.size());
-}
-
-QVariant DetectorTableModel::data(const QModelIndex& index, int role) const
-{
-    switch(role)
-    {
-        /*-----------------------------------------------------*\
-        | Column 0 is the detector name, 1 is the enable flag   |
-        \*-----------------------------------------------------*/
-        case Qt::DisplayRole:
-            switch(index.column())
-            {
-                case 0:
-                    return(detectors[index.row()].key.c_str());
-                case 1:
-                    return(detectors[index.row()].value);
-            }
-            return(QVariant());
-
-        case Qt::CheckStateRole:
-            switch(index.column())
-            {
-                case 1:
-                    return(2 * detectors[index.row()].value);
-            }
-            return(QVariant());
-    }
-    return(QVariant());
-}
-
-bool DetectorTableModel::setData(const QModelIndex& index, const QVariant& value, int role)
-{
-    /*-----------------------------------------------------*\
-    | Update detector value for column 1                    |
-    \*-----------------------------------------------------*/
-    if(index.column() == 1 && role == Qt::CheckStateRole)
-    {
-        detectors[index.row()].value = value.toBool();
-        emit dataChanged(index, index);
-    }
-    return(false);
-}
-
-QVariant DetectorTableModel::headerData(int index, Qt::Orientation orientation, int role) const
-{
-    if(role == Qt::DisplayRole)
-    {
-        switch(orientation)
-        {
-            case Qt::Vertical:
-                return(index + 1);
-
-            case Qt::Horizontal:
-                switch(index)
-                {
-                    case 0:
-                        return(tr("Name"));
-                    case 1:
-                        return(tr("Enabled"));
-                }
-        }
-    }
-    return(QVariant());
-}
-
-Qt::ItemFlags DetectorTableModel::flags(const QModelIndex& index) const
-{
-    Qt::ItemFlags fl = Qt::ItemIsEnabled;
-
-    if(index.column() == 1)
-    {
-        fl |= Qt::ItemIsUserCheckable;
-    }
-
-    return(fl);
-}
-
-void DetectorTableModel::applySettings()
-{
-    /*-----------------------------------------------------*\
-    | Read the detector list from the settings manager      |
-    \*-----------------------------------------------------*/
-    json settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Detectors");
-
-    /*-----------------------------------------------------*\
-    | Loop through all detectors in the list and update the |
-    | value in the settings                                 |
-    \*-----------------------------------------------------*/
-    if(settings.contains("detectors"))
-    {
-        for(unsigned int detector_idx = 0; detector_idx < detectors.size(); detector_idx++)
-        {
-            settings["detectors"][detectors[detector_idx].key] = detectors[detector_idx].value;
-        }
-    }
-
-    /*-----------------------------------------------------*\
-    | Set and save the settings                             |
-    \*-----------------------------------------------------*/
-    ResourceManager::get()->GetSettingsManager()->SetSettings("Detectors", settings);
-    ResourceManager::get()->GetSettingsManager()->SaveSettings();
-}
-
-void DetectorTableModel::toggleAll(const bool state, QSortFilterProxyModel* detectorSortModel)
-{
-    for(unsigned int detector_idx = 0; detector_idx < detectors.size(); detector_idx++)
-    {
-        if(detectorSortModel->mapFromSource(index(detector_idx, 0)).isValid())
-        {
-            setData(index(detector_idx,1), state, Qt::CheckStateRole);
-        }
-    }
-}
diff --git a/qt/DetectorTableModel.h b/qt/DetectorTableModel.h
deleted file mode 100644
index 7bbde2e7..00000000
--- a/qt/DetectorTableModel.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*---------------------------------------------------------*\
-| DetectorTableModel.h                                      |
-|                                                           |
-|   Table model for detector list                           |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QSortFilterProxyModel>
-#include <QAbstractTableModel>
-#include "ResourceManager.h"
-
-typedef struct
-{
-    std::string key;
-    bool        value;
-} DetectorTableValue;
-
-class DetectorTableModel : public QAbstractTableModel
-{
-    Q_OBJECT
-
-private:
-    std::vector<DetectorTableValue> detectors;
-
-public:
-    DetectorTableModel(QObject *parent = nullptr);
-    int columnCount(const QModelIndex&) const override;
-    int rowCount(const QModelIndex&) const override;
-    QVariant data(const QModelIndex& index, int role) const override;
-    bool setData(const QModelIndex& index, const QVariant&, int role) override;
-    QVariant headerData(int index, Qt::Orientation orientation, int role) const override;
-    Qt::ItemFlags flags(const QModelIndex& index) const override;
-
-public slots:
-    void applySettings();
-    void toggleAll(const bool state, QSortFilterProxyModel* detectorSortModel);
-};
diff --git a/qt/DeviceView.cpp b/qt/DeviceView.cpp
deleted file mode 100644
index 73d107f1..00000000
--- a/qt/DeviceView.cpp
+++ /dev/null
@@ -1,1080 +0,0 @@
-/*---------------------------------------------------------*\
-| DeviceView.cpp                                            |
-|                                                           |
-|   OpenRGB Device view widget for Qt                       |
-|                                                           |
-|   Adam Honse (calcprogrammer1@gmail.com)                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QPainter>
-#include <QResizeEvent>
-#include <QStyleOption>
-#include <QtCore/qmath.h>
-#include <QDebug>
-#include <QMouseEvent>
-#include "DeviceView.h"
-#include "ResourceManager.h"
-#include "RGBControllerKeyNames.h"
-#include "RGBController.h"
-#include "SettingsManager.h"
-
-#define MAX_COLS    20
-#define PAD_LED     0.1f
-#define PAD_TEXT    0.1f
-#define PAD_ZONE    1.0f
-#define PAD_SEGMENT 0.9f
-#define SIZE_TEXT   0.5f
-
-DeviceView::DeviceView(QWidget *parent) :
-    QWidget(parent),
-    initSize(128,128),
-    mouseDown(false)
-{
-    controller = NULL;
-    numerical_labels = false;
-    per_led = true;
-    setMouseTracking(1);
-
-    size = width();
-}
-
-DeviceView::~DeviceView()
-{
-
-}
-
-struct led_label
-{
-    QString label_text;
-    QString label_utf8;
-};
-
-static const std::map<std::string, led_label> led_label_lookup =
-{
-    { KEY_EN_A,                 { "A"     , "A",                }},
-    { KEY_EN_B,                 { "B"     , "B",                }},
-    { KEY_EN_C,                 { "C"     , "C",                }},
-    { KEY_EN_D,                 { "D"     , "D",                }},
-    { KEY_EN_E,                 { "E"     , "E",                }},
-    { KEY_EN_F,                 { "F"     , "F",                }},
-    { KEY_EN_G,                 { "G"     , "G",                }},
-    { KEY_EN_H,                 { "H"     , "H",                }},
-    { KEY_EN_I,                 { "I"     , "I",                }},
-    { KEY_EN_J,                 { "J"     , "J",                }},
-    { KEY_EN_K,                 { "K"     , "K",                }},
-    { KEY_EN_L,                 { "L"     , "L",                }},
-    { KEY_EN_M,                 { "M"     , "M",                }},
-    { KEY_EN_N,                 { "N"     , "N",                }},
-    { KEY_EN_O,                 { "O"     , "O",                }},
-    { KEY_EN_P,                 { "P"     , "P",                }},
-    { KEY_EN_Q,                 { "Q"     , "Q",                }},
-    { KEY_EN_R,                 { "R"     , "R",                }},
-    { KEY_EN_S,                 { "S"     , "S",                }},
-    { KEY_EN_T,                 { "T"     , "T",                }},
-    { KEY_EN_U,                 { "U"     , "U",                }},
-    { KEY_EN_V,                 { "V"     , "V",                }},
-    { KEY_EN_W,                 { "W"     , "W",                }},
-    { KEY_EN_X,                 { "X"     , "X",                }},
-    { KEY_EN_Y,                 { "Y"     , "Y",                }},
-    { KEY_EN_Z,                 { "Z"     , "Z",                }},
-    { KEY_EN_0,                 { "0"     , "0",                }},
-    { KEY_EN_1,                 { "1"     , "1",                }},
-    { KEY_EN_2,                 { "2"     , "2",                }},
-    { KEY_EN_3,                 { "3"     , "3",                }},
-    { KEY_EN_4,                 { "4"     , "4",                }},
-    { KEY_EN_5,                 { "5"     , "5",                }},
-    { KEY_EN_6,                 { "6"     , "6",                }},
-    { KEY_EN_7,                 { "7"     , "7",                }},
-    { KEY_EN_8,                 { "8"     , "8",                }},
-    { KEY_EN_9,                 { "9"     , "9",                }},
-    { KEY_EN_F1,                { "F1"    , "F1",               }},
-    { KEY_EN_F2,                { "F2"    , "F2",               }},
-    { KEY_EN_F3,                { "F3"    , "F3",               }},
-    { KEY_EN_F4,                { "F4"    , "F4",               }},
-    { KEY_EN_F5,                { "F5"    , "F5",               }},
-    { KEY_EN_F6,                { "F6"    , "F6",               }},
-    { KEY_EN_F7,                { "F7"    , "F7",               }},
-    { KEY_EN_F8,                { "F8"    , "F8",               }},
-    { KEY_EN_F9,                { "F9"    , "F9",               }},
-    { KEY_EN_F10,               { "F10"   , "F10",              }},
-    { KEY_EN_F11,               { "F11"   , "F11",              }},
-    { KEY_EN_F12,               { "F12"   , "F12",              }},
-    { KEY_EN_BACK_TICK,         { "`"     , "`",                }},
-    { KEY_EN_MINUS,             { "-"     , "-",                }},
-    { KEY_EN_PLUS,              { "+"     , "+",                }},
-    { KEY_EN_EQUALS,            { "="     , "=",                }},
-    { KEY_EN_LEFT_BRACKET,      { "["     , "[",                }},
-    { KEY_EN_RIGHT_BRACKET,     { "]"     , "]",                }},
-    { KEY_EN_BACK_SLASH,        { "\\"    , "\\",               }},
-    { KEY_EN_ANSI_BACK_SLASH,   { "\\"    , "\\",               }},
-    { KEY_EN_ISO_BACK_SLASH,    { "\\"    , "\\",               }},
-    { KEY_EN_SEMICOLON,         { ";"     , ";",                }},
-    { KEY_EN_QUOTE,             { "'"     , "'",                }},
-    { KEY_EN_POUND,             { "#"     , "#",                }},
-    { KEY_EN_COMMA,             { ","     , ",",                }},
-    { KEY_EN_PERIOD,            { "."     , ".",                }},
-    { KEY_EN_FORWARD_SLASH,     { "/"     , "/",                }},
-    { KEY_EN_ESCAPE,            { "Esc"   , "Esc",              }},
-    { KEY_EN_PRINT_SCREEN,      { "Prt"   , "Prt",              }},
-    { KEY_EN_SCROLL_LOCK,       { "Scr"   , "Scr",              }},
-    { KEY_EN_PAUSE_BREAK,       { "Brk"   , "Brk",              }},
-    { KEY_EN_BACKSPACE,         { "Bks"   , "\xE2\x8C\xAB"      }}, // ⌫
-    { KEY_EN_INSERT,            { "Ins"   , "Ins",              }},
-    { KEY_EN_HOME,              { "Hom"   , "Hom",              }},
-    { KEY_EN_PAGE_UP,           { "PUp"   , "PUp",              }},
-    { KEY_EN_TAB,               { "Tab"   , "\xE2\x86\xb9"      }}, // ⭾ ↹ ⇄ ⇥
-    { KEY_EN_DELETE,            { "Del"   , "Del",              }},
-    { KEY_EN_END,               { "End"   , "End",              }},
-    { KEY_EN_PAGE_DOWN,         { "PDn"   , "PDn",              }},
-    { KEY_EN_CAPS_LOCK,         { "Cap"   , "Cap",              }},
-    { KEY_EN_ANSI_ENTER,        { "Ent"   , "\xE2\x86\xB5"      }}, // ↵ ⏎
-    { KEY_EN_ISO_ENTER,         { "Ent"   , "\xE2\x86\xB5"      }}, // ↵ ⏎
-    { KEY_EN_LEFT_SHIFT,        { "Sft"   , "\xE2\x87\xA7"      }}, // ⇧
-    { KEY_EN_RIGHT_SHIFT,       { "Sft"   , "\xE2\x87\xA7"      }}, // ⇧
-    { KEY_EN_UP_ARROW,          { "Up"    , "\xF0\x9F\xA1\xB9"  }}, // ↑ 🡹
-    { KEY_EN_LEFT_CONTROL,      { "Ctl"   , "Ctl",              }},
-    { KEY_EN_LEFT_WINDOWS,      { "Win"   , "\xe2\x9d\x96"      }}, // ❖
-    { KEY_EN_LEFT_FUNCTION,     { "Fn"    , "Fn",               }},
-    { KEY_EN_LEFT_ALT,          { "Alt"   , "Alt",              }},
-    { KEY_EN_SPACE,             { "Spc"   , "Spc",              }},
-    { KEY_EN_RIGHT_ALT,         { "Alt"   , "Alt",              }},
-    { KEY_EN_RIGHT_FUNCTION,    { "Fn"    , "Fn",               }},
-    { KEY_EN_RIGHT_WINDOWS,     { "Win"   , "\xe2\x9d\x96"      }}, // ❖
-    { KEY_EN_MENU,              { "Mnu"   , "\xE2\x98\xB0"      }}, // ▤ ☰ 𝌆 🗏
-    { KEY_EN_RIGHT_CONTROL,     { "Ctl"   , "Ctl",              }},
-    { KEY_EN_LEFT_ARROW,        { "Lft"   , "\xF0\x9F\xA1\xB8"  }}, // ↑ 🡹
-    { KEY_EN_DOWN_ARROW,        { "Dn"    , "\xF0\x9F\xA1\xBB"  }}, // ↑ 🡹
-    { KEY_EN_RIGHT_ARROW,       { "Rgt"   , "\xF0\x9F\xA1\xBA"  }}, // ↑ 🡹
-    { KEY_EN_NUMPAD_LOCK,       { "Num"   , "Num",              }},
-    { KEY_EN_NUMPAD_DIVIDE,     { "/"     , "/",                }},
-    { KEY_EN_NUMPAD_TIMES,      { "*"     , "*",                }},
-    { KEY_EN_NUMPAD_MINUS,      { "-"     , "-",                }},
-    { KEY_EN_NUMPAD_PLUS,       { "+"     , "+",                }},
-    { KEY_EN_NUMPAD_PERIOD,     { "."     , ".",                }},
-    { KEY_EN_NUMPAD_ENTER,      { "Ent"   , "\xE2\x86\xB5"      }}, // ↵ ⏎
-    { KEY_EN_NUMPAD_0,          { "0"     , "0",                }},
-    { KEY_EN_NUMPAD_1,          { "1"     , "1",                }},
-    { KEY_EN_NUMPAD_2,          { "2"     , "2",                }},
-    { KEY_EN_NUMPAD_3,          { "3"     , "3",                }},
-    { KEY_EN_NUMPAD_4,          { "4"     , "4",                }},
-    { KEY_EN_NUMPAD_5,          { "5"     , "5",                }},
-    { KEY_EN_NUMPAD_6,          { "6"     , "6",                }},
-    { KEY_EN_NUMPAD_7,          { "7"     , "7",                }},
-    { KEY_EN_NUMPAD_8,          { "8"     , "8",                }},
-    { KEY_EN_NUMPAD_9,          { "9"     , "9",                }},
-    { KEY_EN_MEDIA_PLAY_PAUSE,  { "Ply"   , "\xE2\x8F\xAF",     }}, // ⏯
-    { KEY_EN_MEDIA_PREVIOUS,    { "Prv"   , "\xE2\x8F\xAE",     }}, // ⏮
-    { KEY_EN_MEDIA_NEXT,        { "Nxt"   , "\xE2\x8F\xAD",     }}, // ⏭
-    { KEY_EN_MEDIA_STOP,        { "Stp"   , "\xE2\x8F\xB9",     }}, // ⏹
-    { KEY_EN_MEDIA_MUTE,        { "Mte"   , "\xF0\x9F\x94\x87", }}, // 🔇
-    { KEY_EN_MEDIA_VOLUME_DOWN, { "Vl-"   , "\xF0\x9F\x94\x88", }}, // 🔉
-    { KEY_EN_MEDIA_VOLUME_UP,   { "Vl+"   , "\xF0\x9F\x94\x89", }}, // 🔊
-    { KEY_EN_POWER,             { "Pwr"   , "\xE2\x8F\xBB",     }}, // ⏻
-    { KEY_JP_RO,                { "_"     , "_",                }},
-    { KEY_JP_EJ,                { "E/J"   , "E/J",              }},
-    { KEY_JP_ZENKAKU,           { "Zen"   , "\xE5\x8D\x8A\xE8"
-                                            "\xA7\x92\x2F\xE5"
-                                            "\x85\xA8\xE8\xA7"
-                                            "\x92",             }}, // 半角/全角
-    { KEY_JP_KANA,              { "Kana"  , "\xE3\x81\x8B\xE3"
-                                            "\x81\xAA",         }}, // かな
-    { KEY_JP_HENKAN,            { "Hnkn"  , "\xE5\xA4\x89\xE6"
-                                            "\x8F\x9B",         }}, // 変換
-    { KEY_JP_MUHENKAN,          { "MuKn"  , "\xE7\x84\xA1\xE5"
-                                            "\xA4\x89\xE6\x8F"
-                                            "\x9B",             }}, // 無変換
-    { KEY_JP_YEN,               { "Yen"   , "\xC2\xA5",         }}, // ¥
-    { KEY_JP_AT,                { "@"     , "@",                }},
-    { KEY_JP_CHEVRON,           { "^"     , "^",                }},
-    { KEY_JP_COLON,             { ":"     , ":",                }},
-    { KEY_KR_HAN,               { "Hayg"  , "\xED\x95\x9C\x2F"
-                                            "\xEC\x98\x81",     }}, // 한/영
-    { KEY_KR_HANJA,             { "Haja"  , "\xED\x95\x9C\xEC"
-                                            "\x9E\x90",         }}, // 한자
-    { KEY_NORD_AAL,             { "Å"     , "\xC3\x85",         }}, // Å
-    { KEY_NORD_A_OE,            { "Ä Ø"   , "\xC3\x84\x20\xC3"
-                                            "\x98"              }}, // Ä Ø
-    { KEY_NORD_O_AE,            { "Ö Æ"   , "\xC3\x96\x20\xC3"
-                                            "\x86"              }}, // Ö Æ
-    { KEY_NORD_HALF,            { "§ ½"   , "\xC2\xA7\x20\xC2"
-                                            "\xBD"              }}, // § ½
-    { KEY_NORD_HYPHEN,          { "- _"   , "- _"               }},
-    { KEY_NORD_PLUS_QUESTION,   { "+ ?"   , "+ ?",              }},
-    { KEY_NORD_ACUTE_GRAVE,     { "´ `"   , "\xC2\xB4\x20\x60", }}, // ´ `
-    { KEY_NORD_DOTS_CARET,      { "¨ ^"   , "\xC2\xA8\x20\x5E", }}, // ¨ ^
-    { KEY_NORD_QUOTE,           { "' *"   , "' *",              }},
-    { KEY_NORD_ANGLE_BRACKET,   { "< >"   , "< >"               }},
-    { KEY_DE_ESZETT,            { "ß"     , "\xc3\x9F",         }},
-    { KEY_DE_DIAERESIS_A,       { "Ä"     , "\xC3\x84",         }},
-    { KEY_DE_DIAERESIS_O,       { "Ö"     , "\xC3\x96",         }},
-    { KEY_DE_DIAERESIS_U,       { "Ü"     , "\xC3\x9C"          }},
-    { KEY_FR_SUPER_2,           { "²"     , "\xc2\xb2"          }},
-    { KEY_FR_AMPERSAND,         { "&"     , "&"                 }},
-    { KEY_FR_ACUTE_E,           { "é"     , "\xc3\xa9"          }},
-    { KEY_FR_DOUBLEQUOTE,       { "\""    , "\""                }},
-    { KEY_FR_LEFT_PARENTHESIS,  { "("     , "("                 }},
-    { KEY_FR_GRAVE_E,           { "è"     , "\xc3\xa8"          }},
-    { KEY_FR_UNDERSCORE,        { "_"     , "_"                 }},
-    { KEY_FR_CEDILLA_C,         { "ç"     , "\xc3\xa7"          }},
-    { KEY_FR_GRAVE_A,           { "à"     , "\xc3\xa0"          }},
-    { KEY_FR_RIGHT_PARENTHESIS, { ")"     , ")"                 }},
-    { KEY_FR_DOLLAR,            { "$"     , "$"                 }},
-    { KEY_FR_GRAVE_U,           { "ù"     , "\xc3\xb9"          }},
-    { KEY_FR_ASTERIX,           { "*"     , "*"                 }},
-    { KEY_FR_EXCLAIMATION,      { "!"     , "!"                 }},
-    { KEY_ES_OPEN_QUESTION_MARK,{ "¿"     , "¡"                 }},
-    { KEY_ES_TILDE,             { "´"     , "¨"                 }},
-    { KEY_ES_ENIE,              { "ñ"     , "Ñ"                 }},
-};
-
-void DeviceView::setController(RGBController * controller_ptr)
-{
-    /*-----------------------------------------------------*\
-    | Store the controller pointer                          |
-    \*-----------------------------------------------------*/
-    controller = controller_ptr;
-}
-
-void DeviceView::InitDeviceView()
-{
-    /*-----------------------------------------------------*\
-    | Set the size of the selection flags vector            |
-    \*-----------------------------------------------------*/
-    selectionFlags.resize((int)controller->leds.size());
-
-    /*-----------------------------------------------------*\
-    | Set the size of the zone and LED position vectors     |
-    \*-----------------------------------------------------*/
-    zone_pos.resize(controller->zones.size());
-    led_pos.resize(controller->leds.size());
-    led_labels.resize(controller->leds.size());
-
-    /*-----------------------------------------------------*\
-    | Process position and size for zones                   |
-    \*-----------------------------------------------------*/
-    unsigned int maxWidth       = 0;
-    unsigned int segment_count  = 0;
-    float        totalHeight    = 0.0f;
-
-    /*-----------------------------------------------------*\
-    | Get device view settings                              |
-    \*-----------------------------------------------------*/
-    SettingsManager*    settings_manager    = ResourceManager::get()->GetSettingsManager();
-    std::string         ui_string           = "UserInterface";
-    json                ui_settings;
-
-    bool                disable_expansion   = false;
-
-    ui_settings = settings_manager->GetSettings(ui_string);
-
-    if(ui_settings.contains("disable_key_expansion"))
-    {
-        disable_expansion       = ui_settings["disable_key_expansion"];
-    }
-
-    /*-----------------------------------------------------*\
-    | Determine the total height (in LEDs) of all zones     |
-    \*-----------------------------------------------------*/
-    for(std::size_t zone_idx = 0; zone_idx < controller->zones.size(); zone_idx++)
-    {
-        /*-----------------------------------------------------*\
-        | For matrix zones, use matrix height from the map      |
-        \*-----------------------------------------------------*/
-        if((controller->zones[zone_idx].type == ZONE_TYPE_MATRIX) && (controller->zones[zone_idx].matrix_map))
-        {
-            totalHeight                += controller->zones[zone_idx].matrix_map->height;
-            zone_pos[zone_idx].matrix_w = controller->zones[zone_idx].matrix_map->width;
-        }
-        /*-----------------------------------------------------*\
-        | For all other zones, compute the height including     |
-        | wrap-around                                           |
-        \*-----------------------------------------------------*/
-        else if(controller->zones[zone_idx].segments.size() > 0)
-        {
-            for(std::size_t segment_idx = 0; segment_idx < controller->zones[zone_idx].segments.size(); segment_idx++)
-            {
-                unsigned int count          = controller->zones[zone_idx].segments[segment_idx].leds_count;
-                zone_pos[zone_idx].matrix_w = std::min(count, (unsigned int)MAX_COLS);
-                totalHeight                += (count / MAX_COLS) + ((count % MAX_COLS) > 0);
-
-                segment_count++;
-            }
-        }
-        else
-        {
-            unsigned int count          = controller->zones[zone_idx].leds_count;
-            zone_pos[zone_idx].matrix_w = std::min(count, (unsigned int)MAX_COLS);
-            totalHeight                += (count / MAX_COLS) + ((count % MAX_COLS) > 0);
-        }
-
-        /*-----------------------------------------------------*\
-        | Determine the maximum width (in LEDs) in the view     |
-        \*-----------------------------------------------------*/
-        if(zone_pos[zone_idx].matrix_w > maxWidth)
-        {
-            maxWidth = zone_pos[zone_idx].matrix_w;
-        }
-    }
-
-    segment_pos.resize(segment_count);
-
-    /*-----------------------------------------------------*\
-    | Add some space for zone names and padding             |
-    \*-----------------------------------------------------*/
-    totalHeight    += controller->zones.size() * PAD_ZONE;
-    totalHeight    += segment_count * PAD_SEGMENT;
-
-    float current_y = 0;                    // We will be descending, placing each zone one unit below the previous one
-    matrix_h        = totalHeight;
-    segment_count   = 0;
-
-    for(std::size_t zone_idx = 0; zone_idx < controller->zones.size(); zone_idx++)
-    {
-        /*-----------------------------------------------------*\
-        | Calculate zone label position and size                |
-        \*-----------------------------------------------------*/
-        zone_pos[zone_idx].matrix_x = (maxWidth - zone_pos[zone_idx].matrix_w) / 2.0f;
-        zone_pos[zone_idx].matrix_y = current_y + SIZE_TEXT;
-        zone_pos[zone_idx].matrix_h = SIZE_TEXT - PAD_TEXT;
-        current_y                  += PAD_ZONE;
-
-        /*-----------------------------------------------------*\
-        | Calculate LEDs position and size for zone             |
-        \*-----------------------------------------------------*/
-        if((controller->zones[zone_idx].type == ZONE_TYPE_MATRIX) && (controller->zones[zone_idx].matrix_map))
-        {
-            matrix_map_type * map = controller->zones[zone_idx].matrix_map;
-
-            for(unsigned int led_x = 0; led_x < map->width; led_x++)
-            {
-                for(unsigned int led_y = 0; led_y < map->height; led_y++)
-                {
-                    unsigned int map_idx    = led_y * map->width + led_x;
-                    unsigned int color_idx  = map->map[map_idx] + controller->zones[zone_idx].start_idx;
-
-                    if(map->map[map_idx] != 0xFFFFFFFF && color_idx < led_pos.size())
-                    {
-                        led_pos[color_idx].matrix_x = (zone_pos[zone_idx].matrix_x + led_x + PAD_LED);
-                        led_pos[color_idx].matrix_y = current_y + (led_y + PAD_LED);
-
-                        /*-----------------------------------------------------*\
-                        | LED is a 1x1 square, minus padding on all sides       |
-                        \*-----------------------------------------------------*/
-                        led_pos[color_idx].matrix_w = (1.0f - (2.0f * PAD_LED));
-                        led_pos[color_idx].matrix_h = (1.0f - (2.0f * PAD_LED));
-
-                        if(!disable_expansion)
-                        {
-                            /*-----------------------------------------------------*\
-                            | Expand large keys to fill empty spaces in matrix, if  |
-                            | possible.  Large keys can fill left, down, up, or wide|
-                            | Fill Left:                                            |
-                            |    Tab                                                |
-                            |    Caps Lock                                          |
-                            |    Left Shift                                         |
-                            |    Right Shift                                        |
-                            |    Backspace                                          |
-                            |    Number Pad 0                                       |
-                            |                                                       |
-                            | Fill Up or Down:                                      |
-                            |    Number Pad Enter                                   |
-                            |    Number Pad +                                       |
-                            |                                                       |
-                            | Fill Wide:                                            |
-                            |    Space                                              |
-                            \*-----------------------------------------------------*/
-                            if(led_x < map->width - 1 && map->map[map_idx + 1] == 0xFFFFFFFF)
-                            {
-                                if( ( controller->leds[color_idx].name == KEY_EN_TAB        )
-                                 || ( controller->leds[color_idx].name == KEY_EN_CAPS_LOCK  )
-                                 || ( controller->leds[color_idx].name == KEY_EN_LEFT_SHIFT )
-                                 || ( controller->leds[color_idx].name == KEY_EN_RIGHT_SHIFT)
-                                 || ( controller->leds[color_idx].name == KEY_EN_BACKSPACE  )
-                                 || ( controller->leds[color_idx].name == KEY_EN_NUMPAD_0   ) )
-                                {
-                                    led_pos[color_idx].matrix_w += 1.0f;
-                                }
-                            }
-                            if( ( controller->leds[color_idx].name == KEY_EN_NUMPAD_ENTER   )
-                             || ( controller->leds[color_idx].name == KEY_EN_NUMPAD_PLUS    ) )
-                            {
-                                if(led_y < map->height - 1 && map->map[map_idx + map->width] == 0xFFFFFFFF)
-                                {
-                                    led_pos[color_idx].matrix_h += 1.0f;
-                                }
-                                /* TODO: check if there isn't another widened key above */
-                                else if(led_y > 0 && map->map[map_idx - map->width] == 0xFFFFFFFF)
-                                {
-                                    led_pos[color_idx].matrix_y -= 1.0f;
-                                    led_pos[color_idx].matrix_h += 1.0f;
-                                }
-                            }
-                            else if(controller->leds[color_idx].name == KEY_EN_SPACE)
-                            {
-                                for(unsigned int map_idx2 = map_idx - 1; map_idx2 > led_y * map->width && map->map[map_idx2] == 0xFFFFFFFF; map_idx2--)
-                                {
-                                    led_pos[color_idx].matrix_x -= 1.0f;
-                                    led_pos[color_idx].matrix_w += 1.0f;
-                                }
-                                for(unsigned int map_idx2 = map_idx + 1; map_idx2 < (led_y + 1) * map->width && map->map[map_idx2] == 0xFFFFFFFF; map_idx2++)
-                                {
-                                    led_pos[color_idx].matrix_w += 1.0f;
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-
-            current_y += map->height;
-        }
-        else if(controller->zones[zone_idx].segments.size() > 0)
-        {
-            for(std::size_t segment_idx = 0; segment_idx < controller->zones[zone_idx].segments.size(); segment_idx++)
-            {
-                /*-----------------------------------------------------*\
-                | Calculate segment label position and size             |
-                \*-----------------------------------------------------*/
-                segment_pos[segment_count].matrix_x = (maxWidth - zone_pos[zone_idx].matrix_w) / 2.0f;
-                segment_pos[segment_count].matrix_y = current_y + SIZE_TEXT;
-                segment_pos[segment_count].matrix_w = zone_pos[zone_idx].matrix_w;
-                segment_pos[segment_count].matrix_h = SIZE_TEXT - PAD_TEXT;
-                current_y                          += PAD_SEGMENT;
-
-                segment_count++;
-
-                /*-----------------------------------------------------*\
-                | Calculate LED box positions for segmented zones       |
-                \*-----------------------------------------------------*/
-                unsigned int leds_count = controller->zones[zone_idx].segments[segment_idx].leds_count;
-
-                for(unsigned int led_idx = 0; led_idx < leds_count; led_idx++)
-                {
-                    unsigned int led_pos_idx = controller->zones[zone_idx].start_idx + controller->zones[zone_idx].segments[segment_idx].start_idx + led_idx;
-
-                    led_pos[led_pos_idx].matrix_x = zone_pos[zone_idx].matrix_x + ((led_idx % MAX_COLS) + PAD_LED);
-                    led_pos[led_pos_idx].matrix_y = current_y + ((led_idx / MAX_COLS) + PAD_LED);
-
-                    /*-----------------------------------------------------*\
-                    | LED is a 1x1 square, minus padding on all sides       |
-                    \*-----------------------------------------------------*/
-                    led_pos[led_pos_idx].matrix_w = (1.0f - (2.0f * PAD_LED));
-                    led_pos[led_pos_idx].matrix_h = (1.0f - (2.0f * PAD_LED));
-                }
-
-                current_y += (leds_count / MAX_COLS) + ((leds_count % MAX_COLS) > 0);
-            }
-        }
-        else
-        {
-            /*-----------------------------------------------------*\
-            | Calculate LED box positions for single/linear zones   |
-            \*-----------------------------------------------------*/
-            unsigned int leds_count = controller->zones[zone_idx].leds_count;
-
-            for(unsigned int led_idx = 0; led_idx < leds_count; led_idx++)
-            {
-                unsigned int led_pos_idx = controller->zones[zone_idx].start_idx + led_idx;
-
-                led_pos[led_pos_idx].matrix_x = zone_pos[zone_idx].matrix_x + ((led_idx % MAX_COLS) + PAD_LED);
-                led_pos[led_pos_idx].matrix_y = current_y + ((led_idx / MAX_COLS) + PAD_LED);
-
-                /*-----------------------------------------------------*\
-                | LED is a 1x1 square, minus padding on all sides       |
-                \*-----------------------------------------------------*/
-                led_pos[led_pos_idx].matrix_w = (1.0f - (2.0f * PAD_LED));
-                led_pos[led_pos_idx].matrix_h = (1.0f - (2.0f * PAD_LED));
-            }
-
-            current_y += (leds_count / MAX_COLS) + ((leds_count % MAX_COLS) > 0);
-        }
-    }
-
-    /*-----------------------------------------------------*\
-    | Update LED labels                                     |
-    \*-----------------------------------------------------*/
-    for(std::size_t led_idx = 0; led_idx < controller->leds.size(); led_idx++)
-    {
-        std::map<std::string, led_label>::const_iterator it = led_label_lookup.find(controller->leds[led_idx].name);
-
-        if(it != led_label_lookup.end())
-        {
-            led_labels[led_idx] = it->second.label_utf8;
-        }
-        else if(numerical_labels)
-        {
-            led_labels[led_idx] = QString::number(led_idx);
-        }
-    }
-
-    /*-----------------------------------------------------*\
-    | Scale the zones, segments, and LEDs                   |
-    |                                                       |
-    | Atom is the width of a single square; if the whole    |
-    | thing becomes too tall, we ignore it and let the view |
-    | widget take care of it                                |
-    \*-----------------------------------------------------*/
-    float atom = 1.0f / maxWidth;
-
-    for(std::size_t zone_idx = 0; zone_idx < zone_pos.size(); zone_idx++)
-    {
-        zone_pos[zone_idx].matrix_x *= atom;
-        zone_pos[zone_idx].matrix_y *= atom;
-        zone_pos[zone_idx].matrix_w *= atom;
-        zone_pos[zone_idx].matrix_h *= atom;
-    }
-
-    for(std::size_t segment_idx = 0; segment_idx < segment_pos.size(); segment_idx++)
-    {
-        segment_pos[segment_idx].matrix_x *= atom;
-        segment_pos[segment_idx].matrix_y *= atom;
-        segment_pos[segment_idx].matrix_w *= atom;
-        segment_pos[segment_idx].matrix_h *= atom;
-    }
-
-    for(std::size_t led_idx = 0; led_idx < led_pos.size(); led_idx++)
-    {
-        led_pos[led_idx].matrix_x *= atom;
-        led_pos[led_idx].matrix_y *= atom;
-        led_pos[led_idx].matrix_w *= atom;
-        led_pos[led_idx].matrix_h *= atom;
-    }
-
-    matrix_h *= atom;
-
-    /*-----------------------------------------------------*\
-    | Update cached size and offset                         |
-    \*-----------------------------------------------------*/
-    size     = width();
-    offset_x = 0;
-
-    if(height() < size * matrix_h)
-    {
-        size     = height() / matrix_h;
-        offset_x = (width() - size) / 2;
-    }
-}
-
-void DeviceView::setNumericalLabels(bool enable)
-{
-    numerical_labels = enable;
-}
-
-void DeviceView::setPerLED(bool per_led_mode)
-{
-    per_led = per_led_mode;
-    update();
-}
-
-QSize DeviceView::sizeHint () const
-{
-    return QSize(height() - 1, height() - 1);
-}
-
-QSize DeviceView::minimumSizeHint () const
-{
-    return initSize;
-}
-
-void DeviceView::mousePressEvent(QMouseEvent *event)
-{
-    if(per_led)
-    {
-        ctrlDown    = event->modifiers().testFlag(Qt::ControlModifier);
-        mouseDown   = true;
-        mouseMoved  = false;
-
-        if(ctrlDown)
-        {
-            previousFlags = selectionFlags;
-            previousSelection = selectedLeds;
-        }
-
-        /*-----------------------------------------------------*\
-        | It's okay if the size becomes negative                |
-        \*-----------------------------------------------------*/
-        selectionRect.setLeft(event->x());
-        selectionRect.setTop(event->y());
-        selectionRect.setRight(event->x());
-        selectionRect.setBottom(event->y());
-
-        updateSelection();
-        update();
-    }
-}
-
-void DeviceView::mouseMoveEvent(QMouseEvent *event)
-{
-    if(per_led)
-    {
-        lastMousePos = event->pos();
-        selectionRect.setRight(event->x());
-        selectionRect.setBottom(event->y());
-
-        if(mouseDown)
-        {
-            mouseMoved  = true;
-            ctrlDown    = event->modifiers().testFlag(Qt::ControlModifier);
-
-            /*-----------------------------------------------------*\
-            | Clear the previous selection in case ctrl is released |
-            \*-----------------------------------------------------*/
-            if(!ctrlDown)
-            {
-                previousSelection.clear();
-                previousFlags.clear();
-                previousFlags.resize((int)controller->leds.size());
-            }
-            updateSelection();
-        }
-        update();
-    }
-}
-
-void DeviceView::mouseReleaseEvent(QMouseEvent* event)
-{
-    if(per_led)
-    {
-        selectionRect = selectionRect.normalized();
-        mouseDown = false;
-
-        /*-----------------------------------------------------*\
-        | Check if the user clicked a zone name & select it     |
-        \*-----------------------------------------------------*/
-        if(!mouseMoved)
-        {
-            int size     = width();
-            int offset_x = 0;
-
-            if(height() < size * matrix_h)
-            {
-                size     = height() / matrix_h;
-                offset_x = (width() - size) / 2;
-            }
-
-            unsigned int segment_count = 0;
-
-            for(unsigned int zone_idx = 0; zone_idx < controller->zones.size(); zone_idx++)
-            {
-                int posx = zone_pos[zone_idx].matrix_x * size + offset_x + 12;
-                int posy = zone_pos[zone_idx].matrix_y * size;
-                int posw = zone_pos[zone_idx].matrix_w * size;
-                int posh = zone_pos[zone_idx].matrix_h * size;
-
-                QRect rect = {posx, posy, posw, posh};
-
-                if(rect.contains(event->pos()))
-                {
-                    selectZone(zone_idx, ctrlDown);
-                }
-
-                for(unsigned int segment_idx = 0; segment_idx < controller->zones[zone_idx].segments.size(); segment_idx++)
-                {
-                    posx = segment_pos[segment_count].matrix_x * size + offset_x + 12;
-                    posy = segment_pos[segment_count].matrix_y * size;
-                    posw = segment_pos[segment_count].matrix_w * size;
-                    posh = segment_pos[segment_count].matrix_h * size;
-
-                    segment_count++;
-
-                    rect = {posx, posy, posw, posh};
-
-                    if(rect.contains(event->pos()))
-                    {
-                        selectSegment(zone_idx, segment_idx, ctrlDown);
-                    }
-                }
-            }
-        }
-        update();
-    }
-}
-
-void DeviceView::resizeEvent(QResizeEvent* /*event*/)
-{
-    size     = width();
-    offset_x = 0;
-
-    if(height() < size * matrix_h)
-    {
-        size     = height() / matrix_h;
-        offset_x = (width() - size) / 2;
-    }
-    update();
-}
-
-void DeviceView::paintEvent(QPaintEvent* /* event */)
-{
-    QPainter painter(this);
-    QFont font = painter.font();
-
-    /*-----------------------------------------------------*\
-    | If Device View is hidden, don't paint                 |
-    \*-----------------------------------------------------*/
-    if(isHidden() || !per_led)
-    {
-        return;
-    }
-
-    /*-----------------------------------------------------*\
-    | If controller has resized, reinitialize local data    |
-    \*-----------------------------------------------------*/
-    if(controller->leds.size() != led_pos.size())
-    {
-        InitDeviceView();
-    }
-
-    /*-----------------------------------------------------*\
-    | If segments have resized, reinitialize local data     |
-    \*-----------------------------------------------------*/
-    unsigned int segments = 0;
-
-    for(std::size_t zone_idx = 0; zone_idx < controller->zones.size(); zone_idx++)
-    {
-        for(std::size_t segment_idx = 0; segment_idx < controller->zones[zone_idx].segments.size(); segment_idx++)
-        {
-            segments++;
-        }
-    }
-
-    if(segments != segment_pos.size())
-    {
-        InitDeviceView();
-    }
-
-    /*-----------------------------------------------------*\
-    | LED rectangles                                        |
-    \*-----------------------------------------------------*/
-    for(unsigned int led_idx = 0; led_idx < controller->leds.size(); led_idx++)
-    {
-        int posx = led_pos[led_idx].matrix_x * size + offset_x;
-        int posy = led_pos[led_idx].matrix_y * size;
-        int posw = led_pos[led_idx].matrix_w * size;
-        int posh = led_pos[led_idx].matrix_h * size;
-
-        QRect rect = {posx, posy, posw, posh};
-
-        /*-----------------------------------------------------*\
-        | Fill color                                            |
-        \*-----------------------------------------------------*/
-        QColor currentColor = QColor::fromRgb(
-                    RGBGetRValue(controller->colors[led_idx]),
-                    RGBGetGValue(controller->colors[led_idx]),
-                    RGBGetBValue(controller->colors[led_idx]));
-        painter.setBrush(currentColor);
-
-        /*-----------------------------------------------------*\
-        | Border color                                          |
-        \*-----------------------------------------------------*/
-        if(selectionFlags[led_idx])
-        {
-            painter.setPen(palette().highlight().color());
-        }
-        else
-        {
-            painter.setPen(palette().dark().color());
-        }
-        painter.drawRect(rect);
-
-        /*-----------------------------------------------------*\
-        | Label                                                 |
-        | Set the font color so that the text is visible        |
-        \*-----------------------------------------------------*/
-        font.setPixelSize(posh / 2);
-        painter.setFont(font);
-
-        unsigned int luma = (unsigned int)(0.2126f * currentColor.red() + 0.7152f * currentColor.green() + 0.0722f * currentColor.blue());
-
-        if(luma > 127)
-        {
-            painter.setPen(Qt::black);
-        }
-        else
-        {
-            painter.setPen(Qt::white);
-        }
-        painter.drawText(rect, Qt::AlignVCenter | Qt::AlignHCenter, QString(led_labels[led_idx]));
-    }
-
-    font.setPixelSize(12);
-    painter.setFont(font);
-
-    /*-----------------------------------------------------*\
-    | Zone and Segment names                                |
-    \*-----------------------------------------------------*/
-    unsigned int segment_count = 0;
-
-    for(std::size_t zone_idx = 0; zone_idx < controller->zones.size(); zone_idx++)
-    {
-        int posx = zone_pos[zone_idx].matrix_x * size + offset_x;
-        int posy = zone_pos[zone_idx].matrix_y * size;
-        int posw = zone_pos[zone_idx].matrix_w * size;
-        int posh = zone_pos[zone_idx].matrix_h * size;
-
-        QRect rect = {posx, posy, posw, posh};
-
-        if(rect.contains(lastMousePos) && (!mouseDown || !mouseMoved))
-        {
-            painter.setPen(palette().highlight().color());
-        }
-        else
-        {
-            painter.setPen(palette().windowText().color());
-        }
-        painter.drawText(posx, posy + posh, QString(controller->zones[zone_idx].name.c_str()));
-
-        for(std::size_t segment_idx = 0; segment_idx < controller->zones[zone_idx].segments.size(); segment_idx++)
-        {
-            posx = segment_pos[segment_count].matrix_x * size + offset_x;
-            posy = segment_pos[segment_count].matrix_y * size;
-            posw = segment_pos[segment_count].matrix_w * size;
-            posh = segment_pos[segment_count].matrix_h * size;
-
-            segment_count++;
-
-            rect = {posx, posy, posw, posh};
-
-            if(rect.contains(lastMousePos) && (!mouseDown || !mouseMoved))
-            {
-                painter.setPen(palette().highlight().color());
-            }
-            else
-            {
-                painter.setPen(palette().windowText().color());
-            }
-            painter.drawText(posx, posy + posh, QString(controller->zones[zone_idx].segments[segment_idx].name.c_str()));
-        }
-    }
-
-    /*-----------------------------------------------------*\
-    | Selection area                                        |
-    \*-----------------------------------------------------*/
-    if(mouseDown)
-    {
-        QRect rect = selectionRect.normalized();
-        QColor color = palette().highlight().color();
-        color.setAlpha(63);
-        painter.fillRect(rect, color);
-        color.setAlpha(127);
-        painter.setBrush(color);
-        painter.drawRect(rect);
-    }
-}
-
-void DeviceView::updateSelection()
-{
-    selectedLeds.clear();
-    selectionFlags.clear();
-    selectionFlags.resize((int)controller->leds.size());
-
-    QRect sel              = selectionRect.normalized();
-    std::vector<led>& leds = controller->leds;
-
-    for(unsigned int led_idx = 0; led_idx < leds.size(); led_idx++)
-    {
-        /*-----------------------------------------------------*\
-        | Check intersection                                    |
-        \*-----------------------------------------------------*/
-        int posx = led_pos[led_idx].matrix_x * size + offset_x;
-        int posy = led_pos[led_idx].matrix_y * size;
-        int posw = led_pos[led_idx].matrix_w * size;
-        int posh = led_pos[led_idx].matrix_h * size;
-
-        QRect rect = {posx, posy, posw, posh};
-
-        selectionFlags[led_idx] = 0;
-
-        if(sel.intersects(rect))
-        {
-            selectionFlags[led_idx] = 1;
-        }
-        if(ctrlDown)
-        {
-            selectionFlags[led_idx] ^= previousFlags[led_idx];
-        }
-
-        if(selectionFlags[led_idx])
-        {
-            selectedLeds.push_back(led_idx);
-        }
-    }
-
-    update();
-
-    /*-----------------------------------------------------*\
-    | Send selection changed signal                         |
-    \*-----------------------------------------------------*/
-    emit selectionChanged(selectedLeds);
-}
-
-bool DeviceView::selectLed(int target)
-{
-    if(target < 0 || size_t(target) >= controller->leds.size())
-    {
-        return false;
-    }
-
-    selectedLeds.resize(1);
-    selectedLeds[0] = target;
-    selectionFlags.clear();
-    selectionFlags.resize((int)controller->leds.size());
-    selectionFlags[target] = 1;
-
-    update();
-
-    /*-----------------------------------------------------*\
-    | Send selection changed signal                         |
-    \*-----------------------------------------------------*/
-    emit selectionChanged(selectedLeds);
-
-    return true;
-}
-
-bool DeviceView::selectLeds(QVector<int> target)
-{
-    for(int item: target)
-    {
-        if(item < 0 || size_t(item) >= controller->leds.size())
-        {
-            return false;
-        }
-    }
-
-    selectionFlags.clear();
-    selectionFlags.resize((int)controller->leds.size());
-
-    for(int item: target)
-    {
-        selectionFlags[item] = 1;
-    }
-
-    //selectedLeds = target;
-
-    /*-----------------------------------------------------*\
-    | Filter out duplicate items                            |
-    \*-----------------------------------------------------*/
-    selectedLeds.clear();
-
-    for(int i = 0; i < selectionFlags.size(); ++i)
-    {
-        if(selectionFlags[i])
-        {
-            selectedLeds.push_back(i);
-        }
-    }
-
-    update();
-
-    /*-----------------------------------------------------*\
-    | Send selection changed signal                         |
-    \*-----------------------------------------------------*/
-    emit selectionChanged(selectedLeds);
-
-    return true;
-}
-
-bool DeviceView::selectSegment(int zone, int segment, bool add)
-{
-    if(zone < 0 || size_t(zone) >= controller->zones.size())
-    {
-        return false;
-    }
-
-    if(segment < 0 || size_t(segment) >= controller->zones[zone].segments.size())
-    {
-        return false;
-    }
-
-    if(!add)
-    {
-        selectedLeds.clear();
-        selectionFlags.clear();
-        selectionFlags.resize((int)controller->leds.size());
-    }
-
-    int zoneStart = controller->zones[zone].start_idx;
-    int segStart = controller->zones[zone].segments[segment].start_idx;
-
-    for(int led_idx = 0; led_idx < (int)controller->zones[zone].segments[segment].leds_count; led_idx++)
-    {
-        if(!selectionFlags[zoneStart + segStart + led_idx])
-        {
-            selectedLeds.push_back(zoneStart + segStart + led_idx);
-            selectionFlags[zoneStart + segStart + led_idx] = 1;
-        }
-    }
-
-    update();
-
-    /*-----------------------------------------------------*\
-    | Send selection changed signal                         |
-    \*-----------------------------------------------------*/
-    emit selectionChanged(selectedLeds);
-
-    return true;
-}
-
-bool DeviceView::selectZone(int zone, bool add)
-{
-    if(zone < 0 || size_t(zone) >= controller->zones.size())
-    {
-        return false;
-    }
-
-    if(!add)
-    {
-        selectedLeds.clear();
-        selectionFlags.clear();
-        selectionFlags.resize((int)controller->leds.size());
-    }
-
-    int zoneStart = controller->zones[zone].start_idx;
-
-    for(int led_idx = 0; led_idx < (int)controller->zones[zone].leds_count; led_idx++)
-    {
-        if(!selectionFlags[zoneStart + led_idx])
-        {
-            selectedLeds.push_back(zoneStart + led_idx);
-            selectionFlags[zoneStart + led_idx] = 1;
-        }
-    }
-
-    update();
-
-    /*-----------------------------------------------------*\
-    | Send selection changed signal                         |
-    \*-----------------------------------------------------*/
-    emit selectionChanged(selectedLeds);
-
-    return true;
-}
-
-void DeviceView::clearSelection()
-{
-    /*-----------------------------------------------------*\
-    | Same as selecting the entire device                   |
-    \*-----------------------------------------------------*/
-    selectedLeds.clear();
-    selectionFlags.clear();
-    selectionFlags.resize((int)controller->leds.size());
-}
-
-void DeviceView::setSelectionColor(RGBColor color)
-{
-    if(selectedLeds.isEmpty())
-    {
-        controller->SetAllLEDs(color);
-    }
-    else
-    {
-        for(int led_idx: selectedLeds)
-        {
-            controller->SetLED(led_idx, color);
-        }
-    }
-    controller->UpdateLEDs();
-    update();
-}
diff --git a/qt/DeviceView.h b/qt/DeviceView.h
deleted file mode 100644
index e0f7f3ee..00000000
--- a/qt/DeviceView.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*---------------------------------------------------------*\
-| DeviceView.h                                              |
-|                                                           |
-|   OpenRGB Device view widget for Qt                       |
-|                                                           |
-|   Adam Honse (calcprogrammer1@gmail.com)                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QWidget>
-#include "RGBController.h"
-
-typedef struct
-{
-    float matrix_x;
-    float matrix_y;
-    float matrix_w;
-    float matrix_h;
-} matrix_pos_size_type;
-
-class DeviceView : public QWidget
-{
-    Q_OBJECT
-public:
-    explicit DeviceView(QWidget *parent = 0);
-    ~DeviceView();
-
-    virtual QSize sizeHint () const;
-    virtual QSize minimumSizeHint () const;
-
-    void setController(RGBController * controller_ptr);
-    void setNumericalLabels(bool enable);
-    void setPerLED(bool per_led_mode);
-
-protected:
-    void mousePressEvent(QMouseEvent *event);
-    void mouseMoveEvent(QMouseEvent *event);
-    void mouseReleaseEvent(QMouseEvent *);
-    void resizeEvent(QResizeEvent *event);
-    void paintEvent(QPaintEvent *);
-
-private:
-    QSize initSize;
-    bool mouseDown;
-    bool ctrlDown;
-    bool mouseMoved;
-    int size;
-    int offset_x;
-    QRect selectionRect;
-    QPoint lastMousePos;
-    QVector<int> previousSelection;
-    QVector<int> selectedLeds;
-    QVector<bool> selectionFlags;
-    QVector<bool> previousFlags;
-    bool per_led;
-
-    std::vector<matrix_pos_size_type>   zone_pos;
-    std::vector<matrix_pos_size_type>   segment_pos;
-    std::vector<matrix_pos_size_type>   led_pos;
-    std::vector<QString>                led_labels;
-
-    float                               matrix_h;
-
-    bool                                numerical_labels;
-
-    RGBController* controller;
-
-    QColor posColor(const QPoint &point);
-    void InitDeviceView();
-    void updateSelection();
-
-signals:
-    void selectionChanged(QVector<int>);
-
-public slots:
-    bool selectLed(int);
-    bool selectLeds(QVector<int>);
-    bool selectSegment(int zone, int segment, bool add = false);
-    bool selectZone(int zone, bool add = false);
-    void clearSelection(); // Same as selecting the entire device
-    void setSelectionColor(RGBColor);
-};
diff --git a/qt/OpenRGBClientInfoPage/OpenRGBClientInfoPage.cpp b/qt/OpenRGBClientInfoPage/OpenRGBClientInfoPage.cpp
deleted file mode 100644
index 7fc9e4b4..00000000
--- a/qt/OpenRGBClientInfoPage/OpenRGBClientInfoPage.cpp
+++ /dev/null
@@ -1,352 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBClientInfoPage.cpp                                 |
-|                                                           |
-|   User interface for OpenRGB client information page      |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <iostream>
-#include <QSignalMapper>
-#include <QCheckBox>
-#include "OpenRGBClientInfoPage.h"
-#include "ResourceManager.h"
-#include "SettingsManager.h"
-
-using namespace Ui;
-
-static void UpdateInfoCallback(void * this_ptr)
-{
-    OpenRGBClientInfoPage * this_obj = (OpenRGBClientInfoPage *)this_ptr;
-
-    QMetaObject::invokeMethod(this_obj, "UpdateInfo", Qt::QueuedConnection);
-}
-
-class NetworkClientPointer : public QObject
-{
-public:
-    NetworkClient * net_client;
-    QWidget *       widget;
-};
-
-OpenRGBClientInfoPage::OpenRGBClientInfoPage(QWidget *parent) :
-    QFrame(parent),
-    ui(new Ui::OpenRGBClientInfoPageUi)
-{
-    /*-----------------------------------------------------*\
-    | Set initial values for GUI fields                     |
-    \*-----------------------------------------------------*/
-    ui->setupUi(this);
-    ui->ClientIPValue->setText("127.0.0.1");
-    ui->ClientPortValue->setText(QString::number(OPENRGB_SDK_PORT));
-
-    /*-----------------------------------------------------*\
-    | Register callbacks for existing clients               |
-    \*-----------------------------------------------------*/
-    for(unsigned int client_idx = 0; client_idx < ResourceManager::get()->GetClients().size(); client_idx++)
-    {
-        ResourceManager::get()->GetClients()[client_idx]->RegisterClientInfoChangeCallback(UpdateInfoCallback, this);
-    }
-
-    /*-----------------------------------------------------*\
-    | Update the information view                           |
-    \*-----------------------------------------------------*/
-    UpdateInfo();
-}
-
-OpenRGBClientInfoPage::~OpenRGBClientInfoPage()
-{
-
-}
-
-void OpenRGBClientInfoPage::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void OpenRGBClientInfoPage::AddClient(NetworkClient* new_client)
-{
-    /*-----------------------------------------------------*\
-    | Add a new client to the list, register the callback,  |
-    | and update the information view if the pointer is     |
-    | valid                                                 |
-    \*-----------------------------------------------------*/
-    if(new_client != NULL)
-    {
-        ResourceManager::get()->GetClients().push_back(new_client);
-        new_client->RegisterClientInfoChangeCallback(UpdateInfoCallback, this);
-
-        UpdateInfo();
-    }
-}
-
-void OpenRGBClientInfoPage::UpdateInfo()
-{
-    /*-----------------------------------------------------*\
-    | Clear the tree view before recreating its contents    |
-    \*-----------------------------------------------------*/
-    ui->ClientTree->clear();
-
-    /*-----------------------------------------------------*\
-    | Set up the tree view header                           |
-    \*-----------------------------------------------------*/
-    ui->ClientTree->setColumnCount(4);
-    ui->ClientTree->header()->setStretchLastSection(false);
-    ui->ClientTree->header()->setSectionResizeMode(0, QHeaderView::Stretch);
-    ui->ClientTree->setColumnWidth(1, 100);
-    ui->ClientTree->setColumnWidth(2, 100);
-    ui->ClientTree->setColumnWidth(3, 100);
-
-    /*-----------------------------------------------------*\
-    | Set up a signal mapper to handle disconnect buttons   |
-    \*-----------------------------------------------------*/
-    QSignalMapper* signalMapper = new QSignalMapper(this);
-    connect(signalMapper, SIGNAL(mapped(QObject *)), this, SLOT(onClientDisconnectButton_clicked(QObject *)));
-
-    QSignalMapper* signalMapperSave = new QSignalMapper(this);
-    connect(signalMapperSave, SIGNAL(mapped(QObject *)), this, SLOT(onClientSaveCheckBox_clicked(QObject *)));
-
-    /*-------------------------------------------------*\
-    | Get Client settings                               |
-    \*-------------------------------------------------*/
-    json                client_settings;
-
-    client_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Client");
-
-    /*-----------------------------------------------------*\
-    | Loop through all clients in list and display them     |
-    \*-----------------------------------------------------*/
-    for(std::size_t client_idx = 0; client_idx < ResourceManager::get()->GetClients().size(); client_idx++)
-    {
-        /*-----------------------------------------------------*\
-        | Check to see if this client is in the saved clients   |
-        | list                                                  |
-        \*-----------------------------------------------------*/
-        bool found = false;
-        if(client_settings.contains("clients"))
-        {
-            for(unsigned int saved_client_idx = 0; saved_client_idx < client_settings["clients"].size(); saved_client_idx++)
-            {
-                if(client_settings["clients"][saved_client_idx].contains("ip") && client_settings["clients"][saved_client_idx].contains("port"))
-                {
-                    std::string     saved_ip    = client_settings["clients"][saved_client_idx]["ip"];
-                    unsigned short  saved_port  = client_settings["clients"][saved_client_idx]["port"];
-                    std::string     client_ip   = ResourceManager::get()->GetClients()[client_idx]->GetIP();
-                    unsigned short  client_port = ResourceManager::get()->GetClients()[client_idx]->GetPort();
-
-                    if((client_ip == saved_ip) && (client_port == saved_port))
-                    {
-                        found = true;
-                        break;
-                    }
-                }
-            }
-        }
-
-        /*-----------------------------------------------------*\
-        | Create the top level tree widget items and display the|
-        | client IP addresses and protocol versions in them     |
-        \*-----------------------------------------------------*/
-        QTreeWidgetItem* new_top_item = new QTreeWidgetItem(ui->ClientTree);
-        new_top_item->setText(0, QString::fromStdString(ResourceManager::get()->GetClients()[client_idx]->GetIP()));
-        new_top_item->setText(1, QString::number(ResourceManager::get()->GetClients()[client_idx]->GetProtocolVersion()));
-
-        /*-----------------------------------------------------*\
-        | Create the save checkbox                              |
-        \*-----------------------------------------------------*/
-        QCheckBox* new_checkbox = new QCheckBox( "" );
-        ui->ClientTree->setItemWidget(new_top_item, 2, new_checkbox);
-        new_checkbox->setChecked(found);
-
-        connect(new_checkbox, SIGNAL(clicked()), signalMapperSave, SLOT(map()));
-
-        NetworkClientPointer * new_save_arg = new NetworkClientPointer();
-        new_save_arg->net_client = ResourceManager::get()->GetClients()[client_idx];
-        new_save_arg->widget = new_checkbox;
-
-        signalMapperSave->setMapping(new_checkbox, new_save_arg);
-
-        /*-----------------------------------------------------*\
-        | Create the disconnect buttons and connect them to the |
-        | signal mapper                                         |
-        \*-----------------------------------------------------*/
-        QPushButton* new_button = new QPushButton(tr("Disconnect"));
-        ui->ClientTree->setItemWidget(new_top_item, 3, new_button);
-
-        connect(new_button, SIGNAL(clicked()), signalMapper, SLOT(map()));
-
-        NetworkClientPointer * new_arg = new NetworkClientPointer();
-        new_arg->net_client = ResourceManager::get()->GetClients()[client_idx];
-        new_arg->widget = new_button;
-
-        signalMapper->setMapping(new_button, new_arg);
-
-        /*-----------------------------------------------------*\
-        | Add child items for each device in the client         |
-        \*-----------------------------------------------------*/
-        for(std::size_t dev_idx = 0; dev_idx < ResourceManager::get()->GetClients()[client_idx]->server_controllers.size(); dev_idx++)
-        {
-            /*-----------------------------------------------------*\
-            | Create child tree widget items and display the device |
-            | names in them                                         |
-            \*-----------------------------------------------------*/
-            QTreeWidgetItem* new_item = new QTreeWidgetItem(new_top_item);
-            new_item->setText(0, QString::fromStdString(ResourceManager::get()->GetClients()[client_idx]->server_controllers[dev_idx]->name));
-
-            /*-----------------------------------------------------*\
-            | Add child items for each zone in the device           |
-            \*-----------------------------------------------------*/
-            for(std::size_t zone_idx = 0; zone_idx < ResourceManager::get()->GetClients()[client_idx]->server_controllers[dev_idx]->zones.size(); zone_idx++)
-            {
-                /*-----------------------------------------------------*\
-                | Create child tree widget items and display the zone   |
-                | names, number of LEDs, and types in them              |
-                \*-----------------------------------------------------*/
-                QTreeWidgetItem* new_child = new QTreeWidgetItem();
-
-                std::string zone_str = ResourceManager::get()->GetClients()[client_idx]->server_controllers[dev_idx]->zones[zone_idx].name + ", ";
-                zone_str.append(std::to_string(ResourceManager::get()->GetClients()[client_idx]->server_controllers[dev_idx]->zones[zone_idx].leds_count));
-                zone_str.append(" LEDs, ");
-                // TODO : translate
-                switch(ResourceManager::get()->GetClients()[client_idx]->server_controllers[dev_idx]->zones[zone_idx].type)
-                {
-                    case ZONE_TYPE_SINGLE:
-                        zone_str.append("Single");
-                    break;
-
-                    case ZONE_TYPE_LINEAR:
-                        zone_str.append("Linear");
-                        break;
-
-                    case ZONE_TYPE_MATRIX:
-                        zone_str.append("Matrix");
-                        break;
-                }
-
-                new_child->setText(0, QString::fromStdString(zone_str));
-
-                new_item->addChild(new_child);
-            }
-        }
-    }
-}
-
-void Ui::OpenRGBClientInfoPage::on_ClientConnectButton_clicked()
-{
-    /*-----------------------------------------------------*\
-    | Read the new client IP and Port values from the UI    |
-    \*-----------------------------------------------------*/
-    unsigned short  port = std::stoi(ui->ClientPortValue->text().toStdString());
-    std::string     ip   = ui->ClientIPValue->text().toStdString();
-
-    /*-----------------------------------------------------*\
-    | Create a new client and set name, IP, and port values |
-    \*-----------------------------------------------------*/
-    NetworkClient * rgb_client = new NetworkClient(ResourceManager::get()->GetRGBControllers());
-
-    std::string titleString = "OpenRGB ";
-    titleString.append(VERSION_STRING);
-
-    rgb_client->SetIP(ip.c_str());
-    rgb_client->SetName(titleString.c_str());
-    rgb_client->SetPort(port);
-
-    rgb_client->StartClient();
-
-    /*-----------------------------------------------------*\
-    | Add new client to list and register update callback   |
-    \*-----------------------------------------------------*/
-    ResourceManager::get()->RegisterNetworkClient(rgb_client);
-
-    rgb_client->RegisterClientInfoChangeCallback(UpdateInfoCallback, this);
-}
-
-void Ui::OpenRGBClientInfoPage::onClientDisconnectButton_clicked(QObject * arg)
-{
-    /*-----------------------------------------------------*\
-    | Get the pointer to the disconnecting client from args |
-    \*-----------------------------------------------------*/
-    NetworkClient * disconnect_client = ((NetworkClientPointer *)arg)->net_client;
-
-    /*-----------------------------------------------------*\
-    | Remove the client from the resource manager, which    |
-    | deletes the client                                    |
-    \*-----------------------------------------------------*/
-    ResourceManager::get()->UnregisterNetworkClient(disconnect_client);
-}
-
-void Ui::OpenRGBClientInfoPage::onClientSaveCheckBox_clicked(QObject * arg)
-{
-    /*-----------------------------------------------------*\
-    | Get the pointer to the client from args               |
-    \*-----------------------------------------------------*/
-    NetworkClient * save_client     = ((NetworkClientPointer *)arg)->net_client;
-    QCheckBox *     save_checkbox   = (QCheckBox *)((NetworkClientPointer *)arg)->widget;
-
-    json            client_settings;
-
-    /*-------------------------------------------------*\
-    | Get Client settings                               |
-    \*-------------------------------------------------*/
-    client_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Client");
-
-    if(save_checkbox->isChecked())
-    {
-        bool found = false;
-        for(unsigned int client_idx = 0; client_idx < client_settings["clients"].size(); client_idx++)
-        {
-            if(client_settings["clients"][client_idx].contains("ip") && client_settings["clients"][client_idx].contains("port"))
-            {
-                std::string     client_ip   = client_settings["clients"][client_idx]["ip"];
-                unsigned short  client_port = client_settings["clients"][client_idx]["port"];
-                std::string     save_ip     = save_client->GetIP();
-                unsigned short  save_port   = save_client->GetPort();
-
-                if((client_ip == save_ip) && (client_port == save_port))
-                {
-                    found = true;
-                    break;
-                }
-            }
-        }
-
-        if(!found)
-        {
-            json new_client;
-
-            new_client["ip"]    = save_client->GetIP();
-            new_client["port"]  = save_client->GetPort();
-
-            client_settings["clients"].push_back(new_client);
-        }
-    }
-    else
-    {
-        if(client_settings.contains("clients"))
-        {
-            for(unsigned int client_idx = 0; client_idx < client_settings["clients"].size(); client_idx++)
-            {
-                if(client_settings["clients"][client_idx].contains("ip") && client_settings["clients"][client_idx].contains("port"))
-                {
-                    std::string     client_ip   = client_settings["clients"][client_idx]["ip"];
-                    unsigned short  client_port = client_settings["clients"][client_idx]["port"];
-                    std::string     save_ip     = save_client->GetIP();
-                    unsigned short  save_port   = save_client->GetPort();
-
-                    if((client_ip == save_ip) && (client_port == save_port))
-                    {
-                        client_settings["clients"].erase(client_settings["clients"].begin() + client_idx);
-                        break;
-                    }
-                }
-            }
-        }
-    }
-
-    ResourceManager::get()->GetSettingsManager()->SetSettings("Client", client_settings);
-    ResourceManager::get()->GetSettingsManager()->SaveSettings();
-}
diff --git a/qt/OpenRGBClientInfoPage/OpenRGBClientInfoPage.h b/qt/OpenRGBClientInfoPage/OpenRGBClientInfoPage.h
deleted file mode 100644
index 19d2481f..00000000
--- a/qt/OpenRGBClientInfoPage/OpenRGBClientInfoPage.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBClientInfoPage.h                                   |
-|                                                           |
-|   User interface for OpenRGB client information page      |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QFrame>
-#include "RGBController.h"
-#include "ui_OpenRGBClientInfoPage.h"
-#include "NetworkClient.h"
-
-namespace Ui
-{
-    class OpenRGBClientInfoPage;
-}
-
-class Ui::OpenRGBClientInfoPage : public QFrame
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBClientInfoPage(QWidget *parent = nullptr);
-    ~OpenRGBClientInfoPage();
-
-    void AddClient(NetworkClient* new_client);
-
-public slots:
-    void UpdateInfo();
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_ClientConnectButton_clicked();
-    void onClientDisconnectButton_clicked(QObject * arg);
-    void onClientSaveCheckBox_clicked(QObject * arg);
-
-private:
-    Ui::OpenRGBClientInfoPageUi *ui;
-};
diff --git a/qt/OpenRGBClientInfoPage/OpenRGBClientInfoPage.ui b/qt/OpenRGBClientInfoPage/OpenRGBClientInfoPage.ui
deleted file mode 100644
index 8ebc2973..00000000
--- a/qt/OpenRGBClientInfoPage/OpenRGBClientInfoPage.ui
+++ /dev/null
@@ -1,101 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBClientInfoPageUi</class>
- <widget class="QFrame" name="OpenRGBClientInfoPageUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>664</width>
-    <height>300</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Client info page</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="0" column="6">
-    <widget class="QLineEdit" name="ClientPortValue">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
-       <horstretch>0</horstretch>
-       <verstretch>0</verstretch>
-      </sizepolicy>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="5">
-    <widget class="QLabel" name="ClientPortLabel">
-     <property name="text">
-      <string>Port:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="7">
-    <spacer name="horizontalSpacer">
-     <property name="orientation">
-      <enum>Qt::Horizontal</enum>
-     </property>
-     <property name="sizeHint" stdset="0">
-      <size>
-       <width>40</width>
-       <height>20</height>
-      </size>
-     </property>
-    </spacer>
-   </item>
-   <item row="0" column="8">
-    <widget class="QPushButton" name="ClientConnectButton">
-     <property name="text">
-      <string>Connect</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="4">
-    <widget class="QLineEdit" name="ClientIPValue"/>
-   </item>
-   <item row="0" column="3">
-    <widget class="QLabel" name="ClientIPLabel">
-     <property name="text">
-      <string>IP:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="3" colspan="6">
-    <widget class="QTreeWidget" name="ClientTree">
-     <property name="columnCount">
-      <number>4</number>
-     </property>
-     <column>
-      <property name="text">
-       <string>Connected Clients</string>
-      </property>
-     </column>
-     <column>
-      <property name="text">
-       <string>Protocol Version</string>
-      </property>
-     </column>
-     <column>
-      <property name="text">
-       <string>Save Connection</string>
-      </property>
-     </column>
-     <column>
-      <property name="text">
-       <string/>
-      </property>
-     </column>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <tabstops>
-  <tabstop>ClientIPValue</tabstop>
-  <tabstop>ClientPortValue</tabstop>
-  <tabstop>ClientConnectButton</tabstop>
-  <tabstop>ClientTree</tabstop>
- </tabstops>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBConsolePage/OpenRGBConsolePage.cpp b/qt/OpenRGBConsolePage/OpenRGBConsolePage.cpp
deleted file mode 100644
index ebab8b02..00000000
--- a/qt/OpenRGBConsolePage/OpenRGBConsolePage.cpp
+++ /dev/null
@@ -1,92 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBConsolePage.cpp                                    |
-|                                                           |
-|   User interface for OpenRGB console page                 |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <stdio.h>
-#include "OpenRGBConsolePage.h"
-#include "LogManager.h"
-
-using namespace Ui;
-
-OpenRGBConsolePage::OpenRGBConsolePage(QWidget *parent) :
-    QFrame(parent),
-    ui(new Ui::OpenRGBConsolePageUi)
-{
-    ui->setupUi(this);
-
-    ui->log_level->blockSignals(true);
-    ui->log_level->addItems({
-                                "Fatal",
-                                "Error",
-                                "Warning",
-                                "Info",
-                                "Verbose",
-                                "Debug",
-                                "Trace"
-                            });
-
-    ui->log_level->setCurrentIndex(LogManager::get()->getLoglevel());
-    ui->log_level->blockSignals(false);
-
-#ifdef _WIN32
-    ui->logs->setFontFamily("Courier New");
-#endif
-    Refresh();
-}
-
-void OpenRGBConsolePage::Refresh()
-{
-    QString log;
-
-    unsigned int current_level = LogManager::get()->getLoglevel();
-
-    for(PLogMessage& message: LogManager::get()->messages())
-    {
-        unsigned int message_level = message.get()->level;
-
-        if(message_level <= current_level || message_level == LL_DIALOG)
-        {
-            log += "[";
-            log += LogManager::log_codes[message_level];
-            log += "] ";
-            log += QString::fromStdString(message.get()->buffer);
-            log += "\n";
-        }
-    }
-
-    ui->logs->setText(log);
-}
-
-void OpenRGBConsolePage::on_log_level_currentIndexChanged(int index)
-{
-    LogManager::get()->setLoglevel(index);
-}
-
-void OpenRGBConsolePage::on_clear_clicked()
-{
-    LogManager::get()->clearMessages();
-    ui->logs->clear();
-}
-
-void OpenRGBConsolePage::on_refresh_clicked()
-{
-    Refresh();
-}
-
-OpenRGBConsolePage::~OpenRGBConsolePage()
-{
-    delete ui;
-}
-
-void OpenRGBConsolePage::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
diff --git a/qt/OpenRGBConsolePage/OpenRGBConsolePage.h b/qt/OpenRGBConsolePage/OpenRGBConsolePage.h
deleted file mode 100644
index 96499dcf..00000000
--- a/qt/OpenRGBConsolePage/OpenRGBConsolePage.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBConsolePage.h                                      |
-|                                                           |
-|   User interface for OpenRGB console page                 |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QFrame>
-#include "ui_OpenRGBConsolePage.h"
-
-namespace Ui
-{
-    class OpenRGBConsolePage;
-}
-
-class Ui::OpenRGBConsolePage : public QFrame
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBConsolePage(QWidget *parent = nullptr);
-    ~OpenRGBConsolePage();
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_log_level_currentIndexChanged(int);
-    void on_clear_clicked();
-    void on_refresh_clicked();
-
-private:
-    Ui::OpenRGBConsolePageUi *ui;
-
-    void Refresh();
-};
diff --git a/qt/OpenRGBConsolePage/OpenRGBConsolePage.ui b/qt/OpenRGBConsolePage/OpenRGBConsolePage.ui
deleted file mode 100644
index 0fe89653..00000000
--- a/qt/OpenRGBConsolePage/OpenRGBConsolePage.ui
+++ /dev/null
@@ -1,54 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBConsolePageUi</class>
- <widget class="QFrame" name="OpenRGBConsolePageUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>1328</width>
-    <height>915</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Log console page</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="1" column="0">
-    <widget class="QLabel" name="label">
-     <property name="text">
-      <string>Log level</string>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="1">
-    <widget class="QComboBox" name="log_level"/>
-   </item>
-   <item row="1" column="2">
-    <widget class="QPushButton" name="refresh">
-     <property name="text">
-      <string>Refresh logs</string>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="3">
-    <widget class="QPushButton" name="clear">
-     <property name="text">
-      <string>Clear log</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="0" colspan="4">
-    <widget class="QTextEdit" name="logs">
-     <property name="font">
-      <font>
-       <family>Monospace</family>
-      </font>
-     </property>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBDeviceInfoPage/OpenRGBDeviceInfoPage.cpp b/qt/OpenRGBDeviceInfoPage/OpenRGBDeviceInfoPage.cpp
deleted file mode 100644
index 0d213b2b..00000000
--- a/qt/OpenRGBDeviceInfoPage/OpenRGBDeviceInfoPage.cpp
+++ /dev/null
@@ -1,48 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBDeviceInfoPage.cpp                                 |
-|                                                           |
-|   User interface for OpenRGB device information page      |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBDeviceInfoPage.h"
-
-using namespace Ui;
-
-OpenRGBDeviceInfoPage::OpenRGBDeviceInfoPage(RGBController *dev, QWidget *parent) :
-    QFrame(parent),
-    ui(new Ui::OpenRGBDeviceInfoPageUi)
-{
-    controller = dev;
-
-    ui->setupUi(this);
-
-    ui->TypeValue->setText(device_type_to_str(dev->type).c_str());
-
-    ui->NameValue->setText(QString::fromStdString(dev->name));
-    ui->VendorValue->setText(QString::fromStdString(dev->vendor));
-    ui->DescriptionValue->setText(QString::fromStdString(dev->description));
-    ui->VersionValue->setText(QString::fromStdString(dev->version));
-    ui->LocationValue->setText(QString::fromStdString(dev->location));
-    ui->SerialValue->setText(QString::fromStdString(dev->serial));
-}
-
-OpenRGBDeviceInfoPage::~OpenRGBDeviceInfoPage()
-{
-    delete ui;
-}
-
-void OpenRGBDeviceInfoPage::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-RGBController* OpenRGBDeviceInfoPage::GetController()
-{
-    return controller;
-}
diff --git a/qt/OpenRGBDeviceInfoPage/OpenRGBDeviceInfoPage.h b/qt/OpenRGBDeviceInfoPage/OpenRGBDeviceInfoPage.h
deleted file mode 100644
index 365c92eb..00000000
--- a/qt/OpenRGBDeviceInfoPage/OpenRGBDeviceInfoPage.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBDeviceInfoPage.h                                   |
-|                                                           |
-|   User interface for OpenRGB device information page      |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QFrame>
-#include "RGBController.h"
-#include "ui_OpenRGBDeviceInfoPage.h"
-
-namespace Ui
-{
-    class OpenRGBDeviceInfoPage;
-}
-
-class Ui::OpenRGBDeviceInfoPage : public QFrame
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBDeviceInfoPage(RGBController *dev, QWidget *parent = nullptr);
-    ~OpenRGBDeviceInfoPage();
-
-    RGBController* GetController();
-
-private:
-    RGBController*                  controller;
-    Ui::OpenRGBDeviceInfoPageUi*    ui;
-
-private slots:
-    void changeEvent(QEvent *event);
-};
diff --git a/qt/OpenRGBDeviceInfoPage/OpenRGBDeviceInfoPage.ui b/qt/OpenRGBDeviceInfoPage/OpenRGBDeviceInfoPage.ui
deleted file mode 100644
index adbfdac8..00000000
--- a/qt/OpenRGBDeviceInfoPage/OpenRGBDeviceInfoPage.ui
+++ /dev/null
@@ -1,164 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBDeviceInfoPageUi</class>
- <widget class="QFrame" name="OpenRGBDeviceInfoPageUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>500</width>
-    <height>300</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Device info page</string>
-  </property>
-  <property name="autoFillBackground">
-   <bool>false</bool>
-  </property>
-  <property name="frameShape">
-   <enum>QFrame::NoFrame</enum>
-  </property>
-  <property name="frameShadow">
-   <enum>QFrame::Sunken</enum>
-  </property>
-  <layout class="QGridLayout" name="gridLayout" columnstretch="0">
-   <item row="0" column="0">
-    <widget class="QFrame" name="DeviceInfoFrame">
-     <property name="autoFillBackground">
-      <bool>true</bool>
-     </property>
-     <property name="frameShape">
-      <enum>QFrame::StyledPanel</enum>
-     </property>
-     <property name="frameShadow">
-      <enum>QFrame::Sunken</enum>
-     </property>
-     <layout class="QGridLayout" name="gridLayout_2" columnstretch="0,1">
-      <item row="4" column="1">
-       <widget class="QLabel" name="VersionValue">
-        <property name="text">
-         <string notr="true">Version Value</string>
-        </property>
-        <property name="wordWrap">
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
-      <item row="6" column="0">
-       <widget class="QLabel" name="SerialLabel">
-        <property name="text">
-         <string>Serial:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="6" column="1">
-       <widget class="QLabel" name="SerialValue">
-        <property name="text">
-         <string notr="true">Serial Value</string>
-        </property>
-        <property name="wordWrap">
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
-      <item row="0" column="0">
-       <widget class="QLabel" name="NameLabel">
-        <property name="text">
-         <string>Name:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="0" column="1">
-       <widget class="QLabel" name="NameValue">
-        <property name="text">
-         <string notr="true">Name Value</string>
-        </property>
-        <property name="wordWrap">
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="0">
-       <widget class="QLabel" name="VendorLabel">
-        <property name="text">
-         <string>Vendor:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="1">
-       <widget class="QLabel" name="VendorValue">
-        <property name="text">
-         <string notr="true">Vendor Value</string>
-        </property>
-        <property name="wordWrap">
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
-      <item row="2" column="0">
-       <widget class="QLabel" name="TypeLabel">
-        <property name="text">
-         <string>Type:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="2" column="1">
-       <widget class="QLabel" name="TypeValue">
-        <property name="text">
-         <string notr="true">Type Value</string>
-        </property>
-        <property name="wordWrap">
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
-      <item row="3" column="1">
-       <widget class="QLabel" name="DescriptionValue">
-        <property name="text">
-         <string notr="true">Description Value</string>
-        </property>
-        <property name="wordWrap">
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
-      <item row="3" column="0">
-       <widget class="QLabel" name="DescriptionLabel">
-        <property name="text">
-         <string>Description:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="4" column="0">
-       <widget class="QLabel" name="VersionLabel">
-        <property name="text">
-         <string>Version:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="0">
-       <widget class="QLabel" name="LocationLabel">
-        <property name="text">
-         <string>Location:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="1">
-       <widget class="QLabel" name="LocationValue">
-        <property name="text">
-         <string notr="true">Location Value</string>
-        </property>
-        <property name="wordWrap">
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
-     </layout>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBDevicePage/OpenRGBDevicePage.cpp b/qt/OpenRGBDevicePage/OpenRGBDevicePage.cpp
deleted file mode 100644
index 09b7cb92..00000000
--- a/qt/OpenRGBDevicePage/OpenRGBDevicePage.cpp
+++ /dev/null
@@ -1,1876 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBDevicePage.cpp                                     |
-|                                                           |
-|   User interface for OpenRGB device page                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBDialog2.h"
-#include "OpenRGBDevicePage.h"
-#include "OpenRGBZoneResizeDialog.h"
-#include "ResourceManager.h"
-#include "SettingsManager.h"
-#include "hsv.h"
-
-using namespace Ui;
-
-static void UpdateCallback(void * this_ptr)
-{
-    OpenRGBDevicePage * this_obj = (OpenRGBDevicePage *)this_ptr;
-
-    QMetaObject::invokeMethod(this_obj, "UpdateInterface", Qt::QueuedConnection);
-}
-
-QString OpenRGBDevicePage::ModeDescription(const mode& m)
-{
-    /*-----------------------------------------------------------------*\
-    | List of common mode names can be found on the OpenRGB Wiki:       |
-    | https://gitlab.com/CalcProgrammer1/OpenRGB/-/wikis/Common-Modes   |
-    \*-----------------------------------------------------------------*/
-    static const std::unordered_map<std::string, QString> descriptions =
-    {
-        {"Direct",          tr("Set individual LEDs to static colors.  Safe for use with software-driven effects.")                     },
-        {"Custom",          tr("Set individual LEDs to static colors.  Not safe for use with software-driven effects.")                 },
-        {"Static",          tr("Sets the entire device or a zone to a single color.")                                                   },
-        {"Breathing",       tr("Gradually fades between fully off and fully on.")                                                       },
-        {"Flashing",        tr("Abruptly changes between fully off and fully on.")                                                      },
-        {"Spectrum Cycle",  tr("Gradually cycles through the entire color spectrum.  All lights on the device are the same color.")     },
-        {"Rainbow Wave",    tr("Gradually cycles through the entire color spectrum.  Produces a rainbow pattern that moves.")           },
-        {"Reactive",        tr("Flashes lights when keys or buttons are pressed.")                                                      },
-    };
-
-    /*-----------------------------------------------------------------*\
-    | Find the given mode name in the list and return the description   |
-    | if it exists, otherwise return an empty string                    |
-    \*-----------------------------------------------------------------*/
-    std::unordered_map<std::string, QString>::const_iterator it = descriptions.find(m.name);
-
-    if(it != descriptions.end())
-    {
-        return it->second;
-    }
-
-    return "";
-}
-
-OpenRGBDevicePage::OpenRGBDevicePage(RGBController *dev, QWidget *parent) :
-    QFrame(parent),
-    ui(new Ui::OpenRGBDevicePageUi)
-{
-    ui->setupUi(this);
-
-    /*-----------------------------------------------------*\
-    | Store device pointer                                  |
-    \*-----------------------------------------------------*/
-    device = dev;
-
-    /*-----------------------------------------------------*\
-    | Register update callback with the device              |
-    \*-----------------------------------------------------*/
-    device->RegisterUpdateCallback(UpdateCallback, this);
-
-    /*-----------------------------------------------------*\
-    | Set up the device view                                |
-    \*-----------------------------------------------------*/
-    connect(ui->DeviceViewBox, &DeviceView::selectionChanged, this, &OpenRGBDevicePage::on_DeviceViewBox_selectionChanged);
-
-    /*-----------------------------------------------------*\
-    | Get the UserInterface settings and check the          |
-    | numerical labels and hex format settings              |
-    \*-----------------------------------------------------*/
-    SettingsManager*    settings_manager    = ResourceManager::get()->GetSettingsManager();
-    std::string         ui_string           = "UserInterface";
-    json                ui_settings;
-
-    ui_settings = settings_manager->GetSettings(ui_string);
-
-    if(ui_settings.contains("numerical_labels"))
-    {
-        bool            numerical_labels    = ui_settings["numerical_labels"];
-
-        ui->DeviceViewBox->setNumericalLabels(numerical_labels);
-    }
-
-    if(ui_settings.contains("hex_format"))
-    {
-        if(ui_settings["hex_format"] == "RGB")
-        {
-            HexFormatRGB = true;
-        }
-        else if(ui_settings["hex_format"] == "BGR")
-        {
-            HexFormatRGB = false;
-        }
-    }
-
-    ui->DeviceViewBox->setController(device);
-    ui->DeviceViewBoxFrame->hide();
-
-    /*-----------------------------------------------------*\
-    | Fill in the mode selection box                        |
-    \*-----------------------------------------------------*/
-    ui->ModeBox->blockSignals(true);
-    ui->ModeBox->clear();
-
-    for(std::size_t i = 0; i < device->modes.size(); i++)
-    {
-        ui->ModeBox->addItem(device->modes[i].name.c_str());
-        ui->ModeBox->setItemData((int)i, ModeDescription(device->modes[i]), Qt::ToolTipRole);
-    }
-
-    ui->ModeBox->setCurrentIndex(device->GetMode());
-    ui->ModeBox->blockSignals(false);
-
-    /*-----------------------------------------------------*\
-    | Update mode user interface elements                   |
-    \*-----------------------------------------------------*/
-    UpdateModeUi();
-
-    /*-----------------------------------------------------*\
-    | Set initial color to black and update UI              |
-    \*-----------------------------------------------------*/
-    current_color.setRgb(0, 0, 0);
-    updateColorUi();
-
-    ui->ApplyColorsButton->setDisabled(autoUpdateEnabled());
-    ui->SetAllButton->setDisabled(device->modes[0].name != "Direct" && device->modes[0].name != "Custom" && device->modes[0].name != "Static");
-}
-
-OpenRGBDevicePage::~OpenRGBDevicePage()
-{
-    /*-----------------------------------------------------*\
-    | Unregister update callback from the controller if the |
-    | controller still exists                               |
-    \*-----------------------------------------------------*/
-    for(unsigned int controller_idx = 0; controller_idx < ResourceManager::get()->GetRGBControllers().size(); controller_idx++)
-    {
-        if(ResourceManager::get()->GetRGBControllers()[controller_idx] == device)
-        {
-            device->UnregisterUpdateCallback(this);
-            break;
-        }
-    }
-
-    delete ui;
-}
-
-void OpenRGBDevicePage::changeEvent(QEvent *event)
-{
-    /*-----------------------------------------------------*\
-    | Retranslate the UI when a language change event occurs|
-    \*-----------------------------------------------------*/
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-RGBController* Ui::OpenRGBDevicePage::GetController()
-{
-    return device;
-}
-
-void Ui::OpenRGBDevicePage::on_ZoneBox_currentIndexChanged(int index)
-{
-    /*-----------------------------------------------------*\
-    | Read selected mode                                    |
-    \*-----------------------------------------------------*/
-    unsigned int selected_mode   = (unsigned int)ui->ModeBox->currentIndex();
-
-    /*-----------------------------------------------------*\
-    | Process zone box change based on color mode           |
-    \*-----------------------------------------------------*/
-    switch(device->modes[selected_mode].color_mode)
-    {
-        case MODE_COLORS_PER_LED:
-            {
-                /*-----------------------------------------*\
-                | Initialize both selected zone and segment |
-                | to -1 to indicate there is no selection   |
-                \*-----------------------------------------*/
-                unsigned int    current_index       = 0;
-                bool            selected_all_zones  = false;
-                int             selected_zone       = -1;
-                int             selected_segment    = -1;
-
-                /*-----------------------------------------*\
-                | Handle condition where device has more    |
-                | than one zone, which adds an "All Zones"  |
-                | entry to the Zone menu in the first index |
-                \*-----------------------------------------*/
-                if(device->zones.size() > 1)
-                {
-                    if(index == (int)current_index)
-                    {
-                        selected_all_zones = true;
-                    }
-
-                    current_index++;
-                }
-
-                /*-----------------------------------------*\
-                | Determine selected zone and optionally    |
-                | selected segment based on index if "All   |
-                | Zones" is not the selected index          |
-                \*-----------------------------------------*/
-                if(!selected_all_zones)
-                {
-                    for(std::size_t zone_idx = 0; zone_idx < device->zones.size(); zone_idx++)
-                    {
-                        if(index == (int)current_index)
-                        {
-                            selected_zone = (int)zone_idx;
-                            break;
-                        }
-
-                        current_index++;
-
-                        for(std::size_t segment_idx = 0; segment_idx < device->zones[zone_idx].segments.size(); segment_idx++)
-                        {
-                            if(index == (int)current_index)
-                            {
-                                selected_zone    = (int)zone_idx;
-                                selected_segment = (int)segment_idx;
-                                break;
-                            }
-
-                            current_index++;
-                        }
-
-                        if(selected_segment != -1)
-                        {
-                            break;
-                        }
-                    }
-                }
-
-                /*-----------------------------------------*\
-                | Clear LED box                             |
-                \*-----------------------------------------*/
-                ui->LEDBox->blockSignals(true);
-                ui->LEDBox->clear();
-
-                /*-----------------------------------------*\
-                | Clear multiple selected flag              |
-                \*-----------------------------------------*/
-                MultipleSelected = false;
-
-                /*-----------------------------------------*\
-                | Handle "All Zones" selected condition or  |
-                | multiple selection condition              |
-                \*-----------------------------------------*/
-                if(selected_all_zones)
-                {
-                    /*-------------------------------------*\
-                    | If there are multiple LEDs, add the   |
-                    | "Entire Device" option to the LED box |
-                    | and enable it, otherwise there is     |
-                    | only one LED so disable it            |
-                    \*-------------------------------------*/
-                    if(device->leds.size() > 1)
-                    {
-                        ui->LEDBox->addItem(tr("Entire Device"));
-                        ui->LEDBox->setEnabled(1);
-                    }
-                    else
-                    {
-                        ui->LEDBox->setDisabled(1);
-                    }
-
-                    /*-------------------------------------*\
-                    | Fill in the LED list with all LEDs in |
-                    | the device                            |
-                    \*-------------------------------------*/
-                    for(std::size_t i = 0; i < device->leds.size(); i++)
-                    {
-                        ui->LEDBox->addItem(device->leds[i].name.c_str());
-                    }
-
-                    /*-------------------------------------*\
-                    | Editing is not allowed when all       |
-                    | zones are selected at once            |
-                    \*-------------------------------------*/
-                    ui->EditZoneButton->setEnabled(false);
-
-                    if(!ui->ZoneBox->signalsBlocked())
-                    {
-                        ui->DeviceViewBox->blockSignals(true);
-                        ui->DeviceViewBox->clearSelection();
-                        ui->DeviceViewBox->blockSignals(false);
-                    }
-                }
-
-                /*-----------------------------------------*\
-                | Handle a zone selected condition          |
-                \*-----------------------------------------*/
-                else if(selected_zone != -1 && selected_segment == -1)
-                {
-                    /*-------------------------------------*\
-                    | If there are multiple LEDs, add the   |
-                    | "Entire Zone" option to the LED box   |
-                    | and enable it, otherwise there is     |
-                    | only one LED so disable it            |
-                    \*-------------------------------------*/
-                    if(device->zones[selected_zone].leds_count > 1)
-                    {
-                        ui->LEDBox->addItem(tr("Entire Zone"));
-                        ui->LEDBox->setEnabled(1);
-                    }
-                    else
-                    {
-                        ui->LEDBox->setDisabled(1);
-                    }
-
-                    /*-------------------------------------*\
-                    | Fill in the LED list with all LEDs in |
-                    | the zone                              |
-                    \*-------------------------------------*/
-                    for(std::size_t led_idx = 0; led_idx < device->zones[selected_zone].leds_count; led_idx++)
-                    {
-                        ui->LEDBox->addItem(device->zones[selected_zone].leds[led_idx].name.c_str());
-                    }
-
-                    /*-------------------------------------*\
-                    | Enable editing if:                    |
-                    |   Zone has variable size              |
-                    | OR                                    |
-                    |   Zone is LINEAR and device type is   |
-                    |   LEDSTRIP                            |
-                    \*-------------------------------------*/
-                    bool zone_is_editable = false;
-
-                    if(device->zones[selected_zone].leds_min != device->zones[selected_zone].leds_max)
-                    {
-                        zone_is_editable = true;
-                    }
-
-                    if((device->zones[selected_zone].type == ZONE_TYPE_LINEAR) && (device->type == DEVICE_TYPE_LEDSTRIP))
-                    {
-                        zone_is_editable = true;
-                    }
-
-                    ui->EditZoneButton->setEnabled(zone_is_editable);
-
-                    if(!ui->ZoneBox->signalsBlocked())
-                    {
-                        ui->DeviceViewBox->blockSignals(true);
-                        ui->DeviceViewBox->selectZone(selected_zone);
-                        ui->DeviceViewBox->blockSignals(false);
-                    }
-                }
-
-                /*-----------------------------------------*\
-                | Handle a segment selected condition       |
-                \*-----------------------------------------*/
-                else if(selected_zone != -1 && selected_segment != -1)
-                {
-                    /*-------------------------------------*\
-                    | If there are multiple LEDs, add the   |
-                    | "Entire Segment" option to the LED    |
-                    | box and enable it, otherwise there is |
-                    | only one LED so disable it            |
-                    \*-------------------------------------*/
-                    if(device->zones[selected_zone].segments[selected_segment].leds_count > 1)
-                    {
-                        ui->LEDBox->addItem(tr("Entire Segment"));
-                        ui->LEDBox->setEnabled(1);
-                    }
-                    else
-                    {
-                        ui->LEDBox->setDisabled(1);
-                    }
-
-                    /*-------------------------------------*\
-                    | Fill in the LED list with all LEDs in |
-                    | the segment                           |
-                    \*-------------------------------------*/
-                    for(std::size_t led_idx = 0; led_idx < device->zones[selected_zone].segments[selected_segment].leds_count; led_idx++)
-                    {
-                        ui->LEDBox->addItem(device->zones[selected_zone].leds[led_idx + device->zones[selected_zone].segments[selected_segment].start_idx].name.c_str());
-                    }
-
-                    /*-------------------------------------*\
-                    | Editing is not allowed when a         |
-                    | segment is selected                   |
-                    \*-------------------------------------*/
-                    ui->EditZoneButton->setEnabled(false);
-
-                    if(!ui->ZoneBox->signalsBlocked())
-                    {
-                        ui->DeviceViewBox->blockSignals(true);
-                        ui->DeviceViewBox->selectSegment(selected_zone, selected_segment);
-                        ui->DeviceViewBox->blockSignals(false);
-                    }
-                }
-
-                ui->LEDBox->setCurrentIndex(0);
-                on_LEDBox_currentIndexChanged(0);
-                ui->LEDBox->blockSignals(false);
-            }
-            break;
-    }
-}
-
-void Ui::OpenRGBDevicePage::on_LEDBox_currentIndexChanged(int index)
-{
-    /*-----------------------------------------------------*\
-    | Read selected mode                                    |
-    \*-----------------------------------------------------*/
-    unsigned int selected_mode   = (unsigned int)ui->ModeBox->currentIndex();
-
-    /*-----------------------------------------------------*\
-    | Process zone box change based on color mode           |
-    \*-----------------------------------------------------*/
-    switch(device->modes[selected_mode].color_mode)
-    {
-        case MODE_COLORS_PER_LED:
-            {
-                /*-----------------------------------------*\
-                | Initialize both selected zone and segment |
-                | to -1 to indicate there is no selection   |
-                \*-----------------------------------------*/
-                unsigned int    current_index       = 0;
-                bool            selected_all_zones  = false;
-                bool            selected_all_leds   = false;
-                int             selected_led        = -1;
-                int             selected_zone       = -1;
-                int             selected_segment    = -1;
-
-                /*-----------------------------------------*\
-                | Handle condition where device has more    |
-                | than one zone, which adds an "All Zones"  |
-                | entry to the Zone menu in the first index |
-                \*-----------------------------------------*/
-                if(device->zones.size() > 1)
-                {
-                    if(ui->ZoneBox->currentIndex() == (int)current_index)
-                    {
-                        selected_all_zones = true;
-                    }
-
-                    current_index++;
-                }
-
-                /*-----------------------------------------*\
-                | Determine selected zone and optionally    |
-                | selected segment based on index if "All   |
-                | Zones" is not the selected index          |
-                \*-----------------------------------------*/
-                if(!selected_all_zones)
-                {
-                    for(std::size_t zone_idx = 0; zone_idx < device->zones.size(); zone_idx++)
-                    {
-                        if(ui->ZoneBox->currentIndex() == (int)current_index)
-                        {
-                            selected_zone = (int)zone_idx;
-                            break;
-                        }
-
-                        current_index++;
-
-                        for(std::size_t segment_idx = 0; segment_idx < device->zones[zone_idx].segments.size(); segment_idx++)
-                        {
-                            if(ui->ZoneBox->currentIndex() == (int)current_index)
-                            {
-                                selected_zone    = (int)zone_idx;
-                                selected_segment = (int)segment_idx;
-                                break;
-                            }
-
-                            current_index++;
-                        }
-
-                        if(selected_segment != -1)
-                        {
-                            break;
-                        }
-                    }
-                }
-
-                /*-----------------------------------------*\
-                | Handle selection of "Entire Device/Zone/  |
-                | Segment" index is selected                |
-                |                                           |
-                | There should always be an Entire index as |
-                | long as the LED box is enabled            |
-                \*-----------------------------------------*/
-                if(index == 0)
-                {
-                    selected_all_leds = true;
-                }
-                /*-----------------------------------------*\
-                | Determine selected LED if "Entire Device/ |
-                | Zone/Segment" is not selected             |
-                \*-----------------------------------------*/
-                else
-                {
-                    selected_led = index - 1;
-                }
-
-                /*-----------------------------------------*\
-                | Initialize variables                      |
-                \*-----------------------------------------*/
-                bool        multiple    = (std::size_t(selected_led) == (device->leds.size() + 1));
-                RGBColor    color       = 0x00000000;
-                bool        updateColor = false;
-
-                /*-----------------------------------------*\
-                | Remove multiple selection                 |
-                \*-----------------------------------------*/
-                if(MultipleSelected)
-                {
-                    ui->LEDBox->removeItem((int)(device->leds.size() + 1));
-                }
-
-                MultipleSelected = false;
-
-                /*-----------------------------------------*\
-                | Handle "All Zones" selected condition     |
-                \*-----------------------------------------*/
-                if(selected_all_zones)
-                {
-                    /*-------------------------------------*\
-                    | Handle Entire Device selection        |
-                    \*-------------------------------------*/
-                    if(selected_all_leds)
-                    {
-                        if(!ui->LEDBox->signalsBlocked())
-                        {
-                            ui->DeviceViewBox->blockSignals(true);
-                            ui->DeviceViewBox->clearSelection();
-                            ui->DeviceViewBox->blockSignals(false);
-                        }
-                    }
-
-                    /*-------------------------------------*\
-                    | Handle single selected LED            |
-                    \*-------------------------------------*/
-                    if((device->leds.size() == 1 || selected_led != -1) && !multiple)
-                    {
-                        /*---------------------------------*\
-                        | Get selected LED's current color  |
-                        \*---------------------------------*/
-                        color = device->GetLED(selected_led);
-
-                        /*---------------------------------*\
-                        | Set update color flag             |
-                        \*---------------------------------*/
-                        updateColor = true;
-
-                        /*---------------------------------*\
-                        | Select LED in device view         |
-                        \*---------------------------------*/
-                        if(!ui->LEDBox->signalsBlocked())
-                        {
-                            ui->DeviceViewBox->blockSignals(true);
-                            ui->DeviceViewBox->selectLed(selected_led);
-                            ui->DeviceViewBox->blockSignals(false);
-                        }
-                    }
-                }
-                /*-----------------------------------------*\
-                | Handle a zone selected condition          |
-                \*-----------------------------------------*/
-                else if(selected_zone != -1 && selected_segment == -1)
-                {
-                    /*-------------------------------------*\
-                    | Handle Entire Zone selection          |
-                    \*-------------------------------------*/
-                    if(selected_all_leds)
-                    {
-                        if(!ui->LEDBox->signalsBlocked())
-                        {
-                            ui->DeviceViewBox->blockSignals(true);
-                            ui->DeviceViewBox->selectZone(selected_zone);
-                            ui->DeviceViewBox->blockSignals(false);
-                        }
-                    }
-
-                    /*-------------------------------------*\
-                    | Handle single selected LED            |
-                    \*-------------------------------------*/
-                    if(device->zones[selected_zone].leds_count == 1 || selected_led != -1)
-                    {
-                        if((unsigned int)selected_led < device->zones[selected_zone].leds_count)
-                        {
-                            /*-----------------------------*\
-                            | Get selected LED's current    |
-                            | color                         |
-                            \*-----------------------------*/
-                            color = device->zones[selected_zone].colors[selected_led];
-
-                            /*-----------------------------*\
-                            | Set update color flag         |
-                            \*-----------------------------*/
-                            updateColor = 1;
-
-                            /*-----------------------------*\
-                            | Set global index              |
-                            \*-----------------------------*/
-                            int globalIndex = device->zones[selected_zone].leds - &(device->leds[0]) + selected_led;
-
-                            /*-----------------------------*\
-                            | Select LED in device view     |
-                            \*-----------------------------*/
-                            if(!ui->LEDBox->signalsBlocked())
-                            {
-                                ui->DeviceViewBox->blockSignals(true);
-                                ui->DeviceViewBox->selectLed(globalIndex);
-                                ui->DeviceViewBox->blockSignals(false);
-                            }
-                        }
-                    }
-                }
-                /*-----------------------------------------*\
-                | Handle a segment selected condition       |
-                \*-----------------------------------------*/
-                else if(selected_zone != -1 && selected_segment != -1)
-                {
-                    /*-------------------------------------*\
-                    | Handle Entire Zone selection          |
-                    \*-------------------------------------*/
-                    if(selected_all_leds)
-                    {
-                        if(!ui->LEDBox->signalsBlocked())
-                        {
-                            ui->DeviceViewBox->blockSignals(true);
-                            ui->DeviceViewBox->selectSegment(selected_zone, selected_segment);
-                            ui->DeviceViewBox->blockSignals(false);
-                        }
-                    }
-
-                    /*-------------------------------------*\
-                    | Handle single selected LED            |
-                    \*-------------------------------------*/
-                    if(device->zones[selected_zone].segments[selected_segment].leds_count == 1 || selected_led != -1)
-                    {
-                        if((unsigned int)selected_led < device->zones[selected_zone].segments[selected_segment].leds_count)
-                        {
-                            /*-----------------------------*\
-                            | Get selected LED's current    |
-                            | color                         |
-                            \*-----------------------------*/
-                            color = device->zones[selected_zone].colors[selected_led + device->zones[selected_zone].segments[selected_segment].start_idx];
-
-                            /*-----------------------------*\
-                            | Set update color flag         |
-                            \*-----------------------------*/
-                            updateColor = 1;
-
-                            /*-----------------------------*\
-                            | Set global index              |
-                            \*-----------------------------*/
-                            int globalIndex = device->zones[selected_zone].leds - &(device->leds[0]) + selected_led + device->zones[selected_zone].segments[selected_segment].start_idx;
-
-                            /*-----------------------------*\
-                            | Select LED in device view     |
-                            \*-----------------------------*/
-                            if(!ui->LEDBox->signalsBlocked())
-                            {
-                                ui->DeviceViewBox->blockSignals(true);
-                                ui->DeviceViewBox->selectLed(globalIndex);
-                                ui->DeviceViewBox->blockSignals(false);
-                            }
-                        }
-                    }
-                }
-
-                /*-----------------------------------------------------*\
-                | Update color picker with color of selected LED        |
-                \*-----------------------------------------------------*/
-                if(updateColor)
-                {
-                    current_color.setRgb(RGBGetRValue(color), RGBGetGValue(color), RGBGetBValue(color));
-
-                    updateColorUi();
-                }
-            }
-            break;
-
-        case MODE_COLORS_MODE_SPECIFIC:
-            {
-                /*-----------------------------------------------------*\
-                | Update color picker with color of selected mode       |
-                \*-----------------------------------------------------*/
-                RGBColor color = device->modes[selected_mode].colors[index];
-
-                current_color.setRgb(RGBGetRValue(color), RGBGetGValue(color), RGBGetBValue(color));
-
-                updateColorUi();
-            }
-            break;
-    }
-
-}
-
-void Ui::OpenRGBDevicePage::on_ModeBox_currentIndexChanged(int index)
-{
-    /*-----------------------------------------------------*\
-    | Update mode user interface elements                   |
-    \*-----------------------------------------------------*/
-    UpdateModeUi();
-
-    /*-----------------------------------------------------*\
-    | Change device mode                                    |
-    \*-----------------------------------------------------*/
-    UpdateMode();
-
-    /*-----------------------------------------------------*\
-    | Disable the button if we can safely auto apply colors |
-    \*-----------------------------------------------------*/
-    ui->ApplyColorsButton->setDisabled(autoUpdateEnabled());
-    ui->SetAllButton->setDisabled(device->modes[index].name != "Direct" && device->modes[index].name != "Custom" && device->modes[index].name != "Static");
-
-}
-
-void Ui::OpenRGBDevicePage::on_PerLEDCheck_clicked()
-{
-    /*-----------------------------------------------------*\
-    | Change device mode                                    |
-    \*-----------------------------------------------------*/
-    UpdateMode();
-
-    /*-----------------------------------------------------*\
-    | Update mode user interface elements                   |
-    \*-----------------------------------------------------*/
-    UpdateModeUi();
-}
-
-void Ui::OpenRGBDevicePage::on_ModeSpecificCheck_clicked()
-{
-    /*-----------------------------------------------------*\
-    | Change device mode                                    |
-    \*-----------------------------------------------------*/
-    UpdateMode();
-
-    /*-----------------------------------------------------*\
-    | Update mode user interface elements                   |
-    \*-----------------------------------------------------*/
-    UpdateModeUi();
-}
-
-void Ui::OpenRGBDevicePage::on_RandomCheck_clicked()
-{
-    /*-----------------------------------------------------*\
-    | Change device mode                                    |
-    \*-----------------------------------------------------*/
-    UpdateMode();
-
-    /*-----------------------------------------------------*\
-    | Update mode user interface elements                   |
-    \*-----------------------------------------------------*/
-    UpdateModeUi();
-}
-
-void Ui::OpenRGBDevicePage::on_BrightnessSlider_valueChanged(int /*value*/)
-{
-    /*-----------------------------------------------------*\
-    | Change device mode                                    |
-    \*-----------------------------------------------------*/
-    UpdateMode();
-}
-
-void Ui::OpenRGBDevicePage::on_SpeedSlider_valueChanged(int /*value*/)
-{
-    /*-----------------------------------------------------*\
-    | Change device mode                                    |
-    \*-----------------------------------------------------*/
-    UpdateMode();
-}
-
-void Ui::OpenRGBDevicePage::on_DirectionBox_currentIndexChanged(int /*index*/)
-{
-    /*-----------------------------------------------------*\
-    | Change device mode                                    |
-    \*-----------------------------------------------------*/
-    UpdateMode();
-}
-
-void Ui::OpenRGBDevicePage::UpdateInterface()
-{
-    //UpdateModeUi();
-    ui->DeviceViewBox->repaint();
-}
-
-void Ui::OpenRGBDevicePage::UpdateModeUi()
-{
-    /*-----------------------------------------------------*\
-    | Read selected mode                                    |
-    \*-----------------------------------------------------*/
-    unsigned int selected_mode   = (unsigned int)ui->ModeBox->currentIndex();
-
-    /*-----------------------------------------------------*\
-    | Don't update the UI if the current mode is invalid    |
-    \*-----------------------------------------------------*/
-    if(selected_mode < device->modes.size())
-    {
-        bool supports_per_led       = ( device->modes[selected_mode].flags & MODE_FLAG_HAS_PER_LED_COLOR );
-        bool supports_mode_specific = ( device->modes[selected_mode].flags & MODE_FLAG_HAS_MODE_SPECIFIC_COLOR );
-        bool supports_random        = ( device->modes[selected_mode].flags & MODE_FLAG_HAS_RANDOM_COLOR );
-        bool supports_speed         = ( device->modes[selected_mode].flags & MODE_FLAG_HAS_SPEED );
-        bool supports_brightness    = ( device->modes[selected_mode].flags & MODE_FLAG_HAS_BRIGHTNESS);
-        bool supports_dir_lr        = ( device->modes[selected_mode].flags & MODE_FLAG_HAS_DIRECTION_LR );
-        bool supports_dir_ud        = ( device->modes[selected_mode].flags & MODE_FLAG_HAS_DIRECTION_UD );
-        bool supports_dir_hv        = ( device->modes[selected_mode].flags & MODE_FLAG_HAS_DIRECTION_HV );
-        bool per_led                = device->modes[selected_mode].color_mode == MODE_COLORS_PER_LED;
-        bool mode_specific          = device->modes[selected_mode].color_mode == MODE_COLORS_MODE_SPECIFIC;
-        bool random                 = device->modes[selected_mode].color_mode == MODE_COLORS_RANDOM;
-        unsigned int dir            = device->modes[selected_mode].direction;
-        bool manual_save            = ( device->modes[selected_mode].flags & MODE_FLAG_MANUAL_SAVE );
-        bool automatic_save         = ( device->modes[selected_mode].flags & MODE_FLAG_AUTOMATIC_SAVE );
-
-        if(supports_speed)
-        {
-            ui->SpeedSlider->blockSignals(true);
-            int  current_speed;
-            InvertedSpeed = device->modes[selected_mode].speed_min > device->modes[selected_mode].speed_max;
-
-            if(InvertedSpeed)
-            {
-                /*-----------------------------------------------------*\
-                | If Speed Slider is inverted, invert value             |
-                \*-----------------------------------------------------*/
-                ui->SpeedSlider->setMinimum(device->modes[selected_mode].speed_max);
-                ui->SpeedSlider->setMaximum(device->modes[selected_mode].speed_min);
-                current_speed = device->modes[selected_mode].speed_min - device->modes[selected_mode].speed + device->modes[selected_mode].speed_max;
-            }
-            else
-            {
-                ui->SpeedSlider->setMinimum(device->modes[selected_mode].speed_min);
-                ui->SpeedSlider->setMaximum(device->modes[selected_mode].speed_max);
-                current_speed = device->modes[selected_mode].speed;
-            }
-
-            ui->SpeedSlider->setValue(current_speed);
-            ui->SpeedSlider->setEnabled(true);
-            ui->SpeedSlider->blockSignals(false);
-        }
-        else
-        {
-            ui->SpeedSlider->blockSignals(true);
-            ui->SpeedSlider->setEnabled(false);
-            ui->SpeedSlider->blockSignals(false);
-        }
-
-        if(supports_brightness)
-        {
-            ui->BrightnessSlider->blockSignals(true);
-            int current_brightness;
-            InvertedBrightness = device->modes[selected_mode].brightness_min > device->modes[selected_mode].brightness_max;
-
-            if(InvertedBrightness)
-            {
-                /*-----------------------------------------------------*\
-                | If Brightness Slider is inverted, invert value        |
-                \*-----------------------------------------------------*/
-                ui->BrightnessSlider->setMinimum(device->modes[selected_mode].brightness_max);
-                ui->BrightnessSlider->setMaximum(device->modes[selected_mode].brightness_min);
-                current_brightness = device->modes[selected_mode].brightness_min - device->modes[selected_mode].brightness + device->modes[selected_mode].brightness_max;
-            }
-            else
-            {
-                ui->BrightnessSlider->setMinimum(device->modes[selected_mode].brightness_min);
-                ui->BrightnessSlider->setMaximum(device->modes[selected_mode].brightness_max);
-                current_brightness = device->modes[selected_mode].brightness;
-            }
-
-            ui->BrightnessSlider->setValue(current_brightness);
-            ui->BrightnessSlider->setEnabled(true);
-            ui->BrightnessSlider->blockSignals(false);
-        }
-        else
-        {
-            ui->BrightnessSlider->blockSignals(true);
-            ui->BrightnessSlider->setEnabled(false);
-            ui->BrightnessSlider->blockSignals(false);
-        }
-
-        ui->DirectionBox->blockSignals(true);
-        ui->DirectionBox->clear();
-
-        if(supports_dir_lr)
-        {
-            ui->DirectionBox->addItem(tr("Left"));
-            ui->DirectionBox->addItem(tr("Right"));
-        }
-
-        if(supports_dir_ud)
-        {
-            ui->DirectionBox->addItem(tr("Up"));
-            ui->DirectionBox->addItem(tr("Down"));
-        }
-
-        if(supports_dir_hv)
-        {
-            ui->DirectionBox->addItem(tr("Horizontal"));
-            ui->DirectionBox->addItem(tr("Vertical"));
-        }
-
-        if(supports_dir_lr || supports_dir_ud || supports_dir_hv)
-        {
-            if((supports_dir_lr)
-             &&((dir == MODE_DIRECTION_LEFT)
-              ||(dir == MODE_DIRECTION_RIGHT)))
-            {
-                ui->DirectionBox->setCurrentIndex(dir);
-            }
-
-            if((supports_dir_ud)
-             &&((dir == MODE_DIRECTION_UP)
-              ||(dir == MODE_DIRECTION_DOWN)))
-            {
-                if(supports_dir_lr)
-                {
-                    ui->DirectionBox->setCurrentIndex(dir);
-                }
-                else
-                {
-                    ui->DirectionBox->setCurrentIndex(dir - 2);
-                }
-            }
-
-            if((supports_dir_hv)
-             &&((dir == MODE_DIRECTION_HORIZONTAL)
-              ||(dir == MODE_DIRECTION_VERTICAL)))
-            {
-                if(supports_dir_lr && supports_dir_ud)
-                {
-                    ui->DirectionBox->setCurrentIndex(dir);
-                }
-                else if(supports_dir_lr || supports_dir_ud)
-                {
-                    ui->DirectionBox->setCurrentIndex(dir - 2);
-                }
-                else
-                {
-                    ui->DirectionBox->setCurrentIndex(dir - 4);
-                }
-            }
-
-            ui->DirectionBox->setEnabled(true);
-        }
-        else
-        {
-            ui->DirectionBox->setEnabled(false);
-        }
-
-        ui->DirectionBox->blockSignals(false);
-
-        if(supports_per_led)
-        {
-            ui->PerLEDCheck->setEnabled(true);
-            ui->PerLEDCheck->setChecked(per_led);
-
-            if(DeviceViewShowing)
-            {
-                ui->DeviceViewBoxFrame->show();
-            }
-        }
-        else
-        {
-            ui->PerLEDCheck->setEnabled(false);
-            ui->PerLEDCheck->setAutoExclusive(false);
-            ui->PerLEDCheck->setChecked(false);
-            ui->PerLEDCheck->setAutoExclusive(true);
-            ui->DeviceViewBoxFrame->hide();
-        }
-
-        if(supports_mode_specific)
-        {
-            ui->ModeSpecificCheck->setEnabled(true);
-            ui->ModeSpecificCheck->setChecked(mode_specific);
-        }
-        else
-        {
-            ui->ModeSpecificCheck->setEnabled(false);
-            ui->ModeSpecificCheck->setAutoExclusive(false);
-            ui->ModeSpecificCheck->setChecked(false);
-            ui->ModeSpecificCheck->setAutoExclusive(true);
-        }
-
-        if(supports_random)
-        {
-            ui->RandomCheck->setEnabled(true);
-            ui->RandomCheck->setChecked(random);
-        }
-        else
-        {
-            ui->RandomCheck->setEnabled(false);
-            ui->RandomCheck->setAutoExclusive(false);
-            ui->RandomCheck->setChecked(false);
-            ui->RandomCheck->setAutoExclusive(true);
-        }
-
-        if(automatic_save)
-        {
-            ui->DeviceSaveButton->setText(tr("Saved To Device"));
-            ui->DeviceSaveButton->setEnabled(false);
-        }
-        else if(manual_save)
-        {
-            ui->DeviceSaveButton->setText(tr("Save To Device"));
-            ui->DeviceSaveButton->setEnabled(true);
-        }
-        else
-        {
-            ui->DeviceSaveButton->setText(tr("Saving Not Supported"));
-            ui->DeviceSaveButton->setEnabled(false);
-        }
-
-        /*-----------------------------------------------------*\
-        | Fill in the zone box based on color mode              |
-        \*-----------------------------------------------------*/
-        switch(device->modes[selected_mode].color_mode)
-        {
-            case MODE_COLORS_NONE:
-            case MODE_COLORS_RANDOM:
-                ui->ZoneBox->blockSignals(true);
-                ui->ZoneBox->clear();
-                ui->ZoneBox->blockSignals(false);
-
-                ui->LEDBox->blockSignals(true);
-                ui->LEDBox->clear();
-                ui->LEDBox->blockSignals(false);
-
-                ui->EditZoneButton->setEnabled(false);
-                ui->ApplyColorsButton->setEnabled(false);
-                //ui->AutoFillCheck->setEnabled(false);
-                break;
-
-            case MODE_COLORS_PER_LED:
-                ui->ZoneBox->blockSignals(true);
-                ui->ZoneBox->clear();
-
-                if(device->zones.size() > 1)
-                {
-                    ui->ZoneBox->setEnabled(1);
-                    ui->ZoneBox->addItem(tr("All Zones"));
-                }
-                else if(device->zones.size() == 1 && device->zones[0].segments.size() > 1)
-                {
-                    ui->ZoneBox->setEnabled(1);
-                }
-                else
-                {
-                    ui->ZoneBox->setDisabled(1);
-                    ui->EditZoneButton->setEnabled(false);
-                }
-
-                for(std::size_t zone_idx = 0; zone_idx < device->zones.size(); zone_idx++)
-                {
-                    ui->ZoneBox->addItem(device->zones[zone_idx].name.c_str());
-
-                    for(std::size_t segment_idx = 0; segment_idx < device->zones[zone_idx].segments.size(); segment_idx++)
-                    {
-                        ui->ZoneBox->addItem(("    " + device->zones[zone_idx].segments[segment_idx].name).c_str());
-                    }
-                }
-
-                ui->ZoneBox->setCurrentIndex(0);
-                ui->ZoneBox->blockSignals(false);
-                ui->ApplyColorsButton->setEnabled(true);
-                //ui->AutoFillCheck->setEnabled(true);
-
-                /*-----------------------------------------------------*\
-                | Update LED box                                        |
-                \*-----------------------------------------------------*/
-                on_ZoneBox_currentIndexChanged(0);
-
-                /*-----------------------------------------------------*\
-                | Update color picker with color of first LED           |
-                \*-----------------------------------------------------*/
-                //on_LEDBox_currentIndexChanged(0);
-                break;
-
-            case MODE_COLORS_MODE_SPECIFIC:
-                ui->ZoneBox->blockSignals(true);
-                ui->ZoneBox->clear();
-                ui->ZoneBox->addItem(tr("Mode Specific"));
-                ui->ZoneBox->blockSignals(false);
-
-                ui->LEDBox->blockSignals(true);
-                ui->LEDBox->clear();
-
-                if(device->modes[selected_mode].colors_min == device->modes[selected_mode].colors_max)
-                {
-                    ui->EditZoneButton->setEnabled(false);
-                }
-                else
-                {
-                    ui->EditZoneButton->setEnabled(true);
-                }
-
-                for(unsigned int i = 0; i < device->modes[selected_mode].colors.size(); i++)
-                {
-                    char id_buf[32];
-                    // TODO: translate
-                    snprintf(id_buf, 32, "Mode Color %u", i);
-                    ui->LEDBox->addItem(id_buf);
-                }
-
-                ui->LEDBox->setCurrentIndex(0);
-                on_LEDBox_currentIndexChanged(0);
-                ui->LEDBox->setEnabled(true);
-                ui->LEDBox->blockSignals(false);
-                ui->ApplyColorsButton->setEnabled(true);
-                //ui->AutoFillCheck->setEnabled(true);
-                break;
-        }
-    }
-}
-
-void Ui::OpenRGBDevicePage::UpdateMode()
-{
-    /*-----------------------------------------------------*\
-    | Read selected mode                                    |
-    \*-----------------------------------------------------*/
-    int current_mode = ui->ModeBox->currentIndex();
-
-    if(current_mode >= 0)
-    {
-        int  current_speed          = 0;
-        int  current_brightness     = 0;
-        bool current_per_led        = ui->PerLEDCheck->isChecked();
-        bool current_mode_specific  = ui->ModeSpecificCheck->isChecked();
-        bool current_random         = ui->RandomCheck->isChecked();
-        int  current_dir_idx        = ui->DirectionBox->currentIndex();
-        int  current_direction      = 0;
-        bool supports_dir_lr        = ( device->modes[(unsigned int)current_mode].flags & MODE_FLAG_HAS_DIRECTION_LR );
-        bool supports_dir_ud        = ( device->modes[(unsigned int)current_mode].flags & MODE_FLAG_HAS_DIRECTION_UD );
-        bool supports_dir_hv        = ( device->modes[(unsigned int)current_mode].flags & MODE_FLAG_HAS_DIRECTION_HV );
-
-        /*-----------------------------------------------------*\
-        | If DirectionBox is enabled, set the direction values  |
-        \*-----------------------------------------------------*/
-        if(ui->DirectionBox->isEnabled())
-        {
-            if(supports_dir_hv)
-            {
-                if(supports_dir_lr && supports_dir_ud)
-                {
-                    current_direction = current_dir_idx;
-                }
-                else if(supports_dir_lr || supports_dir_ud)
-                {
-                    current_direction = current_dir_idx + 2;
-                }
-                else
-                {
-                    current_direction = current_dir_idx + 4;
-                }
-            }
-
-            if(supports_dir_ud)
-            {
-                if(supports_dir_lr)
-                {
-                    current_direction = current_dir_idx;
-                }
-                else
-                {
-                    current_direction = current_dir_idx + 2;
-                }
-            }
-
-            if((supports_dir_lr)
-             &&(current_dir_idx < 2))
-            {
-                current_direction = current_dir_idx;
-            }
-
-            device->modes[(unsigned int)current_mode].direction = current_direction;
-        }
-
-        /*-----------------------------------------------------*\
-        | If Speed Slider is enabled, read the speed value      |
-        \*-----------------------------------------------------*/
-        if(ui->SpeedSlider->isEnabled())
-        {
-            /*-----------------------------------------------------*\
-            | If Speed Slider is inverted, invert value             |
-            \*-----------------------------------------------------*/
-            if(InvertedSpeed)
-            {
-                current_speed = device->modes[(unsigned int)current_mode].speed_min - ui->SpeedSlider->value() + device->modes[current_mode].speed_max;
-            }
-            else
-            {
-                current_speed = ui->SpeedSlider->value();
-            }
-        }
-
-        /*-----------------------------------------------------*\
-        | If Brightness Slider is enabled, read the value       |
-        \*-----------------------------------------------------*/
-        if(ui->BrightnessSlider->isEnabled())
-        {
-            /*-----------------------------------------------------*\
-            | If Brightness Slider is inverted, invert value        |
-            \*-----------------------------------------------------*/
-            if(InvertedBrightness)
-            {
-                current_brightness = device->modes[(unsigned int)current_mode].brightness_min - ui->BrightnessSlider->value() + device->modes[current_mode].brightness_max;
-            }
-            else
-            {
-                current_brightness = ui->BrightnessSlider->value();
-            }
-        }
-
-        /*-----------------------------------------------------*\
-        | Don't set the mode if the current mode is invalid     |
-        \*-----------------------------------------------------*/
-        if((unsigned int)current_mode < device->modes.size())
-        {
-            /*-----------------------------------------------------*\
-            | Update mode parameters                                |
-            \*-----------------------------------------------------*/
-            device->modes[(unsigned int)current_mode].speed         = current_speed;
-            device->modes[(unsigned int)current_mode].brightness    = current_brightness;
-
-            if(current_per_led)
-            {
-                device->modes[(unsigned int)current_mode].color_mode = MODE_COLORS_PER_LED;
-            }
-            else if(current_mode_specific)
-            {
-                device->modes[(unsigned int)current_mode].color_mode = MODE_COLORS_MODE_SPECIFIC;
-            }
-            else if(current_random)
-            {
-                device->modes[(unsigned int)current_mode].color_mode = MODE_COLORS_RANDOM;
-            }
-            else
-            {
-                device->modes[(unsigned int)current_mode].color_mode = MODE_COLORS_NONE;
-            }
-
-            /*-----------------------------------------------------*\
-            | Change device mode                                    |
-            \*-----------------------------------------------------*/
-            device->SetMode((unsigned int)current_mode);
-
-            if(device->modes[(unsigned int)current_mode].color_mode == MODE_COLORS_PER_LED)
-            {
-                device->UpdateLEDs();
-            }
-        }
-    }
-}
-
-void Ui::OpenRGBDevicePage::SetDevice(unsigned char red, unsigned char green, unsigned char blue)
-{
-    current_color.setRgb(red, green, blue);
-
-    /*-----------------------------------------------------*\
-    | Update the color UI                                   |
-    \*-----------------------------------------------------*/
-    colorChanged();
-}
-
-void Ui::OpenRGBDevicePage::UpdateDevice()
-{
-    ui->ModeBox->blockSignals(true);
-    ui->ModeBox->setCurrentIndex(device->active_mode);
-    ui->ModeBox->blockSignals(false);
-    UpdateModeUi();
-    UpdateMode();
-}
-
-void Ui::OpenRGBDevicePage::SetCustomMode(unsigned char red, unsigned char green, unsigned char blue)
-{
-    RGBColor color = ToRGBColor(red, green, blue);
-    /*-----------------------------------------------------*\
-    | Set the selected mode to the custom mode and update UI|
-    \*-----------------------------------------------------*/
-    device->SetCustomMode();
-    ui->ModeBox->blockSignals(true);
-    ui->ModeBox->setCurrentIndex(device->active_mode);
-    ui->ModeBox->blockSignals(false);
-    UpdateModeUi();
-
-    /*-----------------------------------------------------*\
-    | Set the color boxes                                   |
-    \*-----------------------------------------------------*/
-    current_color.setRgb(red, green, blue);
-    updateColorUi();
-
-    /*-----------------------------------------------------*\
-    | Read selected mode                                    |
-    \*-----------------------------------------------------*/
-    unsigned int selected_mode   = (unsigned int)ui->ModeBox->currentIndex();
-
-    switch(device->modes[selected_mode].color_mode)
-    {
-        case MODE_COLORS_PER_LED:
-        {
-            device->SetAllLEDs(color);
-        }
-        break;
-
-        case MODE_COLORS_MODE_SPECIFIC:
-        {
-            for(std::size_t i = 0; i < device->modes[selected_mode].colors.size(); i++)
-            {
-                device->modes[selected_mode].colors[i] = color;
-            }
-            break;
-        }
-    }
-
-    /*-----------------------------------------------------*\
-    | Apply mode and colors                                 |
-    \*-----------------------------------------------------*/
-    UpdateMode();
-}
-
-void Ui::OpenRGBDevicePage::on_SwatchBox_swatchChanged(const QColor color)
-{
-    /*-----------------------------------------------------*\
-    | Store the swatch color to the current color QColor    |
-    \*-----------------------------------------------------*/
-    current_color = color;
-
-    /*-----------------------------------------------------*\
-    | Update the color UI                                   |
-    \*-----------------------------------------------------*/
-    colorChanged();
-}
-
-void Ui::OpenRGBDevicePage::on_ColorWheelBox_colorChanged(const QColor color)
-{
-    /*-----------------------------------------------------*\
-    | Store the wheel color to the current color QColor     |
-    \*-----------------------------------------------------*/
-    current_color = color;
-
-    /*-----------------------------------------------------*\
-    | Update the color UI                                   |
-    \*-----------------------------------------------------*/
-    colorChanged();
-}
-
-bool Ui::OpenRGBDevicePage::autoUpdateEnabled()
-{
-    return !(device->modes[device->active_mode].flags & MODE_FLAG_AUTOMATIC_SAVE);
-}
-
-void Ui::OpenRGBDevicePage::on_RedSpinBox_valueChanged(int red)
-{
-    /*-----------------------------------------------------*\
-    | Update the current color QColor red channel           |
-    \*-----------------------------------------------------*/
-    current_color.setRed(red);
-
-    /*-----------------------------------------------------*\
-    | Update the color UI                                   |
-    \*-----------------------------------------------------*/
-    colorChanged();
-}
-
-void Ui::OpenRGBDevicePage::on_HueSpinBox_valueChanged(int hue)
-{
-    /*-----------------------------------------------------*\
-    | Read the saturation and value box values              |
-    \*-----------------------------------------------------*/
-    int sat = current_color.saturation();
-    int val = current_color.value();
-
-    /*-----------------------------------------------------*\
-    | Update the current color QColor using HSV             |
-    \*-----------------------------------------------------*/
-    current_color.setHsv(hue, sat, val);
-
-    /*-----------------------------------------------------*\
-    | Update the color UI                                   |
-    \*-----------------------------------------------------*/
-    colorChanged();
-}
-
-void Ui::OpenRGBDevicePage::on_GreenSpinBox_valueChanged(int green)
-{
-    /*-----------------------------------------------------*\
-    | Update the current color QColor green channel         |
-    \*-----------------------------------------------------*/
-    current_color.setGreen(green);
-
-    /*-----------------------------------------------------*\
-    | Update the color UI                                   |
-    \*-----------------------------------------------------*/
-    colorChanged();
-}
-
-void Ui::OpenRGBDevicePage::on_SatSpinBox_valueChanged(int sat)
-{
-    /*-----------------------------------------------------*\
-    | Read the hue and value box values                     |
-    \*-----------------------------------------------------*/
-    int hue = current_color.hue();
-    int val = current_color.value();
-
-    /*-----------------------------------------------------*\
-    | Update the current color QColor using HSV             |
-    \*-----------------------------------------------------*/
-    current_color.setHsv(hue, sat, val);
-
-    /*-----------------------------------------------------*\
-    | Update the color UI                                   |
-    \*-----------------------------------------------------*/
-    colorChanged();
-}
-
-void Ui::OpenRGBDevicePage::on_BlueSpinBox_valueChanged(int blue)
-{
-    /*-----------------------------------------------------*\
-    | Update the current color QColor blue channel          |
-    \*-----------------------------------------------------*/
-    current_color.setBlue(blue);
-
-    /*-----------------------------------------------------*\
-    | Update the color UI                                   |
-    \*-----------------------------------------------------*/
-    colorChanged();
-}
-
-void Ui::OpenRGBDevicePage::on_ValSpinBox_valueChanged(int val)
-{
-    /*-----------------------------------------------------*\
-    | Read the hue and saturation box values                |
-    \*-----------------------------------------------------*/
-    int hue = current_color.hue();
-    int sat = current_color.saturation();
-
-    /*-----------------------------------------------------*\
-    | Update the current color QColor using HSV             |
-    \*-----------------------------------------------------*/
-    current_color.setHsv(hue, sat, val);
-
-    /*-----------------------------------------------------*\
-    | Update the color UI                                   |
-    \*-----------------------------------------------------*/
-    colorChanged();
-}
-
-void Ui::OpenRGBDevicePage::on_HexLineEdit_textChanged(const QString &arg1)
-{
-    /*-----------------------------------------------------*\
-    | Make an editable copy of the string                   |
-    \*-----------------------------------------------------*/
-    QString temp = arg1;
-
-    /*-----------------------------------------------------*\
-    | Remove # character so that #XXXXXX color codes are    |
-    | acceptable.  0xXXXXXX codes are already accepted by   |
-    | toInt().  Convert into an RGBColor.  Mask off the     |
-    | unused bits.                                          |
-    \*-----------------------------------------------------*/
-    RGBColor color = (RGBColor)(0x00FFFFFF & temp.replace("#", "").toInt(NULL, 16));
-
-    /*-----------------------------------------------------*\
-    | Store new color into the current color QColor         |
-    | Because RGBColor stores color in BGR format, we have  |
-    | to reverse the R and B channels if the hex format is  |
-    | RGB.                                                  |
-    \*-----------------------------------------------------*/
-    if(HexFormatRGB)
-    {
-        current_color.setRed(RGBGetBValue(color));
-        current_color.setGreen(RGBGetGValue(color));
-        current_color.setBlue(RGBGetRValue(color));
-    }
-    else
-    {
-        current_color.setRed(RGBGetRValue(color));
-        current_color.setGreen(RGBGetGValue(color));
-        current_color.setBlue(RGBGetBValue(color));
-    }
-
-    /*-----------------------------------------------------*\
-    | Update the color UI, but set the UpdateHex flag to    |
-    | false so the hex edit box isn't updated while the user|
-    | is in the middle of typing a value.                   |
-    \*-----------------------------------------------------*/
-    UpdateHex = false;
-    colorChanged();
-    UpdateHex = true;
-}
-
-void Ui::OpenRGBDevicePage::on_DeviceViewBox_selectionChanged(QVector<int> indices)
-{
-    if(device->modes[device->active_mode].color_mode == MODE_COLORS_PER_LED)
-    {
-        ui->ZoneBox->blockSignals(true);
-        ui->LEDBox->blockSignals(true);
-        ui->ZoneBox->setCurrentIndex(0);
-        on_ZoneBox_currentIndexChanged(0);
-        //updateLeds(); // We want to update the LED box, but we don't want any of the side effects of that action
-        ui->ZoneBox->blockSignals(false);
-        if(indices.size() != 0 && size_t(indices.size()) != device->leds.size())
-        {
-            if(indices.size() == 1)
-            {
-                if(device->leds.size() == 1)
-                {
-                    ui->LEDBox->setCurrentIndex(0);
-                }
-                else
-                {
-                    ui->LEDBox->setCurrentIndex(indices[0] + 1);
-                    // Set everything to it's color
-                }
-                MultipleSelected = 0;
-            }
-            else
-            {
-                if(MultipleSelected)
-                {
-                    ui->LEDBox->removeItem((int)(device->leds.size() + 1));
-                }
-                // TODO: translate
-                ui->LEDBox->addItem("Multiple (" + QVariant(indices.size()).toString() + ")");
-                ui->LEDBox->setCurrentIndex((int)(device->leds.size() + 1));
-                MultipleSelected = 1;
-            }
-        }
-        else
-        {
-            ui->LEDBox->setCurrentIndex(0);
-        }
-        ui->LEDBox->blockSignals(false);
-    }
-}
-
-void Ui::OpenRGBDevicePage::on_SetAllButton_clicked()
-{
-    emit SetAllDevices(current_color.red(), current_color.green(), current_color.blue());
-}
-
-void Ui::OpenRGBDevicePage::on_EditZoneButton_clicked()
-{
-    switch(device->modes[device->active_mode].color_mode)
-    {
-    case MODE_COLORS_PER_LED:
-        {
-            /*-----------------------------------------*\
-            | Initialize both selected zone and segment |
-            | to -1 to indicate there is no selection   |
-            \*-----------------------------------------*/
-            unsigned int    current_index       = 0;
-            bool            selected_all_zones  = false;
-            int             selected_zone       = -1;
-            int             selected_segment    = -1;
-
-            /*-----------------------------------------*\
-            | Handle condition where device has more    |
-            | than one zone, which adds an "All Zones"  |
-            | entry to the Zone menu in the first index |
-            \*-----------------------------------------*/
-            if(device->zones.size() > 1)
-            {
-                if(ui->ZoneBox->currentIndex() == (int)current_index)
-                {
-                    selected_all_zones = true;
-                }
-
-                current_index++;
-            }
-
-            /*-----------------------------------------*\
-            | Determine selected zone and optionally    |
-            | selected segment based on index if "All   |
-            | Zones" is not the selected index          |
-            \*-----------------------------------------*/
-            if(!selected_all_zones)
-            {
-                for(std::size_t zone_idx = 0; zone_idx < device->zones.size(); zone_idx++)
-                {
-                    if(ui->ZoneBox->currentIndex() == (int)current_index)
-                    {
-                        selected_zone = (int)zone_idx;
-                        break;
-                    }
-
-                    current_index++;
-
-                    for(std::size_t segment_idx = 0; segment_idx < device->zones[zone_idx].segments.size(); segment_idx++)
-                    {
-                        if(ui->ZoneBox->currentIndex() == (int)current_index)
-                        {
-                            selected_zone    = (int)zone_idx;
-                            selected_segment = (int)segment_idx;
-                            break;
-                        }
-
-                        current_index++;
-                    }
-
-                    if(selected_segment != -1)
-                    {
-                        break;
-                    }
-                }
-            }
-
-            /*-----------------------------------------*\
-            | If all zones or a segment are selected,   |
-            | the edit button should not be clickable.  |
-            | If somehow this did get clicked, ignore.  |
-            \*-----------------------------------------*/
-            if(selected_all_zones || selected_segment != -1)
-            {
-                return;
-            }
-
-            /*-----------------------------------------*\
-            | Only allow resizing linear zones          |
-            \*-----------------------------------------*/
-            if(device->zones[selected_zone].type == ZONE_TYPE_LINEAR)
-            {
-                OpenRGBZoneResizeDialog dlg(device, selected_zone);
-
-                int new_size = dlg.show();
-
-                if(new_size >= 0)
-                {
-                    /*-----------------------------------------------------*\
-                    | Update mode UI to update Zone box                     |
-                    \*-----------------------------------------------------*/
-                    UpdateModeUi();
-
-                    /*-----------------------------------------------------*\
-                    | Update interface to update Device View                |
-                    \*-----------------------------------------------------*/
-                    UpdateInterface();
-
-                    /*-----------------------------------------------------*\
-                    | Update LED box                                        |
-                    \*-----------------------------------------------------*/
-                    on_ZoneBox_currentIndexChanged(selected_zone);
-
-                    /*-----------------------------------------------------*\
-                    | Update color picker with color of first LED           |
-                    \*-----------------------------------------------------*/
-                    on_LEDBox_currentIndexChanged(0);
-
-                    /*-----------------------------------------------------*\
-                    | Save the size profile                                 |
-                    \*-----------------------------------------------------*/
-                    SaveSizeProfile();
-                }
-            }
-        }
-        break;
-
-    case MODE_COLORS_MODE_SPECIFIC:
-        {
-            OpenRGBZoneResizeDialog dlg(device->modes[device->active_mode].colors_min,
-                                        device->modes[device->active_mode].colors_max,
-                                        (int)device->modes[device->active_mode].colors.size());
-
-            int new_size = dlg.show();
-
-            if(new_size > 0)
-            {
-                device->modes[device->active_mode].colors.resize(new_size);
-            }
-
-            UpdateModeUi();
-            UpdateMode();
-        }
-        break;
-    }
-}
-
-void Ui::OpenRGBDevicePage::ShowDeviceView()
-{
-    /*-----------------------------------------------------*\
-    | Read selected mode                                    |
-    \*-----------------------------------------------------*/
-    unsigned int selected_mode = (unsigned int)ui->ModeBox->currentIndex();
-
-    /*-----------------------------------------------------*\
-    | Set device view showing flag to True                  |
-    \*-----------------------------------------------------*/
-    DeviceViewShowing = true;
-
-    /*-----------------------------------------------------*\
-    | Only show device view if active mode is Per-LED and   |
-    | device contains at least one LED                      |
-    \*-----------------------------------------------------*/
-    if(device->modes[selected_mode].flags & MODE_FLAG_HAS_PER_LED_COLOR && device->leds.size() >= 1)
-    {
-        ui->DeviceViewBoxFrame->show();
-    }
-}
-
-void Ui::OpenRGBDevicePage::HideDeviceView()
-{
-    /*-----------------------------------------------------*\
-    | Set device view showing flag to False                 |
-    \*-----------------------------------------------------*/
-    DeviceViewShowing = false;
-
-    /*-----------------------------------------------------*\
-    | Hide device view                                      |
-    \*-----------------------------------------------------*/
-    ui->DeviceViewBoxFrame->hide();
-}
-
-void Ui::OpenRGBDevicePage::on_ApplyColorsButton_clicked()
-{
-    /*-----------------------------------------------------*\
-    | Read selected mode                                    |
-    \*-----------------------------------------------------*/
-    unsigned int selected_mode = (unsigned int)ui->ModeBox->currentIndex();
-
-    switch(device->modes[selected_mode].color_mode)
-    {
-        case MODE_COLORS_PER_LED:
-            {
-                RGBColor qrgb = ToRGBColor(
-                                    current_color.red(),
-                                    current_color.green(),
-                                    current_color.blue()
-                                );
-
-                ui->DeviceViewBox->setSelectionColor(qrgb);
-            }
-            break;
-
-        case MODE_COLORS_MODE_SPECIFIC:
-            {
-                unsigned int index = ui->LEDBox->currentIndex();
-
-                /*-----------------------------------------------------*\
-                | Set all device LEDs to the current color              |
-                \*-----------------------------------------------------*/
-                RGBColor color = ToRGBColor(
-                                    current_color.red(),
-                                    current_color.green(),
-                                    current_color.blue()
-                                );
-
-                device->modes[selected_mode].colors[index] = color;
-
-                device->UpdateMode();
-            }
-            break;
-    }
-}
-
-void Ui::OpenRGBDevicePage::on_SelectAllLEDsButton_clicked()
-{
-    if(device->modes[device->active_mode].color_mode == MODE_COLORS_PER_LED)
-    {
-        ui->LEDBox->setCurrentIndex(0);
-        on_LEDBox_currentIndexChanged(0);
-        ui->DeviceViewBox->repaint();
-    }
-}
-
-void Ui::OpenRGBDevicePage::on_DeviceSaveButton_clicked()
-{
-    if(device->modes[device->active_mode].flags & MODE_FLAG_MANUAL_SAVE)
-    {
-        device->SaveMode();
-    }
-}
-
-void Ui::OpenRGBDevicePage::colorChanged()
-{
-    updateColorUi();
-
-    if(autoUpdateEnabled())
-    {
-        unsigned int selected_mode   = (unsigned int)ui->ModeBox->currentIndex();
-
-        /*-----------------------------------------------------------------*\
-        | OpenRGB's RGBColor is stored differently than Qt's qrgb type,     |
-        | so casting between them doesn't work                              |
-        \*-----------------------------------------------------------------*/
-        RGBColor rgb_color = ToRGBColor(current_color.red(), current_color.green(), current_color.blue());
-
-        switch(device->modes[selected_mode].color_mode)
-        {
-            case MODE_COLORS_PER_LED:
-            {
-                ui->DeviceViewBox->setSelectionColor(rgb_color);
-                break;
-            }
-
-            case MODE_COLORS_MODE_SPECIFIC:
-            {
-                unsigned int index = ui->LEDBox->currentIndex();
-
-                device->modes[selected_mode].colors[index] = rgb_color;
-                device->UpdateMode();
-                break;
-            }
-        }
-    }
-}
-
-void Ui::OpenRGBDevicePage::updateColorUi()
-{
-    /*-----------------------------------------------------*\
-    | Update colorwheel                                     |
-    \*-----------------------------------------------------*/
-    ui->ColorWheelBox->blockSignals(true);
-    ui->ColorWheelBox->setColor(current_color);
-    ui->ColorWheelBox->blockSignals(false);
-
-    /*-----------------------------------------------------*\
-    | Update RGB spinboxes                                  |
-    \*-----------------------------------------------------*/
-    ui->RedSpinBox->blockSignals(true);
-    ui->RedSpinBox->setValue(current_color.red());
-    ui->RedSpinBox->blockSignals(false);
-
-    ui->GreenSpinBox->blockSignals(true);
-    ui->GreenSpinBox->setValue(current_color.green());
-    ui->GreenSpinBox->blockSignals(false);
-
-    ui->BlueSpinBox->blockSignals(true);
-    ui->BlueSpinBox->setValue(current_color.blue());
-    ui->BlueSpinBox->blockSignals(false);
-
-    /*-----------------------------------------------------*\
-    | Update HSV spinboxes                                  |
-    \*-----------------------------------------------------*/
-    ui->HueSpinBox->blockSignals(true);
-    ui->HueSpinBox->setValue(current_color.hue());
-    ui->HueSpinBox->blockSignals(false);
-
-    ui->SatSpinBox->blockSignals(true);
-    ui->SatSpinBox->setValue(current_color.saturation());
-    ui->SatSpinBox->blockSignals(false);
-
-    ui->ValSpinBox->blockSignals(true);
-    ui->ValSpinBox->setValue(current_color.value());
-    ui->ValSpinBox->blockSignals(false);
-
-    /*-----------------------------------------------------*\
-    | Update Hex edit box                                   |
-    \*-----------------------------------------------------*/
-    if(UpdateHex)
-    {
-        RGBColor color = (0x00FFFFFF & current_color.rgb());
-
-        /*-------------------------------------------------*\
-        | If the hex format is BGR, swap R and B before     |
-        | displaying as hex                                 |
-        \*-------------------------------------------------*/
-        if(!HexFormatRGB)
-        {
-            color = RGBGetRValue(color) << 16
-                  | RGBGetGValue(color) << 8
-                  | RGBGetBValue(color);
-        }
-
-        ui->HexLineEdit->blockSignals(true);
-        ui->HexLineEdit->setText(QString().asprintf("%06X", color));
-        ui->HexLineEdit->blockSignals(false);
-    }
-}
diff --git a/qt/OpenRGBDevicePage/OpenRGBDevicePage.h b/qt/OpenRGBDevicePage/OpenRGBDevicePage.h
deleted file mode 100644
index 7e56b85a..00000000
--- a/qt/OpenRGBDevicePage/OpenRGBDevicePage.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBDevicePage.h                                       |
-|                                                           |
-|   User interface for OpenRGB device page                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QFrame>
-#include "ui_OpenRGBDevicePage.h"
-#include "RGBController.h"
-
-namespace Ui
-{
-    class OpenRGBDevicePage;
-}
-
-class Ui::OpenRGBDevicePage : public QFrame
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBDevicePage(RGBController *dev, QWidget *parent = nullptr);
-    ~OpenRGBDevicePage();
-
-    RGBController* GetController();
-
-    void SetDevice(unsigned char red, unsigned char green, unsigned char blue); // Could be moved to private
-    void SetCustomMode(unsigned char red, unsigned char green, unsigned char blue);
-    void UpdateDevice();
-    void UpdateMode();
-    void UpdateModeUi();
-    void ShowDeviceView();
-    void HideDeviceView();
-
-private slots:
-    void changeEvent(QEvent *event);
-    void UpdateInterface();
-
-    void on_ColorWheelBox_colorChanged(const QColor color);
-    void on_SwatchBox_swatchChanged(const QColor color);
-    void on_DirectionBox_currentIndexChanged(int index);
-    void on_ZoneBox_currentIndexChanged(int index);
-    void on_LEDBox_currentIndexChanged(int index);
-    void on_BrightnessSlider_valueChanged(int value);
-    void on_ModeBox_currentIndexChanged(int index);
-    void on_SpeedSlider_valueChanged(int value);
-    void on_RedSpinBox_valueChanged(int red);
-    void on_HueSpinBox_valueChanged(int hue);
-    void on_GreenSpinBox_valueChanged(int green);
-    void on_SatSpinBox_valueChanged(int sat);
-    void on_BlueSpinBox_valueChanged(int blue);
-    void on_ValSpinBox_valueChanged(int val);
-    void on_HexLineEdit_textChanged(const QString &arg1);
-    void on_DeviceViewBox_selectionChanged(QVector<int>);
-
-    void on_SetAllButton_clicked();
-    void on_RandomCheck_clicked();
-    void on_PerLEDCheck_clicked();
-    void on_ModeSpecificCheck_clicked();
-    void on_EditZoneButton_clicked();
-
-    void on_ApplyColorsButton_clicked();
-
-    void on_SelectAllLEDsButton_clicked();
-
-    void on_DeviceSaveButton_clicked();
-
-private:
-    Ui::OpenRGBDevicePageUi *ui;
-    RGBController *device;
-
-    bool InvertedSpeed      = false;
-    bool InvertedBrightness = false;
-    bool MultipleSelected   = false;
-    bool DeviceViewShowing  = false;
-    bool UpdateHex          = true;
-    bool HexFormatRGB       = true;
-
-    QColor current_color;
-    void updateColorUi();
-    void colorChanged();
-
-    bool autoUpdateEnabled();
-
-    QString ModeDescription(const mode& m);
-
-signals:
-    void SetAllDevices(unsigned char red, unsigned char green, unsigned char blue);
-    void SaveSizeProfile();
-};
diff --git a/qt/OpenRGBDevicePage/OpenRGBDevicePage.ui b/qt/OpenRGBDevicePage/OpenRGBDevicePage.ui
deleted file mode 100644
index 758e952d..00000000
--- a/qt/OpenRGBDevicePage/OpenRGBDevicePage.ui
+++ /dev/null
@@ -1,439 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBDevicePageUi</class>
- <widget class="QFrame" name="OpenRGBDevicePageUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>843</width>
-    <height>374</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Device page</string>
-  </property>
-  <layout class="QGridLayout" name="OpenRGBDevicePageUiGridLayout" rowstretch="0,0" columnstretch="3,1">
-   <item row="1" column="1">
-    <widget class="QFrame" name="ColorFrame">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
-       <horstretch>0</horstretch>
-       <verstretch>0</verstretch>
-      </sizepolicy>
-     </property>
-     <property name="autoFillBackground">
-      <bool>true</bool>
-     </property>
-     <property name="frameShape">
-      <enum>QFrame::Shape::StyledPanel</enum>
-     </property>
-     <property name="frameShadow">
-      <enum>QFrame::Shadow::Sunken</enum>
-     </property>
-     <layout class="QGridLayout" name="ColorGridLayout" rowstretch="10,0,0,0" columnstretch="0">
-      <item row="2" column="0">
-       <widget class="QFrame" name="ColorEntryFrame">
-        <property name="frameShape">
-         <enum>QFrame::Shape::NoFrame</enum>
-        </property>
-        <property name="frameShadow">
-         <enum>QFrame::Shadow::Raised</enum>
-        </property>
-        <layout class="QGridLayout" name="ColorEntryGridLayout" columnstretch="0,1,0,1">
-         <property name="leftMargin">
-          <number>0</number>
-         </property>
-         <property name="topMargin">
-          <number>0</number>
-         </property>
-         <property name="rightMargin">
-          <number>0</number>
-         </property>
-         <property name="bottomMargin">
-          <number>0</number>
-         </property>
-         <item row="0" column="0">
-          <widget class="QLabel" name="RedLabel">
-           <property name="text">
-            <string>R:</string>
-           </property>
-          </widget>
-         </item>
-         <item row="0" column="1">
-          <widget class="QSpinBox" name="RedSpinBox">
-           <property name="maximum">
-            <number>255</number>
-           </property>
-          </widget>
-         </item>
-         <item row="0" column="2">
-          <widget class="QLabel" name="HueLabel">
-           <property name="text">
-            <string>H:</string>
-           </property>
-          </widget>
-         </item>
-         <item row="0" column="3">
-          <widget class="QSpinBox" name="HueSpinBox">
-           <property name="maximum">
-            <number>359</number>
-           </property>
-          </widget>
-         </item>
-         <item row="1" column="0">
-          <widget class="QLabel" name="GreenLabel">
-           <property name="text">
-            <string>G:</string>
-           </property>
-          </widget>
-         </item>
-         <item row="1" column="1">
-          <widget class="QSpinBox" name="GreenSpinBox">
-           <property name="maximum">
-            <number>255</number>
-           </property>
-          </widget>
-         </item>
-         <item row="1" column="2">
-          <widget class="QLabel" name="SatLabel">
-           <property name="text">
-            <string>S:</string>
-           </property>
-          </widget>
-         </item>
-         <item row="1" column="3">
-          <widget class="QSpinBox" name="SatSpinBox">
-           <property name="maximum">
-            <number>255</number>
-           </property>
-          </widget>
-         </item>
-         <item row="2" column="0">
-          <widget class="QLabel" name="BlueLabel">
-           <property name="text">
-            <string>B:</string>
-           </property>
-          </widget>
-         </item>
-         <item row="2" column="1">
-          <widget class="QSpinBox" name="BlueSpinBox">
-           <property name="maximum">
-            <number>255</number>
-           </property>
-          </widget>
-         </item>
-         <item row="2" column="2">
-          <widget class="QLabel" name="ValLabel">
-           <property name="text">
-            <string>V:</string>
-           </property>
-          </widget>
-         </item>
-         <item row="2" column="3">
-          <widget class="QSpinBox" name="ValSpinBox">
-           <property name="maximum">
-            <number>255</number>
-           </property>
-          </widget>
-         </item>
-         <item row="3" column="0">
-          <widget class="QLabel" name="HexLabel">
-           <property name="text">
-            <string>Hex:</string>
-           </property>
-          </widget>
-         </item>
-         <item row="3" column="1" colspan="3">
-          <widget class="QLineEdit" name="HexLineEdit">
-           <property name="maxLength">
-            <number>8</number>
-           </property>
-          </widget>
-         </item>
-        </layout>
-       </widget>
-      </item>
-      <item row="0" column="0">
-       <widget class="ColorWheel" name="ColorWheelBox" native="true">
-        <property name="sizePolicy">
-         <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
-          <horstretch>0</horstretch>
-          <verstretch>0</verstretch>
-         </sizepolicy>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="0">
-       <widget class="Swatches" name="SwatchBox" native="true">
-        <property name="sizePolicy">
-         <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
-          <horstretch>0</horstretch>
-          <verstretch>0</verstretch>
-         </sizepolicy>
-        </property>
-        <property name="styleSheet">
-         <string notr="true"/>
-        </property>
-       </widget>
-      </item>
-      <item row="3" column="0">
-       <widget class="QPushButton" name="DeviceSaveButton">
-        <property name="text">
-         <string>Save To Device</string>
-        </property>
-       </widget>
-      </item>
-     </layout>
-    </widget>
-   </item>
-   <item row="1" column="0">
-    <widget class="QFrame" name="ControlsFrame">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
-       <horstretch>0</horstretch>
-       <verstretch>0</verstretch>
-      </sizepolicy>
-     </property>
-     <property name="autoFillBackground">
-      <bool>true</bool>
-     </property>
-     <property name="frameShape">
-      <enum>QFrame::Shape::StyledPanel</enum>
-     </property>
-     <property name="frameShadow">
-      <enum>QFrame::Shadow::Sunken</enum>
-     </property>
-     <layout class="QGridLayout" name="ControlsGridLayout" columnstretch="0,1,1,1">
-      <item row="5" column="0">
-       <widget class="QLabel" name="SpeedLabel">
-        <property name="text">
-         <string>Speed:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="1" colspan="2">
-       <widget class="QComboBox" name="LEDBox"/>
-      </item>
-      <item row="0" column="1" colspan="2">
-       <widget class="QComboBox" name="ZoneBox"/>
-      </item>
-      <item row="4" column="3">
-       <widget class="QRadioButton" name="RandomCheck">
-        <property name="text">
-         <string>Random</string>
-        </property>
-       </widget>
-      </item>
-      <item row="3" column="0">
-       <widget class="QLabel" name="ModeLabel">
-        <property name="text">
-         <string>Mode:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="6" column="0">
-       <widget class="QLabel" name="DirectionLabel">
-        <property name="text">
-         <string>Dir:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="1" colspan="3">
-       <widget class="QTooltipedSlider" name="SpeedSlider">
-        <property name="orientation">
-         <enum>Qt::Orientation::Horizontal</enum>
-        </property>
-       </widget>
-      </item>
-      <item row="4" column="0">
-       <widget class="QLabel" name="ColorLabel">
-        <property name="text">
-         <string>Colors:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="4" column="1">
-       <widget class="QRadioButton" name="PerLEDCheck">
-        <property name="text">
-         <string>Per-LED</string>
-        </property>
-       </widget>
-      </item>
-      <item row="0" column="0">
-       <widget class="QLabel" name="ZoneLabel">
-        <property name="text">
-         <string>Zone:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="3" column="1" colspan="3">
-       <widget class="QComboBox" name="ModeBox"/>
-      </item>
-      <item row="2" column="3">
-       <widget class="QPushButton" name="SetAllButton">
-        <property name="toolTip">
-         <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p align=&quot;justify&quot;&gt;Sets all devices to&lt;br/&gt;&lt;b&gt;Static&lt;/b&gt; mode and&lt;br/&gt;applies the selected color.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
-        </property>
-        <property name="text">
-         <string>Apply All Devices</string>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="0">
-       <widget class="QLabel" name="LEDLabel">
-        <property name="text">
-         <string>LED:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="0" column="3">
-       <widget class="QPushButton" name="EditZoneButton">
-        <property name="text">
-         <string>Edit</string>
-        </property>
-       </widget>
-      </item>
-      <item row="4" column="2">
-       <widget class="QRadioButton" name="ModeSpecificCheck">
-        <property name="text">
-         <string>Mode-Specific</string>
-        </property>
-       </widget>
-      </item>
-      <item row="2" column="1" colspan="2">
-       <widget class="QPushButton" name="ApplyColorsButton">
-        <property name="text">
-         <string>Apply Colors To Selection</string>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="3">
-       <widget class="QPushButton" name="SelectAllLEDsButton">
-        <property name="text">
-         <string>Select All</string>
-        </property>
-       </widget>
-      </item>
-      <item row="7" column="1" colspan="3">
-       <widget class="QTooltipedSlider" name="BrightnessSlider">
-        <property name="orientation">
-         <enum>Qt::Orientation::Horizontal</enum>
-        </property>
-       </widget>
-      </item>
-      <item row="6" column="1" colspan="3">
-       <widget class="QComboBox" name="DirectionBox"/>
-      </item>
-      <item row="7" column="0">
-       <widget class="QLabel" name="BrightnessLabel">
-        <property name="text">
-         <string>Brightness:</string>
-        </property>
-       </widget>
-      </item>
-     </layout>
-    </widget>
-   </item>
-   <item row="0" column="0" colspan="2">
-    <widget class="QFrame" name="DeviceViewBoxFrame">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
-       <horstretch>0</horstretch>
-       <verstretch>0</verstretch>
-      </sizepolicy>
-     </property>
-     <property name="minimumSize">
-      <size>
-       <width>0</width>
-       <height>0</height>
-      </size>
-     </property>
-     <property name="autoFillBackground">
-      <bool>true</bool>
-     </property>
-     <property name="frameShape">
-      <enum>QFrame::Shape::StyledPanel</enum>
-     </property>
-     <property name="frameShadow">
-      <enum>QFrame::Shadow::Sunken</enum>
-     </property>
-     <layout class="QGridLayout" name="DeviceViewBoxGridLayout">
-      <item row="0" column="0">
-       <widget class="DeviceView" name="DeviceViewBox" native="true">
-        <property name="sizePolicy">
-         <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
-          <horstretch>0</horstretch>
-          <verstretch>0</verstretch>
-         </sizepolicy>
-        </property>
-        <property name="minimumSize">
-         <size>
-          <width>0</width>
-          <height>0</height>
-         </size>
-        </property>
-       </widget>
-      </item>
-     </layout>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <customwidgets>
-  <customwidget>
-   <class>ColorWheel</class>
-   <extends>QWidget</extends>
-   <header location="global">ColorWheel.h</header>
-   <container>1</container>
-   <slots>
-    <signal>colorChanged(QColor)</signal>
-   </slots>
-  </customwidget>
-  <customwidget>
-   <class>DeviceView</class>
-   <extends>QWidget</extends>
-   <header location="global">DeviceView.h</header>
-   <container>1</container>
-  </customwidget>
-  <customwidget>
-   <class>Swatches</class>
-   <extends>QWidget</extends>
-   <header location="global">swatches.h</header>
-   <container>1</container>
-   <slots>
-    <signal>swatchChanged(QColor)</signal>
-    <slot>currentColorInput(QColor)</slot>
-   </slots>
-  </customwidget>
-  <customwidget>
-   <class>QTooltipedSlider</class>
-   <extends>QSlider</extends>
-   <header location="global">QTooltipedSlider.h</header>
-  </customwidget>
- </customwidgets>
- <tabstops>
-  <tabstop>ZoneBox</tabstop>
-  <tabstop>EditZoneButton</tabstop>
-  <tabstop>LEDBox</tabstop>
-  <tabstop>SelectAllLEDsButton</tabstop>
-  <tabstop>ApplyColorsButton</tabstop>
-  <tabstop>SetAllButton</tabstop>
-  <tabstop>ModeBox</tabstop>
-  <tabstop>PerLEDCheck</tabstop>
-  <tabstop>ModeSpecificCheck</tabstop>
-  <tabstop>RandomCheck</tabstop>
-  <tabstop>SpeedSlider</tabstop>
-  <tabstop>DirectionBox</tabstop>
-  <tabstop>BrightnessSlider</tabstop>
-  <tabstop>RedSpinBox</tabstop>
-  <tabstop>GreenSpinBox</tabstop>
-  <tabstop>BlueSpinBox</tabstop>
-  <tabstop>HueSpinBox</tabstop>
-  <tabstop>SatSpinBox</tabstop>
-  <tabstop>ValSpinBox</tabstop>
-  <tabstop>DeviceSaveButton</tabstop>
- </tabstops>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBDialog/OpenRGBDialog.cpp b/qt/OpenRGBDialog/OpenRGBDialog.cpp
deleted file mode 100644
index c52968ae..00000000
--- a/qt/OpenRGBDialog/OpenRGBDialog.cpp
+++ /dev/null
@@ -1,207 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBDialog.cpp                                         |
-|                                                           |
-|   User interface for OpenRGB main window                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBDialog.h"
-
-using namespace Ui;
-
-OpenRGBDialog::OpenRGBDialog(std::vector<i2c_smbus_interface *>& bus, std::vector<RGBController *>& control, QWidget *parent) : QMainWindow(parent), busses(bus), controllers (control), ui(new OpenRGBDialogUi)
-{
-    ui->setupUi(this);
-
-    QIcon icon(":org.openrgb.OpenRGB.png");
-    setWindowIcon(icon);
-
-    QPalette pal;
-
-    pal = ui->ButtonRed->palette();
-    pal.setColor(QPalette::Button, QColor(255, 0, 0));
-    ui->ButtonRed->setAutoFillBackground(true);
-    ui->ButtonRed->setPalette(pal);
-    ui->ButtonRed->setFlat(true);
-    ui->ButtonRed->update();
-
-    pal = ui->ButtonYellow->palette();
-    pal.setColor(QPalette::Button, QColor(255, 255, 0));
-    ui->ButtonYellow->setAutoFillBackground(true);
-    ui->ButtonYellow->setPalette(pal);
-    ui->ButtonYellow->setFlat(true);
-    ui->ButtonYellow->update();
-
-    pal = ui->ButtonGreen->palette();
-    pal.setColor(QPalette::Button, QColor(0, 255, 0));
-    ui->ButtonGreen->setAutoFillBackground(true);
-    ui->ButtonGreen->setPalette(pal);
-    ui->ButtonGreen->setFlat(true);
-    ui->ButtonGreen->update();
-
-    pal = ui->ButtonCyan->palette();
-    pal.setColor(QPalette::Button, QColor(0, 255, 255));
-    ui->ButtonCyan->setAutoFillBackground(true);
-    ui->ButtonCyan->setPalette(pal);
-    ui->ButtonCyan->setFlat(true);
-    ui->ButtonCyan->update();
-
-    pal = ui->ButtonBlue->palette();
-    pal.setColor(QPalette::Button, QColor(0, 0, 255));
-    ui->ButtonBlue->setAutoFillBackground(true);
-    ui->ButtonBlue->setPalette(pal);
-    ui->ButtonBlue->setFlat(true);
-    ui->ButtonBlue->update();
-
-    pal = ui->ButtonMagenta->palette();
-    pal.setColor(QPalette::Button, QColor(255, 0, 255));
-    ui->ButtonMagenta->setAutoFillBackground(true);
-    ui->ButtonMagenta->setPalette(pal);
-    ui->ButtonMagenta->setFlat(true);
-    ui->ButtonMagenta->update();
-
-    for (std::size_t i = 0; i < controllers.size(); i++)
-    {
-        ui->ComboDevices->addItem(controllers[i]->name.c_str());
-    }
-
-    //Triggers on_ComboDevices_currentIndexChanged so we don't need to update the other fields here
-    ui->ComboDevices->setCurrentIndex(0);
-}
-
-OpenRGBDialog::~OpenRGBDialog()
-{
-    delete ui;
-}
-
-void OpenRGBDialog::show()
-{
-    QMainWindow::show();
-}
-
-void Ui::OpenRGBDialog::on_ButtonRed_clicked()
-{
-    ui->EditLED0R->setText("255");
-    ui->EditLED0G->setText("0");
-    ui->EditLED0B->setText("0");
-}
-
-void Ui::OpenRGBDialog::on_ButtonYellow_clicked()
-{
-    ui->EditLED0R->setText("255");
-    ui->EditLED0G->setText("255");
-    ui->EditLED0B->setText("0");
-}
-
-void Ui::OpenRGBDialog::on_ButtonGreen_clicked()
-{
-    ui->EditLED0R->setText("0");
-    ui->EditLED0G->setText("255");
-    ui->EditLED0B->setText("0");
-}
-
-void Ui::OpenRGBDialog::on_ButtonCyan_clicked()
-{
-    ui->EditLED0R->setText("0");
-    ui->EditLED0G->setText("255");
-    ui->EditLED0B->setText("255");
-}
-
-void Ui::OpenRGBDialog::on_ButtonBlue_clicked()
-{
-    ui->EditLED0R->setText("0");
-    ui->EditLED0G->setText("0");
-    ui->EditLED0B->setText("255");
-}
-
-void Ui::OpenRGBDialog::on_ButtonMagenta_clicked()
-{
-    ui->EditLED0R->setText("255");
-    ui->EditLED0G->setText("0");
-    ui->EditLED0B->setText("255");
-}
-
-void Ui::OpenRGBDialog::on_ButtonSetAll_clicked()
-{
-    RGBColor color = ToRGBColor(
-        ui->EditLED0R->text().toInt(),
-        ui->EditLED0G->text().toInt(),
-        ui->EditLED0B->text().toInt()
-    );
-
-    for (std::size_t i = 0; i < controllers.size(); i++)
-    {
-        controllers[i]->SetCustomMode();
-        controllers[i]->SetAllLEDs(color);
-    }
-}
-
-void Ui::OpenRGBDialog::on_ButtonSetDevice_clicked()
-{
-    RGBColor color = ToRGBColor(
-        ui->EditLED0R->text().toInt(),
-        ui->EditLED0G->text().toInt(),
-        ui->EditLED0B->text().toInt()
-    );
-
-    controllers[ui->ComboDevices->currentIndex()]->SetAllLEDs(color);
-}
-
-void Ui::OpenRGBDialog::on_ButtonSetZone_clicked()
-{
-    RGBColor color = ToRGBColor(
-        ui->EditLED0R->text().toInt(),
-        ui->EditLED0G->text().toInt(),
-        ui->EditLED0B->text().toInt()
-    );
-
-    controllers[ui->ComboDevices->currentIndex()]->SetAllZoneLEDs(ui->ComboZones->currentIndex(), color);
-}
-
-void Ui::OpenRGBDialog::on_ButtonSetLED_clicked()
-{
-    RGBColor color = ToRGBColor(
-        ui->EditLED0R->text().toInt(),
-        ui->EditLED0G->text().toInt(),
-        ui->EditLED0B->text().toInt()
-    );
-
-    controllers[ui->ComboDevices->currentIndex()]->SetLED(ui->ComboLEDs->currentIndex(), color);
-}
-
-void Ui::OpenRGBDialog::on_ComboDevices_currentIndexChanged()
-{
-    ui->ComboModes->clear();
-
-    for (std::size_t i = 0; i < controllers[ui->ComboDevices->currentIndex()]->modes.size(); i++)
-    {
-        ui->ComboModes->addItem(controllers[ui->ComboDevices->currentIndex()]->modes[i].name.c_str());
-    }
-
-    ui->ComboModes->setCurrentIndex(controllers[ui->ComboDevices->currentIndex()]->GetMode());
-
-    ui->ComboZones->clear();
-
-    for (std::size_t i = 0; i < controllers[ui->ComboDevices->currentIndex()]->zones.size(); i++)
-    {
-        ui->ComboZones->addItem(controllers[ui->ComboDevices->currentIndex()]->zones[i].name.c_str());
-    }
-
-    ui->ComboZones->setCurrentIndex(0);
-
-    ui->ComboLEDs->clear();
-
-    for (std::size_t i = 0; i < controllers[ui->ComboDevices->currentIndex()]->leds.size(); i++)
-    {
-        ui->ComboLEDs->addItem(controllers[ui->ComboDevices->currentIndex()]->leds[i].name.c_str());
-    }
-
-    ui->ComboLEDs->setCurrentIndex(0);
-}
-
-void Ui::OpenRGBDialog::on_ComboModes_currentIndexChanged()
-{
-    controllers[ui->ComboDevices->currentIndex()]->SetMode(ui->ComboModes->currentIndex());
-}
diff --git a/qt/OpenRGBDialog/OpenRGBDialog.h b/qt/OpenRGBDialog/OpenRGBDialog.h
deleted file mode 100644
index f65335c7..00000000
--- a/qt/OpenRGBDialog/OpenRGBDialog.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBDialog.h                                           |
-|                                                           |
-|   User interface for OpenRGB main window                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <vector>
-#include <QMainWindow>
-#include <QTimer>
-#include <QSystemTrayIcon>
-#include <QMenu>
-#include "ui_OpenRGBDialog.h"
-#include "i2c_smbus.h"
-#include "RGBController.h"
-
-namespace Ui
-{
-    class OpenRGBDialog;
-}
-
-class Ui::OpenRGBDialog : public QMainWindow
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBDialog(std::vector<i2c_smbus_interface *>& bus, std::vector<RGBController *>& control, QWidget *parent = 0);
-    ~OpenRGBDialog();
-
-    void show();
-    void setMode(unsigned char mode_val);
-
-protected:
-    std::vector<i2c_smbus_interface *>& busses;
-    std::vector<RGBController *>& controllers;
-
-private slots:
-    void on_ButtonRed_clicked();
-    void on_ButtonYellow_clicked();
-    void on_ButtonGreen_clicked();
-    void on_ButtonCyan_clicked();
-    void on_ButtonBlue_clicked();
-    void on_ButtonMagenta_clicked();
-
-    void on_ButtonSetAll_clicked();
-
-    void on_ButtonSetDevice_clicked();
-
-    void on_ButtonSetZone_clicked();
-
-    void on_ButtonSetLED_clicked();
-
-    void on_ComboDevices_currentIndexChanged();
-
-    void on_ComboModes_currentIndexChanged();
-
-private:
-    Ui::OpenRGBDialogUi *ui;
-};
diff --git a/qt/OpenRGBDialog/OpenRGBDialog.ui b/qt/OpenRGBDialog/OpenRGBDialog.ui
deleted file mode 100644
index 86826057..00000000
--- a/qt/OpenRGBDialog/OpenRGBDialog.ui
+++ /dev/null
@@ -1,163 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBDialogUi</class>
- <widget class="QMainWindow" name="OpenRGBDialogUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>500</width>
-    <height>160</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>OpenRGB</string>
-  </property>
-  <widget class="QWidget" name="centralWidget">
-   <layout class="QGridLayout" name="gridLayout">
-    <item row="0" column="0">
-     <widget class="QPushButton" name="ButtonRed">
-      <property name="text">
-       <string/>
-      </property>
-     </widget>
-    </item>
-    <item row="0" column="1">
-     <widget class="QPushButton" name="ButtonYellow">
-      <property name="text">
-       <string/>
-      </property>
-     </widget>
-    </item>
-    <item row="0" column="2">
-     <widget class="QPushButton" name="ButtonGreen">
-      <property name="text">
-       <string/>
-      </property>
-     </widget>
-    </item>
-    <item row="0" column="3">
-     <widget class="QPushButton" name="ButtonCyan">
-      <property name="text">
-       <string/>
-      </property>
-     </widget>
-    </item>
-    <item row="0" column="4">
-     <widget class="QPushButton" name="ButtonBlue">
-      <property name="text">
-       <string/>
-      </property>
-     </widget>
-    </item>
-    <item row="0" column="5">
-     <widget class="QPushButton" name="ButtonMagenta">
-      <property name="text">
-       <string/>
-      </property>
-     </widget>
-    </item>
-    <item row="0" column="6">
-     <widget class="QLabel" name="LabelAuraDevice">
-      <property name="text">
-       <string>Device</string>
-      </property>
-     </widget>
-    </item>
-    <item row="0" column="7">
-     <widget class="QComboBox" name="ComboDevices"/>
-    </item>
-    <item row="1" column="0" colspan="2">
-     <widget class="QLabel" name="LabelRed">
-      <property name="text">
-       <string>Red</string>
-      </property>
-     </widget>
-    </item>
-    <item row="1" column="2" colspan="2">
-     <widget class="QLabel" name="LabelGreen">
-      <property name="text">
-       <string>Green</string>
-      </property>
-     </widget>
-    </item>
-    <item row="1" column="4" colspan="2">
-     <widget class="QLabel" name="LabelBlue">
-      <property name="text">
-       <string>Blue</string>
-      </property>
-     </widget>
-    </item>
-    <item row="1" column="6" rowspan="2">
-     <widget class="QLabel" name="LabelMode">
-      <property name="text">
-       <string>Mode</string>
-      </property>
-     </widget>
-    </item>
-    <item row="1" column="7" rowspan="2">
-     <widget class="QComboBox" name="ComboModes"/>
-    </item>
-    <item row="2" column="0" colspan="2">
-     <widget class="QLineEdit" name="EditLED0R"/>
-    </item>
-    <item row="2" column="2" colspan="2">
-     <widget class="QLineEdit" name="EditLED0G"/>
-    </item>
-    <item row="2" column="4" colspan="2">
-     <widget class="QLineEdit" name="EditLED0B"/>
-    </item>
-    <item row="3" column="0" colspan="3">
-     <widget class="QPushButton" name="ButtonSetAll">
-      <property name="text">
-       <string>Set All</string>
-      </property>
-     </widget>
-    </item>
-    <item row="3" column="3" colspan="3">
-     <widget class="QPushButton" name="ButtonSetDevice">
-      <property name="text">
-       <string>Set Device</string>
-      </property>
-     </widget>
-    </item>
-    <item row="3" column="6">
-     <widget class="QLabel" name="LabelZone">
-      <property name="text">
-       <string>Zone</string>
-      </property>
-     </widget>
-    </item>
-    <item row="3" column="7">
-     <widget class="QComboBox" name="ComboZones"/>
-    </item>
-    <item row="4" column="0" colspan="3">
-     <widget class="QPushButton" name="ButtonSetZone">
-      <property name="text">
-       <string>Set Zone</string>
-      </property>
-     </widget>
-    </item>
-    <item row="4" column="3" colspan="3">
-     <widget class="QPushButton" name="ButtonSetLED">
-      <property name="text">
-       <string>Set LED</string>
-      </property>
-     </widget>
-    </item>
-    <item row="4" column="6">
-     <widget class="QLabel" name="LabelLED">
-      <property name="text">
-       <string>LED</string>
-      </property>
-     </widget>
-    </item>
-    <item row="4" column="7">
-     <widget class="QComboBox" name="ComboLEDs"/>
-    </item>
-   </layout>
-  </widget>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBDialog2/OpenRGBDialog2.cpp b/qt/OpenRGBDialog2/OpenRGBDialog2.cpp
deleted file mode 100644
index bcad06c8..00000000
--- a/qt/OpenRGBDialog2/OpenRGBDialog2.cpp
+++ /dev/null
@@ -1,1757 +0,0 @@
-﻿/*---------------------------------------------------------*\
-| OpenRGBDialog2.cpp                                        |
-|                                                           |
-|   User interface for OpenRGB main window                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <string>
-#include <functional>
-#include "OpenRGBDialog2.h"
-#include "LogManager.h"
-#include "PluginManager.h"
-#include "OpenRGBDevicePage.h"
-#include "OpenRGBDeviceInfoPage.h"
-#include "OpenRGBServerInfoPage.h"
-#include "OpenRGBConsolePage.h"
-#include "OpenRGBPluginContainer.h"
-#include "OpenRGBProfileSaveDialog.h"
-#include "ResourceManager.h"
-#include "SettingsManager.h"
-#include "TabLabel.h"
-#include "OpenRGBZonesBulkResizer.h"
-#include "OpenRGBThemeManager.h"
-#include <QLabel>
-#include <QTabBar>
-#include <QMessageBox>
-#include <QCloseEvent>
-#include <QStyleFactory>
-#include "OpenRGBFont.h"
-
-#ifdef __APPLE__
-#include "macutils.h"
-#endif
-
-using namespace Ui;
-
-static int GetIcon(device_type type)
-{
-    /*-----------------------------------------------------*\
-    | Return the icon int value for the given device        |
-    | type value                                            |
-    \*-----------------------------------------------------*/
-    int icon;
-
-    switch(type)
-    {
-    case DEVICE_TYPE_ACCESSORY:
-        icon = OpenRGBFont::usb;
-        break;
-    case DEVICE_TYPE_MOTHERBOARD:
-        icon = OpenRGBFont::mainboard;
-        break;
-    case DEVICE_TYPE_DRAM:
-        icon = OpenRGBFont::dram;
-        break;
-    case DEVICE_TYPE_GPU:
-        icon = OpenRGBFont::gpu;
-        break;
-    case DEVICE_TYPE_COOLER:
-        icon = OpenRGBFont::cooler;
-        break;
-    case DEVICE_TYPE_LEDSTRIP:
-        icon = OpenRGBFont::ledstrip;
-        break;
-    case DEVICE_TYPE_KEYBOARD:
-        icon = OpenRGBFont::keyboard;
-        break;
-    case DEVICE_TYPE_MICROPHONE:
-        icon = OpenRGBFont::mic;
-        break;
-    case DEVICE_TYPE_MOUSE:
-        icon = OpenRGBFont::mouse;
-        break;
-    case DEVICE_TYPE_MOUSEMAT:
-        icon = OpenRGBFont::mousemat;
-        break;
-    case DEVICE_TYPE_HEADSET:
-        icon = OpenRGBFont::headset;
-        break;
-    case DEVICE_TYPE_HEADSET_STAND:
-        icon = OpenRGBFont::headsetstand;
-        break;
-    case DEVICE_TYPE_GAMEPAD:
-        icon = OpenRGBFont::gamepad;
-        break;
-    case DEVICE_TYPE_LIGHT:
-        icon = OpenRGBFont::bulb;
-        break;
-    case DEVICE_TYPE_SPEAKER:
-        icon = OpenRGBFont::music_speaker;
-        break;
-    case DEVICE_TYPE_VIRTUAL:
-        icon = OpenRGBFont::virtual_controller;
-        break;
-    case DEVICE_TYPE_STORAGE:
-        icon = OpenRGBFont::drive;
-        break;
-    case DEVICE_TYPE_CASE:
-        icon = OpenRGBFont::pc_case;
-        break;
-    case DEVICE_TYPE_KEYPAD:
-        icon = OpenRGBFont::keypad;
-        break;
-    default:
-        icon = OpenRGBFont::unknown;
-        break;
-    }
-
-    return icon;
-}
-
-static void UpdateDeviceListCallback(void * this_ptr)
-{
-    OpenRGBDialog2 * this_obj = (OpenRGBDialog2 *)this_ptr;
-
-    QMetaObject::invokeMethod(this_obj, "onDeviceListUpdated", Qt::QueuedConnection);
-}
-
-static void UpdateDetectionProgressCallback(void * this_ptr)
-{
-    OpenRGBDialog2 * this_obj = (OpenRGBDialog2 *)this_ptr;
-
-    QMetaObject::invokeMethod(this_obj, "onDetectionProgressUpdated", Qt::QueuedConnection);
-}
-
-static void CreatePluginCallback(void * this_ptr, OpenRGBPluginEntry* plugin)
-{
-    OpenRGBDialog2 * this_obj = (OpenRGBDialog2 *)this_ptr;
-
-    this_obj->AddPlugin(plugin);
-}
-
-static void DeletePluginCallback(void * this_ptr, OpenRGBPluginEntry* plugin)
-{
-    OpenRGBDialog2 * this_obj = (OpenRGBDialog2 *)this_ptr;
-
-    this_obj->RemovePlugin(plugin);
-}
-
-static void DetectionEndedCallback(void * this_ptr)
-{
-    OpenRGBDialog2 * this_obj = (OpenRGBDialog2 *)this_ptr;
-
-    QMetaObject::invokeMethod(this_obj, "onDetectionEnded", Qt::QueuedConnection);
-}
-
-static void DialogShowCallback(void * this_ptr, PLogMessage msg)
-{
-    OpenRGBDialog2 * this_obj = (OpenRGBDialog2 *)this_ptr;
-
-    this_obj->SetDialogMessage(msg);
-    QMetaObject::invokeMethod(this_obj, "onShowDialogMessage", Qt::QueuedConnection);
-}
-
-
-bool OpenRGBDialog2::IsMinimizeOnClose()
-{
-    json ui_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-
-    if(ui_settings.contains("minimize_on_close"))
-    {
-        return ui_settings["minimize_on_close"];
-    }
-
-    return false;
-}
-
-OpenRGBDialog2::OpenRGBDialog2(QWidget *parent) : QMainWindow(parent), ui(new OpenRGBDialog2Ui)
-{
-    ui->setupUi(this);
-
-    /*-----------------------------------------------------*\
-    | Set window icon                                       |
-    \*-----------------------------------------------------*/
-    QIcon logo(":org.openrgb.OpenRGB.png");
-    setWindowIcon(logo);
-
-    /*-----------------------------------------------------*\
-    | Set window geometry from config (if available)        |
-    \*-----------------------------------------------------*/
-    SettingsManager*    settings_manager    = ResourceManager::get()->GetSettingsManager();
-    std::string         ui_string           = "UserInterface";
-    json                ui_settings;
-    bool                new_settings_keys   = false;
-
-    ui_settings = settings_manager->GetSettings(ui_string);
-
-    if(ui_settings.contains("show_led_view") && ui_settings["show_led_view"])
-    {
-        ShowLEDView();
-    }
-
-    /*-----------------------------------------------------*\
-    | If geometry info doesn't exist, write it to config    |
-    \*-----------------------------------------------------*/
-    if(!ui_settings.contains("geometry"))
-    {
-        json geometry_settings;
-
-        geometry_settings["load_geometry"]  = false;
-        geometry_settings["save_on_exit"]   = false;
-        geometry_settings["x"]              = 0;
-        geometry_settings["y"]              = 0;
-        geometry_settings["width"]          = 0;
-        geometry_settings["height"]         = 0;
-
-        ui_settings["geometry"] = geometry_settings;
-        new_settings_keys       = true;
-    }
-
-    /*-----------------------------------------------------*\
-    | If geometry information exists in settings, apply it  |
-    \*-----------------------------------------------------*/
-    bool load_geometry = false;
-
-    if(ui_settings["geometry"].contains("load_geometry"))
-    {
-        load_geometry = ui_settings["geometry"]["load_geometry"].get<bool>();
-    }
-
-    if(load_geometry)
-    {
-        QRect set_window;
-
-        /*-----------------------------------------------------*\
-        | x and y can be set independent of width and height    |
-        | QT attempts to clamp these values in case the user    |
-        | enters invalid numbers                                |
-        \*-----------------------------------------------------*/
-        if( ui_settings["geometry"].contains("x")
-         && ui_settings["geometry"].contains("y"))
-        {
-            set_window.setX(ui_settings["geometry"]["x"].get<int>());
-            set_window.setY(ui_settings["geometry"]["y"].get<int>());
-        }
-
-        if( ui_settings["geometry"].contains("width")
-         && ui_settings["geometry"].contains("height"))
-        {
-            set_window.setWidth(ui_settings["geometry"]["width"].get<int>());
-            set_window.setHeight(ui_settings["geometry"]["height"].get<int>());
-        }
-
-        setGeometry(set_window);
-    }
-
-    /*-----------------------------------------------------*\
-    | If autoload_profiles doesn't exist or has missing     |
-    | profiles, write it to config                          |
-    \*-----------------------------------------------------*/
-    json autoload_profiles;
-    if(ui_settings.contains("autoload_profiles"))
-    {
-        autoload_profiles = ui_settings["autoload_profiles"];
-    }
-    else
-    {
-        new_settings_keys                = true;
-    }
-
-    if(!autoload_profiles.contains("exit_profile"))
-    {
-        json profile;
-        profile["enabled"]                = false;
-        profile["name"]                   = "";
-        autoload_profiles["exit_profile"] = profile;
-        new_settings_keys                 = true;
-    }
-
-    if(!autoload_profiles.contains("resume_profile"))
-    {
-        json profile;
-        profile["enabled"]                  = false;
-        profile["name"]                     = "";
-        autoload_profiles["resume_profile"] = profile;
-        new_settings_keys                   = true;
-    }
-
-    if(!autoload_profiles.contains("suspend_profile"))
-    {
-        json profile;
-        profile["enabled"]                   = false;
-        profile["name"]                      = "";
-        autoload_profiles["suspend_profile"] = profile;
-        new_settings_keys                    = true;
-    }
-
-    ui_settings["autoload_profiles"] = autoload_profiles;
-
-    /*-----------------------------------------------------*\
-    | Register detection progress callback with resource    |
-    | manager                                               |
-    \*-----------------------------------------------------*/
-    ResourceManager::get()->RegisterDetectionProgressCallback(UpdateDetectionProgressCallback, this);
-    ResourceManager::get()->RegisterDeviceListChangeCallback(UpdateDeviceListCallback, this);
-    ResourceManager::get()->RegisterDetectionEndCallback(DetectionEndedCallback, this);
-
-    /*-----------------------------------------------------*\
-    | Register dialog show callback with log manager        |
-    \*-----------------------------------------------------*/
-    LogManager::get()->RegisterDialogShowCallback(DialogShowCallback, this);
-
-    /*-----------------------------------------------------*\
-    | Initialize page pointers                              |
-    \*-----------------------------------------------------*/
-    ClientInfoPage  = NULL;
-    SMBusToolsPage  = NULL;
-    SoftInfoPage    = NULL;
-
-    onDetectionProgressUpdated();
-
-    ui->DetectionProgressBar->setRange(0, 100);
-    ui->DetectionProgressBar->setValue(0);
-    ui->DetectionProgressBar->setTextVisible(true);
-    ui->DetectionProgressBar->setFormat("");
-    ui->DetectionProgressBar->setAlignment(Qt::AlignCenter);
-
-    /*-----------------------------------------------------*\
-    | Set up Save Profile button action and menu            |
-    \*-----------------------------------------------------*/
-    QMenu* saveProfileMenu = new QMenu(this);
-    saveProfileMenu->addAction(ui->ActionSaveProfileAs);
-
-    ui->ButtonSaveProfile->setMenu(saveProfileMenu);
-    ui->ButtonSaveProfile->setDefaultAction(ui->ActionSaveProfile);
-
-    /*-----------------------------------------------------*\
-    | Set up tray icon menu                                 |
-    \*-----------------------------------------------------*/
-    trayIconMenu = new QMenu( this );
-
-    trayIcon = new QSystemTrayIcon(this);
-
-    QAction* actionShowHide = new QAction(tr("Show/Hide"), this);
-    connect(actionShowHide, SIGNAL(triggered()), this, SLOT(on_ShowHide()));
-    trayIconMenu->addAction(actionShowHide);
-
-    profileMenu = new QMenu(tr("Profiles"), this);
-
-    trayIconMenu->addMenu(profileMenu);
-
-    QMenu* quickColorsMenu = new QMenu(tr("Quick Colors"), this);
-
-    QAction* actionQuickRed = new QAction(tr("Red"), this);
-    connect(actionQuickRed, SIGNAL(triggered()), this, SLOT(on_QuickRed()));
-    quickColorsMenu->addAction(actionQuickRed);
-
-    QAction* actionQuickYellow = new QAction(tr("Yellow"), this);
-    connect(actionQuickYellow, SIGNAL(triggered()), this, SLOT(on_QuickYellow()));
-    quickColorsMenu->addAction(actionQuickYellow);
-
-    QAction* actionQuickGreen = new QAction(tr("Green"), this);
-    connect(actionQuickGreen, SIGNAL(triggered()), this, SLOT(on_QuickGreen()));
-    quickColorsMenu->addAction(actionQuickGreen);
-
-    QAction* actionQuickCyan = new QAction(tr("Cyan"), this);
-    connect(actionQuickCyan, SIGNAL(triggered()), this, SLOT(on_QuickCyan()));
-    quickColorsMenu->addAction(actionQuickCyan);
-
-    QAction* actionQuickBlue = new QAction(tr("Blue"), this);
-    connect(actionQuickBlue, SIGNAL(triggered()), this, SLOT(on_QuickBlue()));
-    quickColorsMenu->addAction(actionQuickBlue);
-
-    QAction* actionQuickMagenta = new QAction(tr("Magenta"), this);
-    connect(actionQuickMagenta, SIGNAL(triggered()), this, SLOT(on_QuickMagenta()));
-    quickColorsMenu->addAction(actionQuickMagenta);
-
-    QAction* actionQuickWhite = new QAction(tr("White"), this);
-    connect(actionQuickWhite, SIGNAL(triggered()), this, SLOT(on_QuickWhite()));
-    quickColorsMenu->addAction(actionQuickWhite);
-
-    trayIconMenu->addMenu(quickColorsMenu);
-
-    QAction* actionLightsOff = new QAction(tr("Lights Off"), this);
-    actionLightsOff->setObjectName("ActionLightsOff");
-    connect(actionLightsOff, SIGNAL(triggered()), this, SLOT(on_LightsOff()));
-    trayIconMenu->addAction(actionLightsOff);
-
-    actionExit = new QAction(tr("Exit"), this );
-    connect( actionExit, SIGNAL( triggered() ), this, SLOT( on_Exit() ));
-    trayIconMenu->addAction(actionExit);
-
-    /*-------------------------------------------------*\
-    | If tray minimize flag isn't in the config, set    |
-    | default value to false                            |
-    \*-------------------------------------------------*/
-    if(!ui_settings.contains("minimize_on_close"))
-    {
-        ui_settings["minimize_on_close"] = false;
-        new_settings_keys                = true;
-    }
-
-    connect(trayIcon,SIGNAL(activated(QSystemTrayIcon::ActivationReason)), this, SLOT(on_ReShow(QSystemTrayIcon::ActivationReason)));
-
-    /*-------------------------------------------------*\
-    | If Greyscale Tray Icon flag is not set in config  |
-    | then set the default value to false               |
-    \*-------------------------------------------------*/
-    if(!ui_settings.contains("greyscale_tray_icon"))
-    {
-        ui_settings["greyscale_tray_icon"] = false;
-        new_settings_keys                  = true;
-    }
-
-    /*-----------------------------------------------------*\
-    | If greyscale tray icon exists in settings, apply it   |
-    |   or else set the icon to the default window logo     |
-    \*-----------------------------------------------------*/
-    if(ui_settings.contains("greyscale_tray_icon"))
-    {
-        SetTrayIcon(ui_settings["greyscale_tray_icon"].get<bool>());
-    }
-
-    /*-----------------------------------------------------*\
-    | Save the settings if new default values have been     |
-    | inserted                                              |
-    \*-----------------------------------------------------*/
-    if(new_settings_keys)
-    {
-        settings_manager->SetSettings(ui_string, ui_settings);
-        settings_manager->SaveSettings();
-    }
-
-    trayIcon->setToolTip("OpenRGB");
-    trayIcon->setContextMenu(trayIconMenu);
-    trayIcon->show();
-
-    OpenRGBThemeManager::Init();
-
-    /*-----------------------------------------------------*\
-    | Update the profile list                               |
-    \*-----------------------------------------------------*/
-    UpdateProfileList();
-
-    /*-----------------------------------------------------*\
-    | Update the device list and make sure the              |
-    | ProgressBar gets a proper value                       |
-    \*-----------------------------------------------------*/
-    UpdateDevicesList();
-
-    /*-----------------------------------------------------*\
-    | Add Client Tab                                        |
-    \*-----------------------------------------------------*/
-    AddClientTab();
-
-    /*-----------------------------------------------------*\
-    | Add Server Tab                                        |
-    \*-----------------------------------------------------*/
-    AddServerTab();
-
-    /*-----------------------------------------------------*\
-    | Add the Software Info page                            |
-    \*-----------------------------------------------------*/
-    AddSoftwareInfoPage();
-
-    /*-----------------------------------------------------*\
-    | Add the settings page                                 |
-    \*-----------------------------------------------------*/
-    AddSettingsPage();
-
-    /*-----------------------------------------------------*\
-    | Add the Supported Devices page                        |
-    \*-----------------------------------------------------*/
-    AddSupportedDevicesPage();
-
-    /*-----------------------------------------------------*\
-    | Initialize the plugin manager                         |
-    \*-----------------------------------------------------*/
-    plugin_manager = new PluginManager();
-    plugin_manager->RegisterAddPluginCallback(&CreatePluginCallback, this);
-    plugin_manager->RegisterRemovePluginCallback(&DeletePluginCallback, this);
-
-    /*-----------------------------------------------------*\
-    | Add the Plugins page                                  |
-    \*-----------------------------------------------------*/
-    AddPluginsPage();
-
-    /*-----------------------------------------------------*\
-    | Add the Serial settings page                          |
-    \*-----------------------------------------------------*/
-    AddSerialSettingsPage();
-
-    /*-----------------------------------------------------*\
-    | Add the SMBus Tools page if enabled                   |
-    \*-----------------------------------------------------*/
-    if(ShowI2CTools)
-    {
-        AddI2CToolsPage();
-    }
-
-    /*-----------------------------------------------------*\
-    | If log console is enabled in settings, enable it      |
-    \*-----------------------------------------------------*/
-    json log_manager_settings = settings_manager->GetSettings("LogManager");
-
-    bool log_console_enabled = false;
-    if(log_manager_settings.contains("log_console"))
-    {
-        log_console_enabled = log_manager_settings["log_console"];
-    }
-
-    /*-----------------------------------------------------*\
-    | Add the log console page                              |
-    \*-----------------------------------------------------*/
-    if(log_console_enabled)
-    {
-        AddConsolePage();
-    }
-
-    /*-----------------------------------------------------*\
-    | Connect aboutToQuit signal to handleAboutToQuit       |
-    \*-----------------------------------------------------*/
-    connect(qApp, &QCoreApplication::aboutToQuit, this, &OpenRGBDialog2::handleAboutToQuit);
-
-}
-
-OpenRGBDialog2::~OpenRGBDialog2()
-{
-    /*-----------------------------------------------------*\
-    | Write window geometry to config (if enabled)          |
-    \*-----------------------------------------------------*/
-    SettingsManager*    settings_manager    = ResourceManager::get()->GetSettingsManager();
-    std::string         ui_string           = "UserInterface";
-    json                ui_settings;
-
-    ui_settings = settings_manager->GetSettings(ui_string);
-
-    if(ui_settings.contains("geometry"))
-    {
-        if( ui_settings["geometry"].contains("load_geometry")
-         && ui_settings["geometry"].contains("save_on_exit"))
-        {
-            if( ui_settings["geometry"]["load_geometry"].get<bool>()
-            && ui_settings["geometry"]["save_on_exit"].get<bool>())
-            {
-                ui_settings["geometry"]["x"]                = geometry().x();
-                ui_settings["geometry"]["y"]                = geometry().y();
-                ui_settings["geometry"]["width"]            = geometry().width();
-                ui_settings["geometry"]["height"]           = geometry().height();
-
-                settings_manager->SetSettings(ui_string, ui_settings);
-                settings_manager->SaveSettings();
-            }
-        }
-    }
-
-    delete ui;
-}
-
-
-void OpenRGBDialog2::handleAboutToQuit()
-{
-    QCloseEvent* closeEvent = new QCloseEvent;
-    this->closeEvent(closeEvent);
-    delete closeEvent;
-}
-
-
-void OpenRGBDialog2::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-        for(int i = 0; i < ui->MainTabBar->count(); i++)
-        {
-            /*-----------------------------------------------------*\
-            | if the objectName is either of the SDK tabs           |
-            |   then translate tab text (TODO: improve workaround)  |
-            \*-----------------------------------------------------*/
-            std::string label = ui->MainTabBar->widget(i)->objectName().toStdString();
-
-            if(label.substr(0,3) == "SDK")
-            {
-                ui->MainTabBar->setTabText(i, tr(label.c_str()));
-            }
-        }
-    }
-}
-
-void OpenRGBDialog2::closeEvent(QCloseEvent *event)
-{
-    ResourceManager::get()->WaitForDeviceDetection();
-
-    if (IsMinimizeOnClose() && !this->isHidden())
-    {
-#ifdef __APPLE__
-        MacUtils::ToggleApplicationDocklessState(false);
-#endif
-        hide();
-        event->ignore();
-    }
-    else
-    {
-        plugin_manager->UnloadPlugins();
-
-        if(SelectConfigProfile("exit_profile"))
-        {
-            on_ButtonLoadProfile_clicked();
-
-            /*-----------------------------------------------------*\
-            | Pause briefly to ensure that all profiles are loaded. |
-            \*-----------------------------------------------------*/
-            std::this_thread::sleep_for(std::chrono::milliseconds(250));
-        }
-
-        event->accept();
-        QApplication::exit(0);
-    }
-}
-
-bool OpenRGBDialog2::SelectConfigProfile(const std::string name)
-{
-    /*-----------------------------------------------------*\
-    | Set automatic profile (if enabled and valid)          |
-    \*-----------------------------------------------------*/
-    json ui_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-
-    if(ui_settings.contains("autoload_profiles"))
-    {
-        json autoload_profiles = ui_settings["autoload_profiles"];
-        if(autoload_profiles.contains(name))
-        {
-            json profile = autoload_profiles[name];
-            if (profile.contains("enabled") && profile["enabled"].get<bool>() && profile.contains("name"))
-            {
-                /*-----------------------------------------------------*\
-                | Set the profile name from settings and check the      |
-                |   profile combobox for a match                        |
-                \*-----------------------------------------------------*/
-                std::string profile_name = profile["name"].get<std::string>();
-                int profile_index        = ui->ProfileBox->findText(QString::fromStdString(profile_name));
-
-                if(profile_index > -1)
-                {
-                    ui->ProfileBox->setCurrentIndex(profile_index);
-                    return true;
-                }
-            }
-        }
-    }
-    return false;
-}
-
-void OpenRGBDialog2::AddPluginsPage()
-{
-    /*-----------------------------------------------------*\
-    | Create the Plugins page                               |
-    \*-----------------------------------------------------*/
-    PluginsPage = new OpenRGBPluginsPage(plugin_manager);
-
-    ui->SettingsTabBar->addTab(PluginsPage, "");
-
-    /*-----------------------------------------------------*\
-    | Create the tab label                                  |
-    \*-----------------------------------------------------*/
-    TabLabel* PluginTabLabel = new TabLabel(OpenRGBFont::extension, tr("Plugins"), (char *)"Plugins", (char *)context);
-
-    ui->SettingsTabBar->tabBar()->setTabButton(ui->SettingsTabBar->tabBar()->count() - 1, QTabBar::LeftSide, PluginTabLabel);
-}
-
-void OpenRGBDialog2::AddSoftwareInfoPage()
-{
-    /*-----------------------------------------------------*\
-    | Create the Software Information page                  |
-    \*-----------------------------------------------------*/
-    SoftInfoPage = new OpenRGBSoftwareInfoPage();
-
-    ui->InformationTabBar->addTab(SoftInfoPage, "");
-
-    /*-----------------------------------------------------*\
-    | Create the tab label                                  |
-    \*-----------------------------------------------------*/
-    TabLabel* SoftwareTabLabel = new TabLabel(OpenRGBFont::info, tr("Software"), (char *)"Software", (char *)context);
-
-    ui->InformationTabBar->tabBar()->setTabButton(ui->InformationTabBar->tabBar()->count() - 1, QTabBar::LeftSide, SoftwareTabLabel);
-}
-
-void OpenRGBDialog2::AddSupportedDevicesPage()
-{
-    /*-----------------------------------------------------*\
-    | Create the Supported Devices page                     |
-    \*-----------------------------------------------------*/
-    SupportedPage = new OpenRGBSupportedDevicesPage();
-
-    ui->SettingsTabBar->addTab(SupportedPage, "");
-
-    /*-----------------------------------------------------*\
-    | Create the tab label                                  |
-    \*-----------------------------------------------------*/
-    TabLabel* SupportedTabLabel = new TabLabel(OpenRGBFont::controller, tr("Supported Devices"), (char *)"Supported Devices", (char *)context);
-
-    ui->SettingsTabBar->tabBar()->setTabButton(ui->SettingsTabBar->tabBar()->count() - 1, QTabBar::LeftSide, SupportedTabLabel);
-}
-
-void OpenRGBDialog2::AddSettingsPage()
-{
-    /*-----------------------------------------------------*\
-    | Create the Settings page                              |
-    \*-----------------------------------------------------*/
-    SettingsPage = new OpenRGBSettingsPage();
-
-    ui->SettingsTabBar->addTab(SettingsPage, "");
-
-    /*-----------------------------------------------------*\
-    | Create the tab label                                  |
-    \*-----------------------------------------------------*/
-    TabLabel* SettingsTabLabel = new TabLabel(OpenRGBFont::options, tr("General Settings"), (char *)"General Settings", (char *)context);
-
-    ui->SettingsTabBar->tabBar()->setTabButton(ui->SettingsTabBar->tabBar()->count() - 1, QTabBar::LeftSide, SettingsTabLabel);
-
-    /*-----------------------------------------------------*\
-    | Connect signals to slots                              |
-    \*-----------------------------------------------------*/
-    connect(SettingsPage, SIGNAL(TrayIconChanged(bool)), this, SLOT(SetTrayIcon(bool)));
-    connect(this, SIGNAL(ProfileListChanged()), SettingsPage, SLOT(UpdateProfiles()));
-}
-
-void OpenRGBDialog2::AddSerialSettingsPage()
-{
-    /*-----------------------------------------------------*\
-    | Create the Settings page                              |
-    \*-----------------------------------------------------*/
-    SerialSettingsPage = new OpenRGBSerialSettingsPage();
-
-    ui->SettingsTabBar->addTab(SerialSettingsPage, "");
-
-    /*-----------------------------------------------------*\
-    | Create the tab label                                  |
-    \*-----------------------------------------------------*/
-    TabLabel* SerialSettingsTabLabel = new TabLabel(OpenRGBFont::serial, tr("Serial Devices"), (char *)"Serial Devices", (char *)context);
-
-    ui->SettingsTabBar->tabBar()->setTabButton(ui->SettingsTabBar->tabBar()->count() - 1, QTabBar::LeftSide, SerialSettingsTabLabel);
-}
-
-void OpenRGBDialog2::AddPlugin(OpenRGBPluginEntry* plugin)
-{
-    /*-----------------------------------------------------*\
-    | Create the tab label                                  |
-    \*-----------------------------------------------------*/
-    TabLabel* PluginTabLabel = new TabLabel(OpenRGBFont::extension, QString::fromStdString(plugin->info.Label), (char *)plugin->info.Label.c_str(), (char *)context);
-
-    /*-----------------------------------------------------*\
-    | Place plugin as its own top level tab                 |
-    \*-----------------------------------------------------*/
-    if(plugin->info.Location == OPENRGB_PLUGIN_LOCATION_TOP)
-    {
-        QWidget* NewPluginTab = plugin->plugin->GetWidget();
-
-        plugin->widget = NewPluginTab;
-
-        OpenRGBPluginContainer* NewPluginContainer = new OpenRGBPluginContainer(NewPluginTab, this);
-
-        ui->MainTabBar->addTab(NewPluginContainer,QString().fromStdString(plugin->info.Label));
-    }
-    /*-----------------------------------------------------*\
-    | Place plugin in the Devices tab                       |
-    \*-----------------------------------------------------*/
-    else if(plugin->info.Location == OPENRGB_PLUGIN_LOCATION_DEVICES)
-    {
-        QWidget* NewPluginTab = plugin->plugin->GetWidget();
-
-        plugin->widget = NewPluginTab;
-
-        OpenRGBPluginContainer* NewPluginContainer = new OpenRGBPluginContainer(NewPluginTab, this);
-
-        ui->DevicesTabBar->addTab(NewPluginContainer," ");
-
-        ui->DevicesTabBar->tabBar()->setTabButton((ui->DevicesTabBar->count() - 1),QTabBar::LeftSide , PluginTabLabel);
-    }
-    /*-----------------------------------------------------*\
-    | Place plugin in the Information tab                   |
-    \*-----------------------------------------------------*/
-    else if(plugin->info.Location == OPENRGB_PLUGIN_LOCATION_INFORMATION)
-    {
-        QWidget* NewPluginTab = plugin->plugin->GetWidget();
-
-        plugin->widget = NewPluginTab;
-
-        OpenRGBPluginContainer* NewPluginContainer = new OpenRGBPluginContainer(NewPluginTab, this);
-
-        ui->InformationTabBar->addTab(NewPluginContainer," ");
-
-        ui->InformationTabBar->tabBar()->setTabButton((ui->InformationTabBar->count() - 1),QTabBar::LeftSide , PluginTabLabel);
-    }
-    /*-----------------------------------------------------*\
-    | Place plugin in the Settings tab                      |
-    \*-----------------------------------------------------*/
-    else if(plugin->info.Location == OPENRGB_PLUGIN_LOCATION_SETTINGS)
-    {
-        QWidget* NewPluginTab = plugin->plugin->GetWidget();
-
-        plugin->widget = NewPluginTab;
-
-        OpenRGBPluginContainer* NewPluginContainer = new OpenRGBPluginContainer(NewPluginTab, this);
-
-        ui->SettingsTabBar->addTab(NewPluginContainer," ");
-
-        ui->SettingsTabBar->tabBar()->setTabButton((ui->SettingsTabBar->count() - 1),QTabBar::LeftSide , PluginTabLabel);
-    }
-    /*-----------------------------------------------------*\
-    | Display an error message if the plugin does not       |
-    | specify a valid location                              |
-    \*-----------------------------------------------------*/
-    else
-    {
-        std::cout << ("Cannot load plugin '" + plugin->info.Name + "' as it does not specify a valid location.\n");
-    }
-
-    QMenu* NewTrayMenu = plugin->plugin->GetTrayMenu();
-
-    plugin->traymenu = NewTrayMenu;
-
-    if(NewTrayMenu)
-    {
-        trayIconMenu->insertMenu(actionExit, NewTrayMenu);
-    }
-}
-
-void OpenRGBDialog2::RemovePlugin(OpenRGBPluginEntry* plugin)
-{
-    /*-----------------------------------------------------*\
-    | Remove plugin's tray menu                             |
-    \*-----------------------------------------------------*/
-    if(plugin->traymenu)
-    {
-        QWidget* plugin_tray_entry = trayIconMenu->find(plugin->traymenu->winId());
-
-        if(plugin_tray_entry)
-        {
-            trayIconMenu->removeAction(plugin->traymenu->menuAction());
-        }
-
-        //delete plugin->traymenu;
-    }
-
-    /*-----------------------------------------------------*\
-    | Find plugin's container                               |
-    \*-----------------------------------------------------*/
-    QTabWidget *plugin_parent_widget = nullptr;
-
-    switch(plugin->info.Location)
-    {
-        case OPENRGB_PLUGIN_LOCATION_TOP:
-            plugin_parent_widget = ui->MainTabBar;
-            break;
-        case OPENRGB_PLUGIN_LOCATION_DEVICES:
-            plugin_parent_widget = ui->DevicesTabBar;
-            break;
-        case OPENRGB_PLUGIN_LOCATION_INFORMATION:
-            plugin_parent_widget = ui->InformationTabBar;
-            break;
-        case OPENRGB_PLUGIN_LOCATION_SETTINGS:
-            plugin_parent_widget = ui->InformationTabBar;
-            break;
-        default:
-            break;
-    }
-
-    /*-----------------------------------------------------*\
-    | Remove plugin from its container                      |
-    \*-----------------------------------------------------*/
-    if(plugin_parent_widget != nullptr)
-    {
-        for(int tab_idx = 0; tab_idx < plugin_parent_widget->count(); tab_idx++)
-        {
-            if(dynamic_cast<OpenRGBPluginContainer*>(plugin_parent_widget->widget(tab_idx)) != nullptr)
-            {
-                if(dynamic_cast<OpenRGBPluginContainer*>(plugin_parent_widget->widget(tab_idx))->plugin_widget == plugin->widget)
-                {
-                    plugin_parent_widget->removeTab(tab_idx);
-                    //delete plugin->widget;
-                    break;
-                }
-            }
-        }
-    }
-}
-
-void OpenRGBDialog2::AddI2CToolsPage()
-{
-    ShowI2CTools = true;
-
-    /*-----------------------------------------------------*\
-    | Create the I2C Tools page if it doesn't exist yet     |
-    \*-----------------------------------------------------*/
-    SMBusToolsPage = new OpenRGBSystemInfoPage(ResourceManager::get()->GetI2CBusses());
-
-    /*-----------------------------------------------------*\
-    | Create the I2C Tools tab in the Information bar       |
-    \*-----------------------------------------------------*/
-    ui->InformationTabBar->addTab(SMBusToolsPage, "");
-
-    /*-----------------------------------------------------*\
-    | Create the tab label                                  |
-    \*-----------------------------------------------------*/
-    TabLabel* SMBusToolsTabLabel = new TabLabel(OpenRGBFont::toolbox, tr("SMBus Tools"), (char *)"SMBus Tools", (char *)context);
-
-    ui->InformationTabBar->tabBar()->setTabButton(ui->InformationTabBar->tabBar()->count() - 1, QTabBar::LeftSide, SMBusToolsTabLabel);
-}
-
-void OpenRGBDialog2::AddClientTab()
-{
-    /*-----------------------------------------------------*\
-    | Add client information tab if it doesn't exist yet    |
-    \*-----------------------------------------------------*/
-    if(ClientInfoPage == NULL)
-    {
-        ClientInfoPage = new OpenRGBClientInfoPage();
-        ClientInfoPage->setObjectName(QString("SDK Client"));
-        ui->MainTabBar->insertTab(2, ClientInfoPage, tr("SDK Client"));
-    }
-}
-
-void OpenRGBDialog2::AddClient(NetworkClient* new_client)
-{
-    /*-----------------------------------------------------*\
-    | Add a client to the client information page           |
-    \*-----------------------------------------------------*/
-    if(ClientInfoPage != NULL)
-    {
-        ClientInfoPage->AddClient(new_client);
-    }
-}
-
-void OpenRGBDialog2::AddServerTab()
-{
-    /*-----------------------------------------------------*\
-    | Add server information tab if there is a server       |
-    \*-----------------------------------------------------*/
-    OpenRGBServerInfoPage *ServerInfoPage = new OpenRGBServerInfoPage(ResourceManager::get()->GetServer());
-    ServerInfoPage->setObjectName(QString("SDK Server"));
-    ui->MainTabBar->insertTab(2, ServerInfoPage, tr("SDK Server"));
-}
-
-void OpenRGBDialog2::ClearDevicesList()
-{
-    for(int tab_idx = 0; tab_idx < ui->DevicesTabBar->count(); tab_idx++)
-    {
-        if(dynamic_cast<OpenRGBPluginContainer*>(ui->DevicesTabBar->widget(tab_idx)) == nullptr)
-        {
-            delete ui->DevicesTabBar->widget(tab_idx);
-            ui->DevicesTabBar->removeTab(tab_idx);
-        }
-    }
-
-    for(int tab_idx = 0; tab_idx < ui->InformationTabBar->count(); tab_idx++)
-    {
-        if(dynamic_cast<OpenRGBPluginContainer*>(ui->InformationTabBar->widget(tab_idx)) == nullptr)
-        {
-            delete ui->InformationTabBar->widget(tab_idx);
-            ui->InformationTabBar->removeTab(tab_idx);
-        }
-    }
-}
-
-void OpenRGBDialog2::UpdateDevicesList()
-{
-    std::vector<RGBController *> controllers = ResourceManager::get()->GetRGBControllers();
-
-    /*-----------------------------------------------------*\
-    | Loop through each controller in the list.             |
-    \*-----------------------------------------------------*/
-    for(unsigned int controller_idx = 0; controller_idx < controllers.size(); controller_idx++)
-    {
-        /*-----------------------------------------------------*\
-        | Loop through each tab in the devices tab bar          |
-        \*-----------------------------------------------------*/
-        bool found = false;
-
-        for(int tab_idx = 0; tab_idx < ui->DevicesTabBar->count(); tab_idx++)
-        {
-            QWidget* page = ui->DevicesTabBar->widget(tab_idx);
-
-            if(dynamic_cast<OpenRGBDevicePage*>(page) != nullptr)
-            {
-                /*-----------------------------------------------------*\
-                | If the current tab matches the current controller,    |
-                | move the tab to the correct position                  |
-                \*-----------------------------------------------------*/
-                if(controllers[controller_idx] == ((OpenRGBDevicePage*)page)->GetController())
-                {
-                    found = true;
-                    ui->DevicesTabBar->tabBar()->moveTab(tab_idx, controller_idx);
-                    break;
-                }
-            }
-        }
-
-        if(!found)
-        {
-            /*-----------------------------------------------------*\
-            | The controller does not have a tab already created    |
-            | Create a new tab and move it to the correct position  |
-            \*-----------------------------------------------------*/
-            OpenRGBDevicePage *NewPage = new OpenRGBDevicePage(controllers[controller_idx]);
-            ui->DevicesTabBar->addTab(NewPage, "");
-
-            /*-----------------------------------------------------*\
-            | Connect the page's Set All button to the Set All slot |
-            \*-----------------------------------------------------*/
-            connect(NewPage,
-                    SIGNAL(SetAllDevices(unsigned char, unsigned char, unsigned char)),
-                    this,
-                    SLOT(on_SetAllDevices(unsigned char, unsigned char, unsigned char)));
-
-            /*-----------------------------------------------------*\
-            | Connect the page's Resize signal to the Save Size slot|
-            \*-----------------------------------------------------*/
-            connect(NewPage,
-                    SIGNAL(SaveSizeProfile()),
-                    this,
-                    SLOT(on_SaveSizeProfile()));
-
-            /*-----------------------------------------------------*\
-            | Create the tab label                                  |
-            \*-----------------------------------------------------*/
-            TabLabel* NewTabLabel = new TabLabel(GetIcon(controllers[controller_idx]->type), QString::fromStdString(controllers[controller_idx]->name), (char *)controllers[controller_idx]->name.c_str(), (char *)context);
-
-            ui->DevicesTabBar->tabBar()->setTabButton(ui->DevicesTabBar->count() - 1, QTabBar::LeftSide, NewTabLabel);
-            ui->DevicesTabBar->tabBar()->setTabToolTip(ui->DevicesTabBar->count() - 1, QString::fromStdString(controllers[controller_idx]->name));
-
-            /*-----------------------------------------------------*\
-            | Now move the new tab to the correct position          |
-            \*-----------------------------------------------------*/
-            ui->DevicesTabBar->tabBar()->moveTab(ui->DevicesTabBar->count() - 1, controller_idx);
-        }
-
-        /*-----------------------------------------------------*\
-        | Loop through each tab in the information tab bar      |
-        \*-----------------------------------------------------*/
-        found = false;
-
-        for(int tab_idx = 0; tab_idx < ui->InformationTabBar->count(); tab_idx++)
-        {
-            /*-----------------------------------------------------*\
-            | If type is a device info page, check it               |
-            \*-----------------------------------------------------*/
-            std::string type_str = ui->InformationTabBar->widget(tab_idx)->metaObject()->className();
-            if(type_str == "Ui::OpenRGBDeviceInfoPage")
-            {
-                OpenRGBDeviceInfoPage* page = (OpenRGBDeviceInfoPage*) ui->InformationTabBar->widget(tab_idx);
-
-                /*-----------------------------------------------------*\
-                | If the current tab matches the current controller,    |
-                | move the tab to the correct position                  |
-                \*-----------------------------------------------------*/
-                if(controllers[controller_idx] == page->GetController())
-                {
-                    found = true;
-                    ui->InformationTabBar->tabBar()->moveTab(tab_idx, controller_idx);
-                    break;
-                }
-            }
-        }
-
-        if(!found)
-        {
-            /*-----------------------------------------------------*\
-            | The controller does not have a tab already created    |
-            | Create a new tab and move it to the correct position  |
-            \*-----------------------------------------------------*/
-            OpenRGBDeviceInfoPage *NewPage = new OpenRGBDeviceInfoPage(controllers[controller_idx]);
-            ui->InformationTabBar->addTab(NewPage, "");
-
-            /*-----------------------------------------------------*\
-            | Create the tab label                                  |
-            \*-----------------------------------------------------*/
-            TabLabel* NewTabLabel = new TabLabel(GetIcon(controllers[controller_idx]->type), QString::fromStdString(controllers[controller_idx]->name), (char *)controllers[controller_idx]->name.c_str(), (char *)context);
-
-            ui->InformationTabBar->tabBar()->setTabButton(ui->InformationTabBar->count() - 1, QTabBar::LeftSide, NewTabLabel);
-            ui->InformationTabBar->tabBar()->setTabToolTip(ui->InformationTabBar->count() - 1, QString::fromStdString(controllers[controller_idx]->name));
-
-            /*-----------------------------------------------------*\
-            | Now move the new tab to the correct position          |
-            \*-----------------------------------------------------*/
-            ui->InformationTabBar->tabBar()->moveTab(ui->InformationTabBar->count() - 1, controller_idx);
-        }
-    }
-
-    /*-----------------------------------------------------*\
-    | Remove all remaining device tabs                      |
-    \*-----------------------------------------------------*/
-    unsigned int tab_count = ui->DevicesTabBar->count();
-    unsigned int base_tab = (unsigned int)controllers.size();
-
-    for(std::size_t tab_idx = controllers.size(); tab_idx < tab_count; tab_idx++)
-    {
-        QWidget* tab_widget = ui->DevicesTabBar->widget(base_tab);
-
-        if(dynamic_cast<OpenRGBPluginContainer*>(tab_widget) == nullptr)
-        {
-            ui->DevicesTabBar->removeTab(base_tab);
-            delete tab_widget;
-        }
-    }
-
-    bool found = true;
-
-    while(found)
-    {
-        found = false;
-
-        /*-----------------------------------------------------*\
-        | Remove all remaining device information tabs, leaving |
-        | other information tabs alone                          |
-        \*-----------------------------------------------------*/
-        for(std::size_t tab_idx = controllers.size(); tab_idx < ui->InformationTabBar->count(); tab_idx++)
-        {
-            std::string type_str = ui->InformationTabBar->widget(base_tab)->metaObject()->className();
-            if(type_str == "Ui::OpenRGBDeviceInfoPage")
-            {
-                found = true;
-                QWidget* tab_widget = ui->InformationTabBar->widget(base_tab);
-
-                ui->InformationTabBar->removeTab(base_tab);
-
-                delete tab_widget;
-                break;
-            }
-            base_tab += 1;
-        }
-    }
-
-    if(device_view_showing)
-    {
-        ShowLEDView();
-    }
-}
-
-void OpenRGBDialog2::SetDialogMessage(PLogMessage msg)
-{
-    dialog_message = QString::fromStdString(msg->buffer);
-}
-
-void OpenRGBDialog2::UpdateProfileList()
-{
-    ProfileManager* profile_manager = ResourceManager::get()->GetProfileManager();
-
-    if(profile_manager != NULL)
-    {
-        /*-----------------------------------------------------*\
-        | Clear profile combo box and tray icon menu            |
-        \*-----------------------------------------------------*/
-        ui->ProfileBox->clear();
-        profileMenu->clear();
-
-        for(std::size_t profile_index = 0; profile_index < profile_manager->profile_list.size(); profile_index++)
-        {
-            /*-----------------------------------------------------*\
-            | Fill in profile combo box                             |
-            \*-----------------------------------------------------*/
-            ui->ProfileBox->addItem(profile_manager->profile_list[profile_index].c_str());
-
-            /*-----------------------------------------------------*\
-            | Fill in profile tray icon menu                        |
-            \*-----------------------------------------------------*/
-            QAction* actionProfileSelected = new QAction(profile_manager->profile_list[profile_index].c_str(), this);
-            actionProfileSelected->setObjectName(profile_manager->profile_list[profile_index].c_str());
-            connect(actionProfileSelected, SIGNAL(triggered()), this, SLOT(on_ProfileSelected()));
-            profileMenu->addAction(actionProfileSelected);
-        }
-    }
-
-    emit ProfileListChanged();
-}
-
-void OpenRGBDialog2::OnSuspend()
-{
-    if(SelectConfigProfile("suspend_profile"))
-    {
-        plugin_manager->UnloadPlugins();
-        on_ButtonLoadProfile_clicked();
-    }
-}
-
-void OpenRGBDialog2::OnResume()
-{
-    if(SelectConfigProfile("resume_profile"))
-    {
-        on_ButtonLoadProfile_clicked();
-    }
-    plugin_manager->LoadPlugins();
-}
-
-void OpenRGBDialog2::on_Exit()
-{
-    /*-----------------------------------------------*\
-    | This is the exit from the tray icon             |
-    | NOT the main exit button (top right on Windows) |
-    |                                                 |
-    | The hide is important, otherwise it won't close |
-    | when minimize on close is enabled               |
-    \*-----------------------------------------------*/
-    this->hide();
-    trayIcon->hide();
-    close();
-}
-
-void OpenRGBDialog2::on_LightsOff()
-{
-    on_SetAllDevices(0x00, 0x00, 0x00);
-}
-
-void OpenRGBDialog2::on_QuickRed()
-{
-    on_SetAllDevices(0xFF, 0x00, 0x00);
-}
-
-void OpenRGBDialog2::on_QuickYellow()
-{
-    on_SetAllDevices(0xFF, 0xFF, 0x00);
-}
-
-void OpenRGBDialog2::on_QuickGreen()
-{
-    on_SetAllDevices(0x00, 0xFF, 0x00);
-}
-
-void OpenRGBDialog2::on_QuickCyan()
-{
-    on_SetAllDevices(0x00, 0xFF, 0xFF);
-}
-
-void OpenRGBDialog2::on_QuickBlue()
-{
-    on_SetAllDevices(0x00, 0x00, 0xFF);
-}
-
-void OpenRGBDialog2::on_QuickMagenta()
-{
-    on_SetAllDevices(0xFF, 0x00, 0xFF);
-}
-
-void OpenRGBDialog2::on_QuickWhite()
-{
-    on_SetAllDevices(0xFF, 0xFF, 0xFF);
-}
-
-void OpenRGBDialog2::onDeviceListUpdated()
-{
-    UpdateDevicesList();
-}
-
-void OpenRGBDialog2::onDetectionProgressUpdated()
-{
-    ui->DetectionProgressBar->setValue(ResourceManager::get()->GetDetectionPercent());
-    ui->DetectionProgressBar->setFormat(QString::fromStdString(ResourceManager::get()->GetDetectionString()));
-
-    if(ResourceManager::get()->GetDetectionPercent() == 100)
-    {
-        SetDetectionViewState(false);
-    }
-    else
-    {
-        SetDetectionViewState(true);
-    }
-}
-
-void OpenRGBDialog2::onDetectionEnded()
-{
-    /*-------------------------------------------------------*\
-    | Detect unconfigured zones and prompt for resizing       |
-    \*-------------------------------------------------------*/
-    OpenRGBZonesBulkResizer::RunChecks(this);
-
-    /*-------------------------------------------------------*\
-    | Load plugins after the first detection (ONLY the first) |
-    \*-------------------------------------------------------*/
-    if(!plugins_loaded)
-    {
-        plugin_manager->ScanAndLoadPlugins();
-        plugins_loaded = true;
-    }
-
-    if(device_view_showing)
-    {
-        ShowLEDView();
-    }
-}
-
-void OpenRGBDialog2::on_SetAllDevices(unsigned char red, unsigned char green, unsigned char blue)
-{
-    for(int device = 0; device < ui->DevicesTabBar->count(); device++)
-    {
-        qobject_cast<OpenRGBDevicePage *>(ui->DevicesTabBar->widget(device))->SetCustomMode(red, green, blue);
-    }
-}
-
-void OpenRGBDialog2::on_SaveSizeProfile()
-{
-    ProfileManager* profile_manager = ResourceManager::get()->GetProfileManager();
-
-    if(profile_manager != NULL)
-    {
-        /*---------------------------------------------------------*\
-        | Save the profile                                          |
-        \*---------------------------------------------------------*/
-        profile_manager->SaveProfile("sizes", true);
-    }
-}
-
-void OpenRGBDialog2::on_ShowHide()
-{
-    if(isHidden())
-    {
-#ifdef __APPLE__
-        MacUtils::ToggleApplicationDocklessState(true);
-#endif
-        show();
-        if(isMinimized())
-        {
-            bool maximize = isMaximized();
-            showNormal();
-            if(maximize)
-            {
-                showMaximized();
-            }
-        }
-    }
-    else
-    {
-#ifdef __APPLE__
-        MacUtils::ToggleApplicationDocklessState(false);
-#endif
-        hide();
-    }
-}
-
-void OpenRGBDialog2::onShowDialogMessage()
-{
-    std::size_t hash = std::hash<std::string>{}(dialog_message.toStdString());
-
-    /*-----------------------------------------------------*\
-    | Load the LogManager settings and check if the hash of |
-    | this message is in the no-show list                   |
-    \*-----------------------------------------------------*/
-    SettingsManager*    settings_manager    = ResourceManager::get()->GetSettingsManager();
-    std::string         log_manager_string  = "LogManager";
-    json                log_manager_settings;
-
-    log_manager_settings = settings_manager->GetSettings(log_manager_string);
-
-    /*-----------------------------------------------------*\
-    | If in the no-show list, clear the message string and  |
-    | return without displaying message box                 |
-    \*-----------------------------------------------------*/
-    if(log_manager_settings.contains("dialog_no_show_hashes"))
-    {
-        for(unsigned int list_idx = 0; list_idx < log_manager_settings["dialog_no_show_hashes"].size(); list_idx++)
-        {
-            if(log_manager_settings["dialog_no_show_hashes"][list_idx] == hash)
-            {
-                dialog_message.clear();
-                return;
-            }
-        }
-    }
-
-    QMessageBox box;
-
-    box.setInformativeText(dialog_message);
-
-    QCheckBox* CheckBox_DontShowAgain = new QCheckBox("Don't show this message again");
-
-    DontShowAgain = false;
-
-    QObject::connect(CheckBox_DontShowAgain, &QCheckBox::stateChanged, [this](int state)
-    {
-        if(static_cast<Qt::CheckState>(state) == Qt::CheckState::Checked)
-        {
-            this->DontShowAgain = true;
-        }
-    });
-
-    box.setCheckBox(CheckBox_DontShowAgain);
-    box.setTextFormat(Qt::RichText);
-    box.setTextInteractionFlags(Qt::TextSelectableByMouse|Qt::TextBrowserInteraction);
-
-    box.exec();
-
-    if(DontShowAgain)
-    {
-        /*-----------------------------------------------------*\
-        | Add hash of dialog text to no-show list in LogManager |
-        | settings                                              |
-        \*-----------------------------------------------------*/
-        log_manager_settings["dialog_no_show_hashes"].push_back(hash);
-
-        settings_manager->SetSettings(log_manager_string, log_manager_settings);
-        settings_manager->SaveSettings();
-    }
-
-    DontShowAgain = false;
-
-    dialog_message.clear();
-}
-
-void OpenRGBDialog2::on_ReShow(QSystemTrayIcon::ActivationReason reason)
-{
-    if (reason == QSystemTrayIcon::DoubleClick)
-    {
-        if (isHidden())
-        {
-            show();
-            if(isMinimized())
-            {
-                bool maximize = isMaximized();
-                showNormal();
-                if(maximize)
-                {
-                    showMaximized();
-                }
-            }
-        }
-    }
-}
-
-void Ui::OpenRGBDialog2::on_ProfileSelected()
-{
-    ProfileManager* profile_manager = ResourceManager::get()->GetProfileManager();
-
-    if(profile_manager != NULL)
-    {
-        /*---------------------------------------------------------*\
-        | Get the profile filename from the selected object         |
-        \*---------------------------------------------------------*/
-        std::string profile_name = QObject::sender()->objectName().toStdString();
-
-        /*---------------------------------------------------------*\
-        | Load the profile                                          |
-        \*---------------------------------------------------------*/
-        if(profile_manager->LoadProfile(profile_name))
-        {
-            for(int device = 0; device < ui->DevicesTabBar->count(); device++)
-            {
-                qobject_cast<OpenRGBDevicePage *>(ui->DevicesTabBar->widget(device))->UpdateDevice();
-            }
-        }
-
-        ui->ProfileBox->setCurrentIndex(ui->ProfileBox->findText(QString::fromStdString(profile_name)));
-    }
-}
-
-void Ui::OpenRGBDialog2::on_ButtonLoadProfile_clicked()
-{
-    ProfileManager* profile_manager = ResourceManager::get()->GetProfileManager();
-
-    if(profile_manager != NULL)
-    {
-        /*---------------------------------------------------------*\
-        | Get the profile filename from the profiles list           |
-        \*---------------------------------------------------------*/
-        std::string profile_name = ui->ProfileBox->currentText().toStdString();
-
-        /*---------------------------------------------------------*\
-        | Load the profile                                          |
-        \*---------------------------------------------------------*/
-        if(profile_manager->LoadProfile(profile_name))
-        {
-            for(int device = 0; device < ui->DevicesTabBar->count(); device++)
-            {
-                qobject_cast<OpenRGBDevicePage *>(ui->DevicesTabBar->widget(device))->UpdateDevice();
-            }
-        }
-    }
-}
-
-void Ui::OpenRGBDialog2::on_ButtonDeleteProfile_clicked()
-{
-    ProfileManager* profile_manager = ResourceManager::get()->GetProfileManager();
-
-    if(profile_manager != NULL)
-    {
-        /*---------------------------------------------------------*\
-        | Get the profile filename from the profiles list           |
-        \*---------------------------------------------------------*/
-        std::string profile_name = ui->ProfileBox->currentText().toStdString();
-
-        /*---------------------------------------------------------*\
-        | Confirm we want to delete the profile                     |
-        \*---------------------------------------------------------*/
-        QMessageBox::StandardButton reply;
-        reply = QMessageBox::question(this, tr("Delete Profile"), tr("Do you really want to delete this profile?"), QMessageBox::Yes|QMessageBox::No);
-
-        /*---------------------------------------------------------*\
-        | Load the profile                                          |
-        \*---------------------------------------------------------*/
-        if(reply == QMessageBox::Yes)
-        {
-            profile_manager->DeleteProfile(profile_name);
-
-            UpdateProfileList();
-        }
-    }
-}
-
-void Ui::OpenRGBDialog2::on_ButtonToggleDeviceView_clicked()
-{
-    if(device_view_showing)
-    {
-        HideLEDView();
-    }
-    else
-    {
-        ShowLEDView();
-    }
-}
-
-void Ui::OpenRGBDialog2::ShowLEDView()
-{
-    for(int device = 0; device < ui->DevicesTabBar->count(); device++)
-    {
-        OpenRGBDevicePage* device_page = qobject_cast<OpenRGBDevicePage *>(ui->DevicesTabBar->widget(device));
-        if(device_page) // Check the cast to make sure it is a device and not plugin
-        {
-            device_page->ShowDeviceView();
-        }
-    }
-    device_view_showing = true;
-}
-
-void Ui::OpenRGBDialog2::HideLEDView()
-{
-    for(int device = 0; device < ui->DevicesTabBar->count(); device++)
-    {
-        qobject_cast<OpenRGBDevicePage *>(ui->DevicesTabBar->widget(device))->HideDeviceView();
-    }
-    device_view_showing = false;
-}
-
-
-void Ui::OpenRGBDialog2::on_ButtonStopDetection_clicked()
-{
-    /*---------------------------------------------------------*\
-    | Notify the detection thread that it has to die            |
-    \*---------------------------------------------------------*/
-    ResourceManager::get()->StopDeviceDetection();
-
-    /*---------------------------------------------------------*\
-    | Pretend we're done already by hiding the progress bar     |
-    \*---------------------------------------------------------*/
-    SetDetectionViewState(false);
-}
-
-void Ui::OpenRGBDialog2::SetDetectionViewState(bool detection_showing)
-{
-    if(detection_showing)
-    {
-        /*---------------------------------------------------------*\
-        | Show the detection progress and hide the normal buttons   |
-        \*---------------------------------------------------------*/
-        ui->ButtonToggleDeviceView->setVisible(false);
-        ui->ButtonRescan->setVisible(false);
-        ui->ButtonLoadProfile->setVisible(false);
-        ui->ButtonSaveProfile->setVisible(false);
-        ui->ButtonDeleteProfile->setVisible(false);
-        ui->ProfileBox->setVisible(false);
-
-        ui->DetectionProgressBar->setVisible(true);
-        ui->DetectionProgressLabel->setVisible(true);
-        ui->ButtonStopDetection->setVisible(true);
-    }
-    else
-    {
-        /*---------------------------------------------------------*\
-        | Hide the detection progress and show the normal buttons   |
-        \*---------------------------------------------------------*/
-        ui->DetectionProgressBar->setVisible(false);
-        ui->DetectionProgressLabel->setVisible(false);
-        ui->ButtonStopDetection->setVisible(false);
-
-        ui->ButtonToggleDeviceView->setVisible(true);
-        ui->ButtonRescan->setVisible(true);
-        ui->ButtonLoadProfile->setVisible(true);
-        ui->ButtonSaveProfile->setVisible(true);
-        ui->ButtonDeleteProfile->setVisible(true);
-        ui->ProfileBox->setVisible(true);
-    }
-}
-
-void OpenRGBDialog2::SetTrayIcon(bool tray_icon)
-{
-    if(tray_icon)
-    {
-        trayIcon->setIcon(QIcon(":OpenRGBGreyscale.png"));
-    }
-    else
-    {
-        trayIcon->setIcon(QIcon(":org.openrgb.OpenRGB.png"));
-    }
-}
-
-void OpenRGBDialog2::SaveProfile()
-{
-    ProfileManager* profile_manager = ResourceManager::get()->GetProfileManager();
-
-    if(profile_manager != NULL)
-    {
-        /*---------------------------------------------------------*\
-        | Get the profile filename from the profiles list           |
-        \*---------------------------------------------------------*/
-        std::string filename = ui->ProfileBox->currentText().toStdString();
-
-        /*---------------------------------------------------------*\
-        | Save the profile                                          |
-        \*---------------------------------------------------------*/
-        profile_manager->SaveProfile(filename);
-    }
-}
-
-void OpenRGBDialog2::SaveProfileAs()
-{
-    ProfileManager* profile_manager = ResourceManager::get()->GetProfileManager();
-
-    if(profile_manager != NULL)
-    {
-        OpenRGBProfileSaveDialog dialog;
-
-        /*---------------------------------------------------------*\
-        | Open Profile Name Dialog                                  |
-        \*---------------------------------------------------------*/
-        std::string profile_name = dialog.show();
-
-        if(!profile_name.empty())
-        {
-            /*---------------------------------------------------------*\
-            | Extension .orp - OpenRgb Profile                          |
-            \*---------------------------------------------------------*/
-            std::string filename = profile_name;
-
-            /*---------------------------------------------------------*\
-            | Save the profile                                          |
-            \*---------------------------------------------------------*/
-            if(profile_manager->SaveProfile(filename))
-            {
-                UpdateProfileList();
-
-                ui->ProfileBox->setCurrentIndex(ui->ProfileBox->findText(QString::fromStdString(profile_name)));
-            }
-        }
-    }
-}
-
-void Ui::OpenRGBDialog2::on_ButtonRescan_clicked()
-{
-    /*---------------------------------------------------------*\
-    | Hide devices view on rescan so it stops handling paint    |
-    | events.                                                   |
-    | Memorize previous value of device_view_showing and        |
-    | restore it.                                               |
-    \*---------------------------------------------------------*/
-    bool device_view_showing_prev = device_view_showing;
-
-    HideLEDView();
-
-    device_view_showing = device_view_showing_prev;
-
-    /*---------------------------------------------------------*\
-    | Show the detection progress bar.                          |
-    \*---------------------------------------------------------*/
-    SetDetectionViewState(true);
-
-    /*---------------------------------------------------------*\
-    | Show the detection progress bar.                          |
-    \*---------------------------------------------------------*/
-    ResourceManager::get()->DetectDevices();
-}
-
-void Ui::OpenRGBDialog2::on_ActionSaveProfile_triggered()
-{
-    if(ui->ProfileBox->currentIndex() >= 0)
-    {
-        SaveProfile();
-    }
-    else
-    {
-        SaveProfileAs();
-    }
-}
-
-void Ui::OpenRGBDialog2::on_ActionSaveProfileAs_triggered()
-{
-    SaveProfileAs();
-}
-
-
-void Ui::OpenRGBDialog2::on_InformationTabBar_currentChanged(int tab_idx)
-{
-    TogglePluginsVisibility(tab_idx, ui->InformationTabBar);
-}
-
-void Ui::OpenRGBDialog2::on_DevicesTabBar_currentChanged(int tab_idx)
-{
-    TogglePluginsVisibility(tab_idx, ui->DevicesTabBar);
-}
-
-void Ui::OpenRGBDialog2::on_MainTabBar_currentChanged(int tab_idx)
-{
-    TogglePluginsVisibility(tab_idx, ui->MainTabBar);
-}
-
-void Ui::OpenRGBDialog2::on_SettingsTabBar_currentChanged(int tab_idx)
-{
-    TogglePluginsVisibility(tab_idx, ui->SettingsTabBar);
-}
-
-void Ui::OpenRGBDialog2::TogglePluginsVisibility(int tab_idx, QTabWidget* tabBar)
-{
-    /*---------------------------------------------------------*\
-    | Hide all plugins                                          |
-    \*---------------------------------------------------------*/
-    for(int i = 0; i < (tabBar->count()); i++)
-    {
-        QWidget* tab = tabBar->widget(i);
-
-        /*-----------------------------------------------------*\
-        | Dynamic cast is essential in this check to ensure the |
-        | tab is actually a plugin container                    |
-        \*-----------------------------------------------------*/
-        if((i != tab_idx) && (dynamic_cast<OpenRGBPluginContainer*>(tab) != nullptr))
-        {
-            ((OpenRGBPluginContainer*) tab)->Hide();
-            ui->MainButtonsFrame->setVisible(true);
-        }
-    }
-
-    /*---------------------------------------------------------*\
-    | Show plugin if needed                                     |
-    \*---------------------------------------------------------*/
-    QWidget* tab = tabBar->widget(tab_idx);
-
-    /*---------------------------------------------------------*\
-    | Dynamic cast is essential in this check to ensure the tab |
-    | is actually a plugin container                            |
-    \*---------------------------------------------------------*/
-    if(dynamic_cast<OpenRGBPluginContainer*>(tab) != nullptr)
-    {
-        ((OpenRGBPluginContainer*) tab)->Show();
-        ui->MainButtonsFrame->setVisible(false);
-    }
-}
-
-void Ui::OpenRGBDialog2::AddConsolePage()
-{
-    OpenRGBConsolePage* page = new OpenRGBConsolePage();
-
-    ui->InformationTabBar->addTab(page, "");
-
-    /*-----------------------------------------------------*\
-    | Create the tab label                                  |
-    \*-----------------------------------------------------*/
-    TabLabel* ConsoleTabLabel = new TabLabel(OpenRGBFont::terminal, tr("Log Console"), (char *)"Log Console", (char *)context);
-
-    ui->InformationTabBar->tabBar()->setTabButton(ui->InformationTabBar->tabBar()->count() - 1, QTabBar::LeftSide, ConsoleTabLabel);
-}
diff --git a/qt/OpenRGBDialog2/OpenRGBDialog2.h b/qt/OpenRGBDialog2/OpenRGBDialog2.h
deleted file mode 100644
index f8ac0f93..00000000
--- a/qt/OpenRGBDialog2/OpenRGBDialog2.h
+++ /dev/null
@@ -1,167 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBDialog2.h                                          |
-|                                                           |
-|   User interface for OpenRGB main window                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <string>
-#include <vector>
-#include <QMainWindow>
-#include <QTimer>
-#include <QSystemTrayIcon>
-#include <QMenu>
-#include <QSlider>
-
-#include "ui_OpenRGBDialog2.h"
-
-#include "OpenRGBClientInfoPage.h"
-#include "OpenRGBPluginsPage/OpenRGBPluginsPage.h"
-#include "OpenRGBSoftwareInfoPage.h"
-#include "OpenRGBSystemInfoPage.h"
-#include "OpenRGBSupportedDevicesPage.h"
-#include "OpenRGBSettingsPage.h"
-#include "OpenRGBSerialSettingsPage/OpenRGBSerialSettingsPage.h"
-#include "PluginManager.h"
-#include "SuspendResume.h"
-
-#include "i2c_smbus.h"
-#include "LogManager.h"
-#include "RGBController.h"
-#include "ProfileManager.h"
-#include "NetworkClient.h"
-#include "NetworkServer.h"
-
-namespace Ui
-{
-    class OpenRGBDialog2;
-}
-
-class Ui::OpenRGBDialog2 : public QMainWindow, private SuspendResumeListener
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBDialog2(QWidget *parent = 0);
-    ~OpenRGBDialog2();
-
-    void AddClient(NetworkClient* new_client);
-    void AddClientTab();
-    void AddI2CToolsPage();
-    void AddServerTab();
-
-    void AddPlugin(OpenRGBPluginEntry* plugin);
-    void RemovePlugin(OpenRGBPluginEntry* plugin);
-
-    void setMode(unsigned char mode_val);
-
-    static bool IsMinimizeOnClose();
-
-    void SetDialogMessage(PLogMessage msg);
-
-    bool DontShowAgain;
-
-signals:
-    void ProfileListChanged();
-
-public slots:
-    void changeEvent(QEvent *event);
-    void SetTrayIcon(bool tray_icon);
-    void handleAboutToQuit();
-
-private:
-    const char* context = "Ui::OpenRGBDialog2";
-
-    /*-------------------------------------*\
-    | Page pointers                         |
-    \*-------------------------------------*/
-    OpenRGBClientInfoPage *ClientInfoPage;
-    OpenRGBPluginsPage *PluginsPage;
-    OpenRGBSystemInfoPage *SMBusToolsPage;
-    OpenRGBSoftwareInfoPage *SoftInfoPage;
-    OpenRGBSupportedDevicesPage *SupportedPage;
-    OpenRGBSettingsPage *SettingsPage;
-    OpenRGBSerialSettingsPage *SerialSettingsPage;
-
-    bool ShowI2CTools = false;
-    bool plugins_loaded = false;
-
-    /*-------------------------------------*\
-    | System tray icon and menu             |
-    \*-------------------------------------*/
-    QSystemTrayIcon* trayIcon;
-    QMenu* trayIconMenu;
-    QMenu* profileMenu;
-
-    /*-------------------------------------*\
-    | User interface                        |
-    \*-------------------------------------*/
-    Ui::OpenRGBDialog2Ui *ui;
-
-    void AddSoftwareInfoPage();
-    void AddSupportedDevicesPage();
-    void AddSettingsPage();
-    void AddSerialSettingsPage();
-    void AddPluginsPage();
-    void AddConsolePage();
-
-    void ClearDevicesList();
-    void UpdateDevicesList();
-    void UpdateProfileList();
-    void closeEvent(QCloseEvent *event);
-    bool SelectConfigProfile(const std::string name);
-
-    void SetDetectionViewState(bool detection_showing);
-    void SaveProfile();
-    void SaveProfileAs();
-
-    void TogglePluginsVisibility(int, QTabWidget*);
-
-    bool device_view_showing = false;
-
-    PluginManager* plugin_manager = nullptr;
-
-    QAction* actionExit;
-    QString dialog_message;
-
-    void ShowLEDView();
-    void HideLEDView();
-
-    void OnSuspend();
-    void OnResume();
-
-private slots:
-    void on_Exit();
-    void on_LightsOff();
-    void on_QuickRed();
-    void on_QuickYellow();
-    void on_QuickGreen();
-    void on_QuickCyan();
-    void on_QuickBlue();
-    void on_QuickMagenta();
-    void on_QuickWhite();
-    void onDeviceListUpdated();
-    void onDetectionProgressUpdated();
-    void onDetectionEnded();
-    void on_SetAllDevices(unsigned char red, unsigned char green, unsigned char blue);
-    void on_SaveSizeProfile();
-    void on_ShowHide();
-    void onShowDialogMessage();
-    void on_ReShow(QSystemTrayIcon::ActivationReason reason);
-    void on_ProfileSelected();
-    void on_ButtonLoadProfile_clicked();
-    void on_ButtonDeleteProfile_clicked();
-    void on_ButtonToggleDeviceView_clicked();
-    void on_ButtonStopDetection_clicked();
-    void on_ButtonRescan_clicked();
-    void on_ActionSaveProfile_triggered();
-    void on_ActionSaveProfileAs_triggered();
-    void on_MainTabBar_currentChanged(int);
-    void on_InformationTabBar_currentChanged(int);
-    void on_DevicesTabBar_currentChanged(int);
-    void on_SettingsTabBar_currentChanged(int);
-};
diff --git a/qt/OpenRGBDialog2/OpenRGBDialog2.ui b/qt/OpenRGBDialog2/OpenRGBDialog2.ui
deleted file mode 100644
index e7864802..00000000
--- a/qt/OpenRGBDialog2/OpenRGBDialog2.ui
+++ /dev/null
@@ -1,206 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBDialog2Ui</class>
- <widget class="QMainWindow" name="OpenRGBDialog2Ui">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>700</width>
-    <height>350</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>OpenRGB</string>
-  </property>
-  <widget class="QWidget" name="centralWidget">
-   <layout class="QGridLayout" name="gridLayout">
-    <item row="2" column="0" colspan="5">
-     <widget class="QTabWidget" name="MainTabBar">
-      <property name="tabShape">
-       <enum>QTabWidget::Rounded</enum>
-      </property>
-      <property name="currentIndex">
-       <number>0</number>
-      </property>
-      <property name="iconSize">
-       <size>
-        <width>20</width>
-        <height>20</height>
-       </size>
-      </property>
-      <widget class="QWidget" name="TabDevices">
-       <attribute name="title">
-        <string>Devices</string>
-       </attribute>
-       <layout class="QGridLayout" name="gridLayout_3">
-        <item row="1" column="0">
-         <widget class="QTabWidget" name="DevicesTabBar">
-          <property name="tabPosition">
-           <enum>QTabWidget::West</enum>
-          </property>
-         </widget>
-        </item>
-       </layout>
-      </widget>
-      <widget class="QWidget" name="TabInformation">
-       <attribute name="title">
-        <string>Information</string>
-       </attribute>
-       <layout class="QGridLayout" name="gridLayout_2">
-        <item row="0" column="0">
-         <widget class="QTabWidget" name="InformationTabBar">
-          <property name="tabPosition">
-           <enum>QTabWidget::West</enum>
-          </property>
-          <property name="currentIndex">
-           <number>-1</number>
-          </property>
-         </widget>
-        </item>
-       </layout>
-      </widget>
-      <widget class="QWidget" name="TabSettings">
-       <attribute name="title">
-        <string>Settings</string>
-       </attribute>
-       <layout class="QGridLayout" name="gridLayout_4">
-        <item row="0" column="0">
-         <widget class="QTabWidget" name="SettingsTabBar">
-          <property name="tabPosition">
-           <enum>QTabWidget::West</enum>
-          </property>
-          <property name="currentIndex">
-           <number>-1</number>
-          </property>
-         </widget>
-        </item>
-       </layout>
-      </widget>
-     </widget>
-    </item>
-    <item row="6" column="0" colspan="5">
-     <layout class="QHBoxLayout" name="MainButtonsLayout">
-      <item>
-       <widget class="QFrame" name="MainButtonsFrame">
-        <property name="frameShape">
-         <enum>QFrame::NoFrame</enum>
-        </property>
-        <property name="frameShadow">
-         <enum>QFrame::Raised</enum>
-        </property>
-        <layout class="QGridLayout" name="gridLayout_5">
-         <property name="leftMargin">
-          <number>0</number>
-         </property>
-         <property name="topMargin">
-          <number>0</number>
-         </property>
-         <property name="rightMargin">
-          <number>0</number>
-         </property>
-         <property name="bottomMargin">
-          <number>0</number>
-         </property>
-         <item row="0" column="0">
-          <widget class="QPushButton" name="ButtonToggleDeviceView">
-           <property name="text">
-            <string>Toggle LED View</string>
-           </property>
-          </widget>
-         </item>
-         <item row="0" column="1">
-          <widget class="QPushButton" name="ButtonRescan">
-           <property name="text">
-            <string>Rescan Devices</string>
-           </property>
-          </widget>
-         </item>
-         <item row="0" column="2">
-          <widget class="QToolButton" name="ButtonSaveProfile">
-           <property name="sizePolicy">
-            <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
-             <horstretch>0</horstretch>
-             <verstretch>0</verstretch>
-            </sizepolicy>
-           </property>
-           <property name="text">
-            <string>Save Profile</string>
-           </property>
-           <property name="popupMode">
-            <enum>QToolButton::MenuButtonPopup</enum>
-           </property>
-          </widget>
-         </item>
-         <item row="0" column="3">
-          <widget class="QPushButton" name="ButtonDeleteProfile">
-           <property name="text">
-            <string>Delete Profile</string>
-           </property>
-          </widget>
-         </item>
-         <item row="0" column="4">
-          <widget class="QPushButton" name="ButtonLoadProfile">
-           <property name="text">
-            <string>Load Profile</string>
-           </property>
-          </widget>
-         </item>
-         <item row="0" column="5">
-          <widget class="QComboBox" name="ProfileBox"/>
-         </item>
-        </layout>
-       </widget>
-      </item>
-     </layout>
-    </item>
-    <item row="4" column="0" colspan="5">
-     <layout class="QHBoxLayout" name="DetectorLayout">
-      <item>
-       <widget class="QLabel" name="DetectionProgressLabel">
-        <property name="text">
-         <string>OpenRGB is detecting devices...</string>
-        </property>
-        <property name="alignment">
-         <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <widget class="QProgressBar" name="DetectionProgressBar">
-        <property name="value">
-         <number>24</number>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <widget class="QPushButton" name="ButtonStopDetection">
-        <property name="text">
-         <string>Cancel</string>
-        </property>
-       </widget>
-      </item>
-     </layout>
-    </item>
-   </layout>
-  </widget>
-  <action name="ActionSaveProfile">
-   <property name="text">
-    <string>Save Profile</string>
-   </property>
-   <property name="toolTip">
-    <string>Save Profile</string>
-   </property>
-  </action>
-  <action name="ActionSaveProfileAs">
-   <property name="text">
-    <string>Save Profile As...</string>
-   </property>
-   <property name="toolTip">
-    <string>Save Profile with custom name</string>
-   </property>
-  </action>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsEntry.cpp b/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsEntry.cpp
deleted file mode 100644
index 23c7b9f3..00000000
--- a/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsEntry.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBE131SettingsEntry.cpp                              |
-|                                                           |
-|   User interface for OpenRGB E1.31 settings entry         |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBE131SettingsEntry.h"
-#include "ui_OpenRGBE131SettingsEntry.h"
-
-using namespace Ui;
-
-OpenRGBE131SettingsEntry::OpenRGBE131SettingsEntry(QWidget *parent) :
-    QWidget(parent),
-    ui(new Ui::OpenRGBE131SettingsEntryUi)
-{
-    ui->setupUi(this);
-
-    ui->TypeComboBox->addItem(tr("Single"));
-    ui->TypeComboBox->addItem(tr("Linear"));
-    ui->TypeComboBox->addItem(tr("Matrix"));
-
-    ui->MatrixOrderComboBox->addItem(tr("Horizontal Top Left"));
-    ui->MatrixOrderComboBox->addItem(tr("Horizontal Top Right"));
-    ui->MatrixOrderComboBox->addItem(tr("Horizontal Bottom Left"));
-    ui->MatrixOrderComboBox->addItem(tr("Horizontal Bottom Right"));
-    ui->MatrixOrderComboBox->addItem(tr("Vertical Top Left"));
-    ui->MatrixOrderComboBox->addItem(tr("Vertical Top Right"));
-    ui->MatrixOrderComboBox->addItem(tr("Vertical Bottom Left"));
-    ui->MatrixOrderComboBox->addItem(tr("Vertical Bottom Right"));
-
-    ui->RGBOrderComboBox->addItem("RGB");
-    ui->RGBOrderComboBox->addItem("RBG");
-    ui->RGBOrderComboBox->addItem("GRB");
-    ui->RGBOrderComboBox->addItem("GBR");
-    ui->RGBOrderComboBox->addItem("BRG");
-    ui->RGBOrderComboBox->addItem("BGR");
-
-    HideMatrixSettings();
-}
-
-OpenRGBE131SettingsEntry::~OpenRGBE131SettingsEntry()
-{
-    delete ui;
-}
-
-void OpenRGBE131SettingsEntry::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void Ui::OpenRGBE131SettingsEntry::HideMatrixSettings()
-{
-    ui->MatrixWidthLabel->setDisabled(true);
-    ui->MatrixWidthEdit->setDisabled(true);
-
-    ui->MatrixHeightLabel->setDisabled(true);
-    ui->MatrixHeightEdit->setDisabled(true);
-
-    ui->MatrixOrderLabel->setDisabled(true);
-    ui->MatrixOrderComboBox->setDisabled(true);
-}
-
-void Ui::OpenRGBE131SettingsEntry::ShowMatrixSettings()
-{
-    ui->MatrixWidthLabel->setDisabled(false);
-    ui->MatrixWidthEdit->setDisabled(false);
-
-    ui->MatrixHeightLabel->setDisabled(false);
-    ui->MatrixHeightEdit->setDisabled(false);
-
-    ui->MatrixOrderLabel->setDisabled(false);
-    ui->MatrixOrderComboBox->setDisabled(false);
-}
-
-void Ui::OpenRGBE131SettingsEntry::on_TypeComboBox_currentIndexChanged(int index)
-{
-    if(index == 2)
-    {
-        ShowMatrixSettings();
-    }
-    else
-    {
-        HideMatrixSettings();
-    }
-}
diff --git a/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsEntry.h b/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsEntry.h
deleted file mode 100644
index 34c9462c..00000000
--- a/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsEntry.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBE131SettingsEntry.h                                |
-|                                                           |
-|   User interface for OpenRGB E1.31 settings entry         |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QWidget>
-#include "ui_OpenRGBE131SettingsEntry.h"
-
-namespace Ui
-{
-    class OpenRGBE131SettingsEntry;
-}
-
-class Ui::OpenRGBE131SettingsEntry : public QWidget
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBE131SettingsEntry(QWidget *parent = nullptr);
-    ~OpenRGBE131SettingsEntry();
-    Ui::OpenRGBE131SettingsEntryUi *ui;
-
-private:
-    void HideMatrixSettings();
-    void ShowMatrixSettings();
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_TypeComboBox_currentIndexChanged(int index);
-};
diff --git a/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsEntry.ui b/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsEntry.ui
deleted file mode 100644
index 3bb97a86..00000000
--- a/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsEntry.ui
+++ /dev/null
@@ -1,169 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBE131SettingsEntryUi</class>
- <widget class="QWidget" name="OpenRGBE131SettingsEntryUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>531</width>
-    <height>237</height>
-   </rect>
-  </property>
-  <property name="sizePolicy">
-   <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
-    <horstretch>0</horstretch>
-    <verstretch>0</verstretch>
-   </sizepolicy>
-  </property>
-  <property name="windowTitle">
-   <string>E131 settings entry</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="1" column="0" colspan="2">
-    <widget class="QGroupBox" name="groupBox">
-     <property name="title">
-      <string/>
-     </property>
-     <layout class="QGridLayout" name="gridLayout_2">
-      <item row="2" column="5">
-       <widget class="QLineEdit" name="StartChannelEdit"/>
-      </item>
-      <item row="5" column="3">
-       <widget class="QLineEdit" name="NumLEDsEdit"/>
-      </item>
-      <item row="6" column="3">
-       <widget class="QLineEdit" name="MatrixWidthEdit"/>
-      </item>
-      <item row="2" column="4">
-       <widget class="QLabel" name="StartChannelLabel">
-        <property name="text">
-         <string>Start Channel:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="0">
-       <widget class="QLabel" name="NumLEDsLabel">
-        <property name="text">
-         <string>Number of LEDs:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="2" column="3">
-       <widget class="QLineEdit" name="StartUniverseEdit"/>
-      </item>
-      <item row="1" column="3">
-       <widget class="QLineEdit" name="NameEdit"/>
-      </item>
-      <item row="7" column="3">
-       <widget class="QComboBox" name="MatrixOrderComboBox"/>
-      </item>
-      <item row="2" column="0">
-       <widget class="QLabel" name="StartUniverseLabel">
-        <property name="text">
-         <string>Start Universe:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="5">
-       <widget class="QLineEdit" name="IPEdit"/>
-      </item>
-      <item row="1" column="0">
-       <widget class="QLabel" name="NameLabel">
-        <property name="text">
-         <string>Name:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="7" column="0">
-       <widget class="QLabel" name="MatrixOrderLabel">
-        <property name="text">
-         <string>Matrix Order:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="5">
-       <widget class="QComboBox" name="TypeComboBox"/>
-      </item>
-      <item row="6" column="5">
-       <widget class="QLineEdit" name="MatrixHeightEdit"/>
-      </item>
-      <item row="6" column="4">
-       <widget class="QLabel" name="MatrixHeightLabel">
-        <property name="text">
-         <string>Matrix Height:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="6" column="0">
-       <widget class="QLabel" name="MatrixWidthLabel">
-        <property name="text">
-         <string>Matrix Width:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="4">
-       <widget class="QLabel" name="TypeLabel">
-        <property name="text">
-         <string>Type:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="4">
-       <widget class="QLabel" name="IPLabel">
-        <property name="text">
-         <string>IP (Unicast):</string>
-        </property>
-       </widget>
-      </item>
-      <item row="8" column="0">
-       <widget class="QLabel" name="UniverseSizeLabel">
-        <property name="text">
-         <string>Universe Size:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="8" column="3">
-       <widget class="QLineEdit" name="UniverseSizeEdit"/>
-      </item>
-      <item row="8" column="4">
-       <widget class="QLabel" name="KeepaliveTimeLabel">
-        <property name="text">
-         <string>Keepalive Time:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="8" column="5">
-       <widget class="QLineEdit" name="KeepaliveTimeEdit"/>
-      </item>
-      <item row="7" column="4">
-       <widget class="QLabel" name="RGBOrderLabel">
-        <property name="text">
-         <string>RGB Order:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="7" column="5">
-       <widget class="QComboBox" name="RGBOrderComboBox"/>
-      </item>
-     </layout>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <tabstops>
-  <tabstop>NameEdit</tabstop>
-  <tabstop>IPEdit</tabstop>
-  <tabstop>StartUniverseEdit</tabstop>
-  <tabstop>StartChannelEdit</tabstop>
-  <tabstop>NumLEDsEdit</tabstop>
-  <tabstop>TypeComboBox</tabstop>
-  <tabstop>MatrixWidthEdit</tabstop>
-  <tabstop>MatrixHeightEdit</tabstop>
-  <tabstop>MatrixOrderComboBox</tabstop>
-  <tabstop>UniverseSizeEdit</tabstop>
-  <tabstop>KeepaliveTimeEdit</tabstop>
- </tabstops>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsPage.cpp b/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsPage.cpp
deleted file mode 100644
index 8d06e1de..00000000
--- a/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsPage.cpp
+++ /dev/null
@@ -1,300 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBE131SettingsPage.cpp                               |
-|                                                           |
-|   User interface for OpenRGB E1.31 settings page          |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBE131SettingsPage.h"
-#include "ui_OpenRGBE131SettingsPage.h"
-#include "ResourceManager.h"
-#include "SettingsManager.h"
-
-using namespace Ui;
-
-OpenRGBE131SettingsPage::OpenRGBE131SettingsPage(QWidget *parent) :
-    QWidget(parent),
-    ui(new Ui::OpenRGBE131SettingsPageUi)
-{
-    ui->setupUi(this);
-
-    json                e131_settings;
-
-    /*-------------------------------------------------*\
-    | Get E1.31 settings from settings manager          |
-    \*-------------------------------------------------*/
-    e131_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("E131Devices");
-
-    /*-------------------------------------------------*\
-    | If the E1.31 settings contains devices, process   |
-    \*-------------------------------------------------*/
-    if(e131_settings.contains("devices"))
-    {
-        for(unsigned int device_idx = 0; device_idx < e131_settings["devices"].size(); device_idx++)
-        {
-            OpenRGBE131SettingsEntry* entry = new OpenRGBE131SettingsEntry;
-
-            if(e131_settings["devices"][device_idx].contains("name"))
-            {
-                entry->ui->NameEdit->setText(QString::fromStdString(e131_settings["devices"][device_idx]["name"]));
-            }
-
-            if(e131_settings["devices"][device_idx].contains("ip"))
-            {
-                entry->ui->IPEdit->setText(QString::fromStdString(e131_settings["devices"][device_idx]["ip"]));
-            }
-
-            if(e131_settings["devices"][device_idx].contains("start_universe"))
-            {
-                entry->ui->StartUniverseEdit->setText(QString::number((int)e131_settings["devices"][device_idx]["start_universe"]));
-            }
-
-            if(e131_settings["devices"][device_idx].contains("start_channel"))
-            {
-                entry->ui->StartChannelEdit->setText(QString::number((int)e131_settings["devices"][device_idx]["start_channel"]));
-            }
-
-            if(e131_settings["devices"][device_idx].contains("num_leds"))
-            {
-                entry->ui->NumLEDsEdit->setText(QString::number((int)e131_settings["devices"][device_idx]["num_leds"]));
-            }
-
-            if(e131_settings["devices"][device_idx].contains("type"))
-            {
-                if(e131_settings["devices"][device_idx]["type"].is_string())
-                {
-                    std::string type_val = e131_settings["devices"][device_idx]["type"];
-
-                    if(type_val == "SINGLE")
-                    {
-                        entry->ui->TypeComboBox->setCurrentIndex(0);
-                    }
-                    else if(type_val == "LINEAR")
-                    {
-                        entry->ui->TypeComboBox->setCurrentIndex(1);
-                    }
-                    else if(type_val == "MATRIX")
-                    {
-                        entry->ui->TypeComboBox->setCurrentIndex(2);
-                    }
-                }
-                else
-                {
-                    entry->ui->TypeComboBox->setCurrentIndex(e131_settings["devices"][device_idx]["type"]);
-                }
-            }
-
-            if(e131_settings["devices"][device_idx].contains("rgb_order"))
-            {
-                if(e131_settings["devices"][device_idx]["rgb_order"].is_string())
-                {
-                    std::string rgb_order_val = e131_settings["devices"][device_idx]["rgb_order"];
-
-                    if(rgb_order_val == "RGB")
-                    {
-                        entry->ui->RGBOrderComboBox->setCurrentIndex(0);
-                    }
-                    else if(rgb_order_val == "RBG")
-                    {
-                        entry->ui->RGBOrderComboBox->setCurrentIndex(1);
-                    }
-                    else if(rgb_order_val == "GRB")
-                    {
-                        entry->ui->RGBOrderComboBox->setCurrentIndex(2);
-                    }
-                    else if(rgb_order_val == "GBR")
-                    {
-                        entry->ui->RGBOrderComboBox->setCurrentIndex(3);
-                    }
-                    else if(rgb_order_val == "BRG")
-                    {
-                        entry->ui->RGBOrderComboBox->setCurrentIndex(4);
-                    }
-                    else if(rgb_order_val == "BGR")
-                    {
-                        entry->ui->RGBOrderComboBox->setCurrentIndex(5);
-                    }
-                }
-                else
-                {
-                    entry->ui->RGBOrderComboBox->setCurrentIndex(e131_settings["devices"][device_idx]["rgb_order"]);
-                }
-            }
-
-            if(e131_settings["devices"][device_idx].contains("matrix_width"))
-            {
-                entry->ui->MatrixWidthEdit->setText(QString::number((int)e131_settings["devices"][device_idx]["matrix_width"]));
-            }
-
-            if(e131_settings["devices"][device_idx].contains("matrix_height"))
-            {
-                entry->ui->MatrixHeightEdit->setText(QString::number((int)e131_settings["devices"][device_idx]["matrix_height"]));
-            }
-
-            if(e131_settings["devices"][device_idx].contains("matrix_order"))
-            {
-                if(e131_settings["devices"][device_idx]["matrix_order"].is_string())
-                {
-                    std::string matrix_order_val = e131_settings["devices"][device_idx]["matrix_order"];
-
-                    if(matrix_order_val == "HORIZONTAL_TOP_LEFT")
-                    {
-                        entry->ui->MatrixOrderComboBox->setCurrentIndex(0);
-                    }
-                    else if(matrix_order_val == "HORIZONTAL_TOP_RIGHT")
-                    {
-                        entry->ui->MatrixOrderComboBox->setCurrentIndex(1);
-                    }
-                    else if(matrix_order_val == "HORIZONTAL_BOTTOM_LEFT")
-                    {
-                        entry->ui->MatrixOrderComboBox->setCurrentIndex(2);
-                    }
-                    else if(matrix_order_val == "HORIZONTAL_BOTTOM_RIGHT")
-                    {
-                        entry->ui->MatrixOrderComboBox->setCurrentIndex(3);
-                    }
-                    else if(matrix_order_val == "VERTICAL_TOP_LEFT")
-                    {
-                        entry->ui->MatrixOrderComboBox->setCurrentIndex(4);
-                    }
-                    else if(matrix_order_val == "VERTICAL_TOP_RIGHT")
-                    {
-                        entry->ui->MatrixOrderComboBox->setCurrentIndex(5);
-                    }
-                    else if(matrix_order_val == "VERTICAL_BOTTOM_LEFT")
-                    {
-                        entry->ui->MatrixOrderComboBox->setCurrentIndex(6);
-                    }
-                    else if(matrix_order_val == "VERTICAL_BOTTOM_RIGHT")
-                    {
-                        entry->ui->MatrixOrderComboBox->setCurrentIndex(7);
-                    }
-                }
-                else
-                {
-                    entry->ui->MatrixOrderComboBox->setCurrentIndex(e131_settings["devices"][device_idx]["matrix_order"]);
-                }
-            }
-
-            if(e131_settings["devices"][device_idx].contains("universe_size"))
-            {
-                entry->ui->UniverseSizeEdit->setText(QString::number((int)e131_settings["devices"][device_idx]["universe_size"]));
-            }
-
-            if(e131_settings["devices"][device_idx].contains("keepalive_time"))
-            {
-                entry->ui->KeepaliveTimeEdit->setText(QString::number((int)e131_settings["devices"][device_idx]["keepalive_time"]));
-            }
-
-            entries.push_back(entry);
-
-            QListWidgetItem* item = new QListWidgetItem;
-
-            item->setSizeHint(entry->sizeHint());
-
-            ui->E131DeviceList->addItem(item);
-            ui->E131DeviceList->setItemWidget(item, entry);
-            ui->E131DeviceList->show();
-        }
-    }
-}
-
-OpenRGBE131SettingsPage::~OpenRGBE131SettingsPage()
-{
-    delete ui;
-}
-
-void OpenRGBE131SettingsPage::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void Ui::OpenRGBE131SettingsPage::on_AddE131DeviceButton_clicked()
-{
-    OpenRGBE131SettingsEntry* entry = new OpenRGBE131SettingsEntry;
-    entries.push_back(entry);
-
-    QListWidgetItem* item = new QListWidgetItem;
-
-    item->setSizeHint(entry->sizeHint());
-
-    ui->E131DeviceList->addItem(item);
-    ui->E131DeviceList->setItemWidget(item, entry);
-    ui->E131DeviceList->show();
-}
-
-void Ui::OpenRGBE131SettingsPage::on_RemoveE131DeviceButton_clicked()
-{
-    int cur_row = ui->E131DeviceList->currentRow();
-
-    if(cur_row < 0)
-    {
-        return;
-    }
-
-    QListWidgetItem* item = ui->E131DeviceList->takeItem(cur_row);
-
-    ui->E131DeviceList->removeItemWidget(item);
-    delete item;
-
-    delete entries[cur_row];
-    entries.erase(entries.begin() + cur_row);
-}
-
-void Ui::OpenRGBE131SettingsPage::on_SaveE131ConfigurationButton_clicked()
-{
-    json                e131_settings;
-
-    /*-------------------------------------------------*\
-    | Get E1.31 settings from settings manager          |
-    \*-------------------------------------------------*/
-    e131_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("E131Devices");
-
-    e131_settings["devices"].clear();
-
-    for(unsigned int device_idx = 0; device_idx < entries.size(); device_idx++)
-    {
-        /*-------------------------------------------------*\
-        | Required parameters                               |
-        \*-------------------------------------------------*/
-        e131_settings["devices"][device_idx]["name"]                = entries[device_idx]->ui->NameEdit->text().toStdString();
-        e131_settings["devices"][device_idx]["start_universe"]      = entries[device_idx]->ui->StartUniverseEdit->text().toUInt();
-        e131_settings["devices"][device_idx]["start_channel"]       = entries[device_idx]->ui->StartChannelEdit->text().toUInt();
-        e131_settings["devices"][device_idx]["num_leds"]            = entries[device_idx]->ui->NumLEDsEdit->text().toUInt();
-        e131_settings["devices"][device_idx]["type"]                = entries[device_idx]->ui->TypeComboBox->currentIndex();
-        e131_settings["devices"][device_idx]["rgb_order"]           = entries[device_idx]->ui->RGBOrderComboBox->currentIndex();
-
-        /*-------------------------------------------------*\
-        | Optional parameters                               |
-        \*-------------------------------------------------*/
-        if(entries[device_idx]->ui->IPEdit->text() != "")
-        {
-            e131_settings["devices"][device_idx]["ip"]              = entries[device_idx]->ui->IPEdit->text().toStdString();
-        }
-
-        if(e131_settings["devices"][device_idx]["type"] == 2)
-        {
-            e131_settings["devices"][device_idx]["matrix_width"]    = entries[device_idx]->ui->MatrixWidthEdit->text().toUInt();
-            e131_settings["devices"][device_idx]["matrix_height"]   = entries[device_idx]->ui->MatrixHeightEdit->text().toUInt();
-            e131_settings["devices"][device_idx]["matrix_order"]    = entries[device_idx]->ui->MatrixOrderComboBox->currentIndex();
-        }
-
-        if(entries[device_idx]->ui->UniverseSizeEdit->text() != "")
-        {
-            e131_settings["devices"][device_idx]["universe_size"]   = entries[device_idx]->ui->UniverseSizeEdit->text().toUInt();
-        }
-
-        if(entries[device_idx]->ui->KeepaliveTimeEdit->text() != "")
-        {
-            e131_settings["devices"][device_idx]["keepalive_time"]  = entries[device_idx]->ui->KeepaliveTimeEdit->text().toUInt();
-        }
-    }
-
-    ResourceManager::get()->GetSettingsManager()->SetSettings("E131Devices", e131_settings);
-    ResourceManager::get()->GetSettingsManager()->SaveSettings();
-}
diff --git a/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsPage.h b/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsPage.h
deleted file mode 100644
index 4fdfeab2..00000000
--- a/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsPage.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBE131SettingsPage.h                                 |
-|                                                           |
-|   User interface for OpenRGB E1.31 settings page          |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QWidget>
-#include "ui_OpenRGBE131SettingsPage.h"
-#include "OpenRGBE131SettingsEntry.h"
-
-namespace Ui
-{
-    class OpenRGBE131SettingsPage;
-}
-
-class Ui::OpenRGBE131SettingsPage : public QWidget
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBE131SettingsPage(QWidget *parent = nullptr);
-    ~OpenRGBE131SettingsPage();
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_AddE131DeviceButton_clicked();
-
-    void on_RemoveE131DeviceButton_clicked();
-
-    void on_SaveE131ConfigurationButton_clicked();
-
-private:
-    Ui::OpenRGBE131SettingsPageUi *ui;
-    std::vector<OpenRGBE131SettingsEntry*> entries;
-};
diff --git a/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsPage.ui b/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsPage.ui
deleted file mode 100644
index 0d1bda23..00000000
--- a/qt/OpenRGBE131SettingsPage/OpenRGBE131SettingsPage.ui
+++ /dev/null
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBE131SettingsPageUi</class>
- <widget class="QWidget" name="OpenRGBE131SettingsPageUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>400</width>
-    <height>300</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>E131 settings page</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="1" column="0">
-    <widget class="QPushButton" name="AddE131DeviceButton">
-     <property name="text">
-      <string>Add</string>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="1">
-    <widget class="QPushButton" name="RemoveE131DeviceButton">
-     <property name="text">
-      <string>Remove</string>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="2">
-    <widget class="QPushButton" name="SaveE131ConfigurationButton">
-     <property name="text">
-      <string>Save</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="0" colspan="3">
-    <widget class="QListWidget" name="E131DeviceList">
-     <property name="verticalScrollMode">
-      <enum>QAbstractItemView::ScrollPerPixel</enum>
-     </property>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBFont.cpp b/qt/OpenRGBFont.cpp
deleted file mode 100644
index 9913c7bc..00000000
--- a/qt/OpenRGBFont.cpp
+++ /dev/null
@@ -1,51 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBFont.cpp                                           |
-|                                                           |
-|   Functionality for OpenRGB custom font icons             |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QStringList>
-#include <QFontDatabase>
-#include "OpenRGBFont.h"
-
-OpenRGBFont* OpenRGBFont::instance;
-
-OpenRGBFont::OpenRGBFont()
-{
-}
-
-OpenRGBFont *OpenRGBFont::Get()
-{
-    if(!instance)
-    {
-        instance = new OpenRGBFont();
-        instance->fontId = QFontDatabase::addApplicationFont(":/fonts/OpenRGB.ttf");
-
-        if(instance->fontId == -1)
-        {
-            printf("Cannot load requested font.\n");
-        }
-        else
-        {
-            QString family = QFontDatabase::applicationFontFamilies(instance->fontId).at(0);
-            instance->font = QFont(family);
-            instance->font.setStyleStrategy(QFont::PreferAntialias);
-        }
-    }
-
-    return instance;
-}
-
-QString OpenRGBFont::icon(int glyph)
-{
-    return QChar(glyph);
-}
-
-QFont OpenRGBFont::GetFont()
-{
-    return Get()->font;
-}
-
diff --git a/qt/OpenRGBFont.h b/qt/OpenRGBFont.h
deleted file mode 100644
index 415b1d0c..00000000
--- a/qt/OpenRGBFont.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBFont.h                                             |
-|                                                           |
-|   Functionality for OpenRGB custom font icons             |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QFont>
-#include <QString>
-
-class OpenRGBFont
-{
-public:
-    static OpenRGBFont* Get();
-
-    enum Glyph
-    {
-        bulb                = 0xF001,
-        controller          = 0xF002,
-        cooler              = 0xF003,
-        data                = 0xF004,
-        dram                = 0xF005,
-        drive               = 0xF006,
-        extension           = 0xF007,
-        gamepad             = 0xF008,
-        gpu                 = 0xF009,
-        headset             = 0xF00A,
-        headsetstand        = 0xF00B,
-        info                = 0xF00C,
-        keyboard            = 0xF00D,
-        keypad              = 0xF00E,
-        ledstrip            = 0xF00F,
-        mainboard           = 0xF010,
-        mic                 = 0xF011,
-        mouse               = 0xF012,
-        mousemat            = 0xF013,
-        music_speaker       = 0xF014,
-        options             = 0xF015,
-        pc_case             = 0xF016,
-        serial              = 0xF017,
-        terminal            = 0xF018,
-        toolbox             = 0xF019,
-        unknown             = 0xF01A,
-        virtual_controller  = 0xF01B,
-        usb                 = 0xF01C
-    };
-
-    static QString icon(int);
-    static QFont GetFont();
-
-private:
-    OpenRGBFont();
-
-    static OpenRGBFont* instance;
-    int fontId = -1;
-    QFont font;
-};
diff --git a/qt/OpenRGBHardwareIDsDialog/OpenRGBHardwareIDsDialog.cpp b/qt/OpenRGBHardwareIDsDialog/OpenRGBHardwareIDsDialog.cpp
deleted file mode 100644
index 662927c6..00000000
--- a/qt/OpenRGBHardwareIDsDialog/OpenRGBHardwareIDsDialog.cpp
+++ /dev/null
@@ -1,143 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBHardwareIDsDialog.cpp                              |
-|                                                           |
-|   User interface for OpenRGB Hardware IDs dialog          |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QString>
-#include <QClipboard>
-#include <hidapi.h>
-#include <libusb.h>
-#include "OpenRGBHardwareIDsDialog.h"
-#include "ui_OpenRGBHardwareIDsDialog.h"
-#include "ResourceManager.h"
-#include "StringUtils.h"
-
-Ui::OpenRGBHardwareIDsDialog::OpenRGBHardwareIDsDialog(QWidget *parent) :
-    QDialog(parent),
-    ui(new Ui::OpenRGBHardwareIDsDialogUi)
-{
-    ui->setupUi(this);
-    ui->HardwareIdsList->header()->resizeSection(0 /*column index*/, 300 /*width*/);
-    ui->HardwareIdsList->header()->resizeSection(1 /*column index*/, 200 /*width*/);
-    ui->HardwareIdsList->header()->resizeSection(2 /*column index*/, 100 /*width*/);
-}
-
-Ui::OpenRGBHardwareIDsDialog::~OpenRGBHardwareIDsDialog()
-{
-    delete ui;
-}
-
-int Ui::OpenRGBHardwareIDsDialog::show()
-{
-    /*---------------------------------------------------------*\
-    | Add i2c busses infos                                      |
-    \*---------------------------------------------------------*/
-    std::vector<i2c_smbus_interface*> i2CBusses = ResourceManager::get()->GetI2CBusses();
-
-    // The widget takes control over items after creation
-    QTreeWidgetItem* i2c_top = new QTreeWidgetItem(ui->HardwareIdsList, {"i2c busses"});
-    strings.push_back("[ i2c busses ]");
-
-    for(i2c_smbus_interface* bus : i2CBusses)
-    {
-        char line[550];
-        snprintf(line, 550, "%04X:%04X %04X:%04X", bus->pci_vendor, bus->pci_device, bus->pci_subsystem_vendor, bus->pci_subsystem_device);
-        new QTreeWidgetItem(i2c_top, {line, bus->device_name});
-
-        snprintf(line, 550, "%04X:%04X %04X:%04X - %s", bus->pci_vendor, bus->pci_device, bus->pci_subsystem_vendor, bus->pci_subsystem_device, bus->device_name);
-        strings.push_back(line);
-    }
-
-    /*---------------------------------------------------------*\
-    | Add HID devices infos                                     |
-    \*---------------------------------------------------------*/
-    hid_device_info*    hid_devices         = NULL;
-    hid_devices = hid_enumerate(0,0);
-
-    hid_device_info*    current_hid_device;
-    current_hid_device  = hid_devices;
-
-    QTreeWidgetItem* hid_top = new QTreeWidgetItem(ui->HardwareIdsList, {"HID devices"});
-    strings.push_back("\n[ HID devices ]");
-
-    while(current_hid_device)
-    {
-        const char* manu_name = StringUtils::wchar_to_char(current_hid_device->manufacturer_string);
-        const char* prod_name = StringUtils::wchar_to_char(current_hid_device->product_string);
-
-        char line[550];
-
-        snprintf(line, 550, "[%04X:%04X U=%04X P=0x%04X I=%d]", current_hid_device->vendor_id, current_hid_device->product_id, current_hid_device->usage, current_hid_device->usage_page, current_hid_device->interface_number);
-        new QTreeWidgetItem(hid_top, {line, prod_name, manu_name});
-
-        snprintf(line, 550, "[%04X:%04X U=%04X P=0x%04X I=%d] %s - %s", current_hid_device->vendor_id, current_hid_device->product_id, current_hid_device->usage, current_hid_device->usage_page, current_hid_device->interface_number, manu_name, prod_name);
-        strings.push_back(line);
-
-        current_hid_device = current_hid_device->next;
-    }
-
-    /*---------------------------------------------------------*\
-    | Add LibUSB devices infos                                  |
-    \*---------------------------------------------------------*/
-    libusb_device** devices = nullptr;
-
-    QTreeWidgetItem* libusb_top = new QTreeWidgetItem(ui->HardwareIdsList, {"LibUSB devices"});
-    strings.push_back("\n[ LibUSB devices ]");
-
-    int ret;
-
-    ret = libusb_init(NULL);
-
-    if(ret < 0)
-    {
-        return 0;
-    }
-
-    ret = libusb_get_device_list(NULL, &devices);
-
-    if(ret < 0)
-    {
-        return 0;
-    }
-
-    int deviceCount = ret;
-
-    for(int i = 0; i < deviceCount; i++)
-    {
-        libusb_device* device = devices[i];
-        libusb_device_descriptor descriptor;
-
-        ret = libusb_get_device_descriptor(device, &descriptor);
-
-        if(ret < 0)
-        {
-            continue;
-        }
-
-        char line[512];
-        snprintf(line, 512, "%04X:%04X", descriptor.idVendor, descriptor.idProduct);
-        new QTreeWidgetItem(libusb_top, {line});
-        strings.push_back(line);
-    }
-
-    if(devices != nullptr)
-    {
-        libusb_free_device_list(devices, 1);
-    }
-
-    i2c_top->setExpanded(true);
-    hid_top->setExpanded(true);
-    libusb_top->setExpanded(true);
-
-    return this->exec();
-}
-
-void Ui::OpenRGBHardwareIDsDialog::on_CopyToClipboardButton_clicked()
-{
-    QClipboard *clipboard = QGuiApplication::clipboard();
-    clipboard->setText(strings.join("\n"));
-}
diff --git a/qt/OpenRGBHardwareIDsDialog/OpenRGBHardwareIDsDialog.h b/qt/OpenRGBHardwareIDsDialog/OpenRGBHardwareIDsDialog.h
deleted file mode 100644
index 16b520ef..00000000
--- a/qt/OpenRGBHardwareIDsDialog/OpenRGBHardwareIDsDialog.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBHardwareIDsDialog.h                                |
-|                                                           |
-|   User interface for OpenRGB Hardware IDs dialog          |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QDialog>
-#include "ui_OpenRGBHardwareIDsDialog.h"
-
-namespace Ui
-{
-    class OpenRGBHardwareIDsDialog;
-}
-
-class Ui::OpenRGBHardwareIDsDialog : public QDialog
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBHardwareIDsDialog(QWidget *parent = nullptr);
-    ~OpenRGBHardwareIDsDialog();
-
-    int show();
-
-private slots:
-    void on_CopyToClipboardButton_clicked();
-
-private:
-    Ui::OpenRGBHardwareIDsDialogUi *ui;
-    QStringList strings;
-};
diff --git a/qt/OpenRGBHardwareIDsDialog/OpenRGBHardwareIDsDialog.ui b/qt/OpenRGBHardwareIDsDialog/OpenRGBHardwareIDsDialog.ui
deleted file mode 100644
index 33084ef1..00000000
--- a/qt/OpenRGBHardwareIDsDialog/OpenRGBHardwareIDsDialog.ui
+++ /dev/null
@@ -1,47 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBHardwareIDsDialogUi</class>
- <widget class="QWidget" name="OpenRGBHardwareIDsDialogUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>700</width>
-    <height>500</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Hardware IDs</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="1" column="0">
-    <widget class="QPushButton" name="CopyToClipboardButton">
-     <property name="text">
-      <string>Copy to clipboard</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="0">
-    <widget class="QTreeWidget" name="HardwareIdsList">
-     <column>
-      <property name="text">
-       <string>Location</string>
-      </property>
-     </column>
-     <column>
-      <property name="text">
-       <string>Device</string>
-      </property>
-     </column>
-     <column>
-      <property name="text">
-       <string>Vendor</string>
-      </property>
-     </column>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBPluginContainer/OpenRGBPluginContainer.cpp b/qt/OpenRGBPluginContainer/OpenRGBPluginContainer.cpp
deleted file mode 100644
index 866e5b3a..00000000
--- a/qt/OpenRGBPluginContainer/OpenRGBPluginContainer.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBPluginContainer.h                                  |
-|                                                           |
-|   User interface entry for OpenRGB plugin container widget|
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBPluginContainer.h"
-#include "ui_OpenRGBPluginContainer.h"
-
-Ui::OpenRGBPluginContainer::OpenRGBPluginContainer(QWidget *plugin, QWidget *parent) :
-    QWidget(parent),
-    ui(new Ui::OpenRGBPluginContainerUi)
-{
-    ui->setupUi(this);
-
-    plugin_widget = plugin;
-    plugin_widget->setParent(this);
-
-    ui->PluginContainerLayout->layout()->addWidget(plugin_widget);
-
-    Hide();
-}
-
-Ui::OpenRGBPluginContainer::~OpenRGBPluginContainer()
-{
-    delete ui;
-}
-
-void Ui::OpenRGBPluginContainer::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void Ui::OpenRGBPluginContainer::Hide()
-{
-    plugin_widget->hide();
-    ui->PluginContainerLayout->layout()->invalidate();
-}
-
-void Ui::OpenRGBPluginContainer::Show()
-{
-    plugin_widget->show();
-    ui->PluginContainerLayout->layout()->invalidate();
-}
diff --git a/qt/OpenRGBPluginContainer/OpenRGBPluginContainer.h b/qt/OpenRGBPluginContainer/OpenRGBPluginContainer.h
deleted file mode 100644
index a9dc68c6..00000000
--- a/qt/OpenRGBPluginContainer/OpenRGBPluginContainer.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBPluginContainer.h                                  |
-|                                                           |
-|   User interface entry for OpenRGB plugin container widget|
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QWidget>
-#include "ui_OpenRGBPluginContainer.h"
-
-namespace Ui
-{
-    class OpenRGBPluginContainer;
-}
-
-class Ui::OpenRGBPluginContainer : public QWidget
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBPluginContainer(QWidget *plugin, QWidget *parent = nullptr);
-    ~OpenRGBPluginContainer();
-    void Hide();
-    void Show();
-
-    QWidget* plugin_widget;
-
-private:
-    Ui::OpenRGBPluginContainerUi *ui;
-
-private slots:
-    void changeEvent(QEvent *event);
-};
diff --git a/qt/OpenRGBPluginContainer/OpenRGBPluginContainer.ui b/qt/OpenRGBPluginContainer/OpenRGBPluginContainer.ui
deleted file mode 100644
index ceecf696..00000000
--- a/qt/OpenRGBPluginContainer/OpenRGBPluginContainer.ui
+++ /dev/null
@@ -1,42 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBPluginContainerUi</class>
- <widget class="QWidget" name="OpenRGBPluginContainerUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>256</width>
-    <height>120</height>
-   </rect>
-  </property>
-  <property name="sizePolicy">
-   <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
-    <horstretch>0</horstretch>
-    <verstretch>0</verstretch>
-   </sizepolicy>
-  </property>
-  <property name="windowTitle">
-   <string>Plugin container</string>
-  </property>
-  <layout class="QVBoxLayout" name="verticalLayout">
-   <property name="leftMargin">
-    <number>0</number>
-   </property>
-   <property name="topMargin">
-    <number>0</number>
-   </property>
-   <property name="rightMargin">
-    <number>0</number>
-   </property>
-   <property name="bottomMargin">
-    <number>0</number>
-   </property>
-   <item>
-    <layout class="QGridLayout" name="PluginContainerLayout"/>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBPluginsPage/OpenRGBPluginsEntry.cpp b/qt/OpenRGBPluginsPage/OpenRGBPluginsEntry.cpp
deleted file mode 100644
index db44785b..00000000
--- a/qt/OpenRGBPluginsPage/OpenRGBPluginsEntry.cpp
+++ /dev/null
@@ -1,53 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBPluginsEntry.cpp                                   |
-|                                                           |
-|   User interface entry for OpenRGB plugin entry widget    |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBPluginsEntry.h"
-#include "ui_OpenRGBPluginsEntry.h"
-
-using namespace Ui;
-
-OpenRGBPluginsEntry::OpenRGBPluginsEntry(QWidget *parent) :
-    QWidget(parent),
-    ui(new Ui::OpenRGBPluginsEntryUi)
-{
-    ui->setupUi(this);
-
-    EnableClickCallbackVal  = nullptr;
-    EnableClickCallbackArg  = nullptr;
-}
-
-OpenRGBPluginsEntry::~OpenRGBPluginsEntry()
-{
-    delete ui;
-}
-
-void OpenRGBPluginsEntry::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void OpenRGBPluginsEntry::RegisterEnableClickCallback(EnableClickCallback new_callback, void * new_callback_arg)
-{
-    EnableClickCallbackVal  = new_callback;
-    EnableClickCallbackArg  = new_callback_arg;
-}
-
-void Ui::OpenRGBPluginsEntry::on_EnabledCheckBox_stateChanged(int /*checked*/)
-{
-    /*-------------------------------------------------*\
-    | Call the callbacks                                |
-    \*-------------------------------------------------*/
-    if(EnableClickCallbackVal != nullptr)
-    {
-        EnableClickCallbackVal(EnableClickCallbackArg, this);
-    }
-}
diff --git a/qt/OpenRGBPluginsPage/OpenRGBPluginsEntry.h b/qt/OpenRGBPluginsPage/OpenRGBPluginsEntry.h
deleted file mode 100644
index 596ea560..00000000
--- a/qt/OpenRGBPluginsPage/OpenRGBPluginsEntry.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBPluginsEntry.h                                     |
-|                                                           |
-|   User interface entry for OpenRGB plugin entry widget    |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QWidget>
-#include "ui_OpenRGBPluginsEntry.h"
-
-namespace Ui
-{
-    class OpenRGBPluginsEntry;
-}
-
-typedef void (*EnableClickCallback)(void *, void *);
-
-class Ui::OpenRGBPluginsEntry : public QWidget
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBPluginsEntry(QWidget *parent = nullptr);
-    ~OpenRGBPluginsEntry();
-
-    Ui::OpenRGBPluginsEntryUi * ui;
-    bool                        is_system;
-
-    void RegisterEnableClickCallback(EnableClickCallback new_callback, void * new_callback_arg);
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_EnabledCheckBox_stateChanged(int checked);
-
-private:
-    EnableClickCallback EnableClickCallbackVal;
-    void *              EnableClickCallbackArg;
-};
diff --git a/qt/OpenRGBPluginsPage/OpenRGBPluginsEntry.ui b/qt/OpenRGBPluginsPage/OpenRGBPluginsEntry.ui
deleted file mode 100644
index 24de9d6f..00000000
--- a/qt/OpenRGBPluginsPage/OpenRGBPluginsEntry.ui
+++ /dev/null
@@ -1,197 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBPluginsEntryUi</class>
- <widget class="QWidget" name="OpenRGBPluginsEntryUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>478</width>
-    <height>238</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Plugins entry</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="0" column="0">
-    <widget class="QGroupBox" name="groupBox">
-     <property name="title">
-      <string/>
-     </property>
-     <layout class="QGridLayout" name="gridLayout_2">
-      <item row="5" column="1">
-       <widget class="QLabel" name="URLLabel">
-        <property name="text">
-         <string>URL:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="0" column="0" rowspan="8">
-       <widget class="QLabel" name="IconView">
-        <property name="sizePolicy">
-         <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
-          <horstretch>0</horstretch>
-          <verstretch>0</verstretch>
-         </sizepolicy>
-        </property>
-        <property name="minimumSize">
-         <size>
-          <width>64</width>
-          <height>64</height>
-         </size>
-        </property>
-        <property name="maximumSize">
-         <size>
-          <width>64</width>
-          <height>64</height>
-         </size>
-        </property>
-        <property name="text">
-         <string notr="true">Icon</string>
-        </property>
-        <property name="alignment">
-         <set>Qt::AlignCenter</set>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="2">
-       <widget class="QLabel" name="URLValue">
-        <property name="text">
-         <string notr="true">URL Value</string>
-        </property>
-        <property name="openExternalLinks">
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
-      <item row="7" column="1">
-       <widget class="QLabel" name="EnabledLabel">
-        <property name="text">
-         <string>Enabled</string>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="1">
-       <widget class="QLabel" name="DescriptionLabel">
-        <property name="sizePolicy">
-         <sizepolicy hsizetype="Minimum" vsizetype="Preferred">
-          <horstretch>0</horstretch>
-          <verstretch>0</verstretch>
-         </sizepolicy>
-        </property>
-        <property name="text">
-         <string>Description:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="0" column="2">
-       <widget class="QLabel" name="NameValue">
-        <property name="sizePolicy">
-         <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
-          <horstretch>0</horstretch>
-          <verstretch>0</verstretch>
-         </sizepolicy>
-        </property>
-        <property name="text">
-         <string notr="true">Name Value</string>
-        </property>
-       </widget>
-      </item>
-      <item row="2" column="2">
-       <widget class="QLabel" name="PathValue">
-        <property name="text">
-         <string notr="true">Path Value</string>
-        </property>
-       </widget>
-      </item>
-      <item row="3" column="2">
-       <widget class="QLabel" name="VersionValue">
-        <property name="text">
-         <string notr="true">Version Value</string>
-        </property>
-       </widget>
-      </item>
-      <item row="4" column="2">
-       <widget class="QLabel" name="CommitValue">
-        <property name="text">
-         <string notr="true">Commit Value</string>
-        </property>
-       </widget>
-      </item>
-      <item row="0" column="1">
-       <widget class="QLabel" name="NameLabel">
-        <property name="sizePolicy">
-         <sizepolicy hsizetype="Minimum" vsizetype="Preferred">
-          <horstretch>0</horstretch>
-          <verstretch>0</verstretch>
-         </sizepolicy>
-        </property>
-        <property name="text">
-         <string>Name:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="2" column="1">
-       <widget class="QLabel" name="PathLabel">
-        <property name="text">
-         <string>Path:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="7" column="2">
-       <widget class="QCheckBox" name="EnabledCheckBox">
-        <property name="text">
-         <string/>
-        </property>
-       </widget>
-      </item>
-      <item row="3" column="1">
-       <widget class="QLabel" name="VersionLabel">
-        <property name="text">
-         <string>Version:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="4" column="1">
-       <widget class="QLabel" name="CommitLabel">
-        <property name="text">
-         <string>Commit:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="2">
-       <widget class="QLabel" name="DescriptionValue">
-        <property name="sizePolicy">
-         <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
-          <horstretch>0</horstretch>
-          <verstretch>0</verstretch>
-         </sizepolicy>
-        </property>
-        <property name="text">
-         <string notr="true">Description Value</string>
-        </property>
-       </widget>
-      </item>
-      <item row="6" column="1">
-       <widget class="QLabel" name="APIVersionLabel">
-        <property name="text">
-         <string>API Version:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="6" column="2">
-       <widget class="QLabel" name="APIVersionValue">
-        <property name="text">
-         <string>API Version Value</string>
-        </property>
-       </widget>
-      </item>
-     </layout>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBPluginsPage/OpenRGBPluginsList.cpp b/qt/OpenRGBPluginsPage/OpenRGBPluginsList.cpp
deleted file mode 100644
index e7255618..00000000
--- a/qt/OpenRGBPluginsPage/OpenRGBPluginsList.cpp
+++ /dev/null
@@ -1,53 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBPluginsList.cpp                                    |
-|                                                           |
-|   User interface entry for OpenRGB plugin list widget     |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QMimeData>
-#include <QUrl>
-#include "OpenRGBPluginsList.h"
-
-OpenRGBPluginsList::OpenRGBPluginsList(QWidget *parent) : QListWidget (parent)
-{
-    setAcceptDrops(true);
-}
-
-void OpenRGBPluginsList::dropEvent(QDropEvent *event)
-{
-    const QMimeData* mimeData = event->mimeData();
-
-    if (mimeData->hasUrls())
-    {
-        std::vector<std::string> path_list;
-
-        QList<QUrl> urls = mimeData->urls();
-
-        for(const QUrl& url: urls)
-        {
-            path_list.push_back(url.toLocalFile().toStdString());
-        }
-
-        emit PluginsDropped(path_list);
-    }
-}
-
-void OpenRGBPluginsList::dragEnterEvent(QDragEnterEvent *event)
-{
-    if (event->mimeData()->hasUrls())
-    {
-        event->acceptProposedAction();
-    }
-    else
-    {
-        event->ignore();
-    }
-}
-
-void OpenRGBPluginsList::dragMoveEvent(QDragMoveEvent *event)
-{
-    event->acceptProposedAction();
-}
diff --git a/qt/OpenRGBPluginsPage/OpenRGBPluginsList.h b/qt/OpenRGBPluginsPage/OpenRGBPluginsList.h
deleted file mode 100644
index d9244ce6..00000000
--- a/qt/OpenRGBPluginsPage/OpenRGBPluginsList.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBPluginsList.h                                      |
-|                                                           |
-|   User interface entry for OpenRGB plugin list widget     |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QListWidget>
-#include <QDropEvent>
-#include <QDragEnterEvent>
-
-class OpenRGBPluginsList : public QListWidget
-{
-    Q_OBJECT
-
-public:
-    OpenRGBPluginsList(QWidget *parent = nullptr);
-
-signals:
-    void PluginsDropped(std::vector<std::string>);
-
-protected:
-    void dropEvent(QDropEvent *event) override;
-    void dragEnterEvent(QDragEnterEvent *event) override;
-    void dragMoveEvent(QDragMoveEvent *event) override;
-};
diff --git a/qt/OpenRGBPluginsPage/OpenRGBPluginsPage.cpp b/qt/OpenRGBPluginsPage/OpenRGBPluginsPage.cpp
deleted file mode 100644
index b550c762..00000000
--- a/qt/OpenRGBPluginsPage/OpenRGBPluginsPage.cpp
+++ /dev/null
@@ -1,377 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBPluginsPage.cpp                                    |
-|                                                           |
-|   User interface entry for OpenRGB plugin settings        |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QFileDialog>
-#include <QMessageBox>
-#include <QGraphicsPixmapItem>
-#include <QGraphicsScene>
-#include "filesystem.h"
-#include "LogManager.h"
-#include "SettingsManager.h"
-#include "OpenRGBPluginsPage.h"
-#include "ui_OpenRGBPluginsPage.h"
-
-void EnableClickCallbackFunction(void* this_ptr, void* entry_ptr)
-{
-    Ui::OpenRGBPluginsPage* this_page = (Ui::OpenRGBPluginsPage*)this_ptr;
-
-    this_page->on_EnableButton_clicked((Ui::OpenRGBPluginsEntry*)entry_ptr);
-}
-
-Ui::OpenRGBPluginsPage::OpenRGBPluginsPage(PluginManager* plugin_manager_ptr, QWidget *parent) :
-    QWidget(parent),
-    ui(new Ui::OpenRGBPluginsPageUi)
-{
-    plugin_manager = plugin_manager_ptr;
-    ui->setupUi(this);
-
-    RefreshList();
-}
-
-Ui::OpenRGBPluginsPage::~OpenRGBPluginsPage()
-{
-    delete ui;
-}
-
-void Ui::OpenRGBPluginsPage::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void Ui::OpenRGBPluginsPage::RefreshList()
-{
-    ui->PluginsList->clear();
-    entries.clear();
-
-    for(const OpenRGBPluginEntry& plugin: plugin_manager->ActivePlugins)
-    {
-        OpenRGBPluginsEntry* entry = new OpenRGBPluginsEntry();
-
-        /*---------------------------------------------------------*\
-        | Fill in plugin information fields                         |
-        \*---------------------------------------------------------*/
-        entry->ui->NameValue->setText(QString::fromStdString(plugin.info.Name));
-        entry->ui->DescriptionValue->setText(QString::fromStdString(plugin.info.Description));
-        entry->ui->VersionValue->setText(QString::fromStdString(plugin.info.Version));
-        entry->ui->CommitValue->setText(QString::fromStdString(plugin.info.Commit));
-        entry->ui->URLValue->setText(QString::fromStdString(plugin.info.URL));
-        entry->ui->APIVersionValue->setText(QString::number(plugin.api_version));
-
-        /*---------------------------------------------------------*\
-        | If the plugin is incompatible, highlight the API version  |
-        | in red and disable the enable checkbox                    |
-        \*---------------------------------------------------------*/
-        if(plugin.incompatible)
-        {
-            entry->ui->APIVersionValue->setStyleSheet("QLabel { color : red; }");
-            entry->ui->EnabledCheckBox->setEnabled(false);
-        }
-
-        /*---------------------------------------------------------*\
-        | Fill in plugin icon                                       |
-        \*---------------------------------------------------------*/
-        QPixmap pixmap(QPixmap::fromImage(plugin.info.Icon));
-
-        entry->ui->IconView->setPixmap(pixmap);
-        entry->ui->IconView->setScaledContents(true);
-
-        /*---------------------------------------------------------*\
-        | Fill in plugin path                                       |
-        \*---------------------------------------------------------*/
-        entry->ui->PathValue->setText(QString::fromStdString(plugin.path));
-
-        /*---------------------------------------------------------*\
-        | Fill in plugin enabled status                             |
-        \*---------------------------------------------------------*/
-        entry->ui->EnabledCheckBox->setChecked((plugin.enabled));
-
-        entry->RegisterEnableClickCallback(EnableClickCallbackFunction, this);
-
-        entry->is_system = plugin.is_system;
-
-        /*---------------------------------------------------------*\
-        | Add the entry to the plugin list                          |
-        \*---------------------------------------------------------*/
-        QListWidgetItem* item = new QListWidgetItem;
-
-        item->setSizeHint(entry->sizeHint());
-
-        ui->PluginsList->addItem(item);
-        ui->PluginsList->setItemWidget(item, entry);
-
-        entries.push_back(entry);
-    }
-}
-
-void Ui::OpenRGBPluginsPage::on_InstallPluginButton_clicked()
-{
-    /*-----------------------------------------------------*\
-    | Open a file selection prompt to choose the plugin file|
-    \*-----------------------------------------------------*/
-    QString     install_file    = QFileDialog::getOpenFileName(this, tr("Install OpenRGB Plugin"), "", tr("Plugin files (*.dll *.dylib *.so *.so.*)"));
-
-    bool installed = InstallPlugin(install_file.toStdString());
-
-    if(installed)
-    {
-        RefreshList();
-    }
-}
-
-bool Ui::OpenRGBPluginsPage::InstallPlugin(std::string install_file)
-{
-    filesystem::path from_path = filesystem::u8path(install_file);
-    filesystem::path to_path   = ResourceManager::get()->GetConfigurationDirectory() / "plugins" / from_path.filename();
-    bool        match           = false;
-
-    LOG_TRACE("[OpenRGBPluginsPage] Installing plugin %s", install_file.c_str());
-
-    /*-----------------------------------------------------*\
-    | Check if a plugin with this path already exists       |
-    \*-----------------------------------------------------*/
-    for(unsigned int plugin_idx = 0; plugin_idx < plugin_manager->ActivePlugins.size(); plugin_idx++)
-    {
-        if(to_path == plugin_manager->ActivePlugins[plugin_idx].path)
-        {
-            match = true;
-            break;
-        }
-    }
-
-    /*-----------------------------------------------------*\
-    | If this plugin already exists, prompt to replace it   |
-    \*-----------------------------------------------------*/
-    if(match == true)
-    {
-        QMessageBox::StandardButton reply;
-
-        reply = QMessageBox::question(this, tr("Replace Plugin"), tr("A plugin with this filename is already installed.  Are you sure you want to replace this plugin?"), QMessageBox::Yes | QMessageBox::No);
-
-        if(reply != QMessageBox::Yes)
-        {
-            return false;
-        }
-    }
-
-    /*-----------------------------------------------------*\
-    | When replacing, remove the existing plugin before     |
-    | copying the file and adding the new one               |
-    \*-----------------------------------------------------*/
-    try
-    {
-        plugin_manager->RemovePlugin(to_path);
-
-        LOG_TRACE("[OpenRGBPluginsPage] Copying from %s to %s", from_path.c_str(), to_path.c_str());
-        filesystem::copy(from_path, to_path, filesystem::copy_options::overwrite_existing);
-
-        plugin_manager->AddPlugin(to_path, false);
-
-        return true;
-    }
-    catch(const std::exception& e)
-    {
-        LOG_ERROR("[OpenRGBPluginsPage] Failed to install plugin: %s", e.what());
-    }
-
-    return false;
-}
-
-void Ui::OpenRGBPluginsPage::on_RemovePluginButton_clicked()
-{
-    QMessageBox::StandardButton reply;
-
-    /*-----------------------------------------------------*\
-    | Confirm plugin removal with message box               |
-    \*-----------------------------------------------------*/
-    reply = QMessageBox::question(this, tr("Remove Plugin"), tr("Are you sure you want to remove this plugin?"), QMessageBox::Yes | QMessageBox::No);
-
-    if(reply != QMessageBox::Yes)
-    {
-        return;
-    }
-
-    /*-----------------------------------------------------*\
-    | Get index of selected plugin entry                    |
-    \*-----------------------------------------------------*/
-    int cur_row = ui->PluginsList->currentRow();
-
-    if(cur_row < 0)
-    {
-        return;
-    }
-
-    /*-----------------------------------------------------*\
-    | Don't allow removing system plugins                   |
-    \*-----------------------------------------------------*/
-    if(entries[cur_row]->is_system)
-    {
-        return;
-    }
-
-    /*-----------------------------------------------------*\
-    | Open plugin settings                                  |
-    \*-----------------------------------------------------*/
-    json plugin_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Plugins");
-
-    /*-----------------------------------------------------*\
-    | Find plugin's entry in settings and remove it         |
-    \*-----------------------------------------------------*/
-    if(plugin_settings.contains("plugins"))
-    {
-        for(unsigned int plugin_idx = 0; plugin_idx < plugin_settings["plugins"].size(); plugin_idx++)
-        {
-            if((plugin_settings["plugins"][plugin_idx].contains("name"))
-             &&(plugin_settings["plugins"][plugin_idx].contains("description")))
-            {
-                if((plugin_settings["plugins"][plugin_idx]["name"] == entries[cur_row]->ui->NameValue->text().toStdString())
-                 &&(plugin_settings["plugins"][plugin_idx]["description"] == entries[cur_row]->ui->DescriptionValue->text().toStdString()))
-                {
-                    plugin_settings["plugins"].erase(plugin_idx);
-
-                    ResourceManager::get()->GetSettingsManager()->SetSettings("Plugins", plugin_settings);
-                    ResourceManager::get()->GetSettingsManager()->SaveSettings();
-
-                    break;
-                }
-            }
-        }
-    }
-
-    /*-----------------------------------------------------*\
-    | Remove plugin entry from GUI plugin entries list      |
-    \*-----------------------------------------------------*/
-    QListWidgetItem* item = ui->PluginsList->takeItem(cur_row);
-
-    ui->PluginsList->removeItemWidget(item);
-    delete item;
-
-    /*-----------------------------------------------------*\
-    | Command plugin manager to unload and remove the plugin|
-    \*-----------------------------------------------------*/
-    plugin_manager->RemovePlugin(entries[cur_row]->ui->PathValue->text().toStdString());
-
-    /*-----------------------------------------------------*\
-    | Delete the plugin file and refresh the GUI            |
-    \*-----------------------------------------------------*/
-    filesystem::remove(entries[cur_row]->ui->PathValue->text().toStdString());
-
-    RefreshList();
-}
-
-void Ui::OpenRGBPluginsPage::on_EnableButton_clicked(OpenRGBPluginsEntry* entry)
-{
-    /*-----------------------------------------------------*\
-    | Open plugin list and check if plugin is in the list   |
-    \*-----------------------------------------------------*/
-    json plugin_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Plugins");
-
-    /*-----------------------------------------------------*\
-    | Search the settings to find the correct index         |
-    \*-----------------------------------------------------*/
-    std::string     name        = "";
-    std::string     description = "";
-    bool            enabled     = entry->ui->EnabledCheckBox->isChecked();
-    bool            found       = false;
-    unsigned int    plugin_ct   = 0;
-    unsigned int    plugin_idx  = 0;
-
-    std::string     entry_name  = entry->ui->NameValue->text().toStdString();
-    std::string     entry_desc  = entry->ui->DescriptionValue->text().toStdString();
-    std::string     entry_path  = entry->ui->PathValue->text().toStdString();
-
-    if(plugin_settings.contains("plugins"))
-    {
-        plugin_ct = (unsigned int)plugin_settings["plugins"].size();
-
-        for(plugin_idx = 0; plugin_idx < (unsigned int)plugin_settings["plugins"].size(); plugin_idx++)
-        {
-            if(plugin_settings["plugins"][plugin_idx].contains("name"))
-            {
-                name        = plugin_settings["plugins"][plugin_idx]["name"];
-            }
-
-            if(plugin_settings["plugins"][plugin_idx].contains("description"))
-            {
-                description = plugin_settings["plugins"][plugin_idx]["description"];
-            }
-
-            if((entry_name == name)
-             &&(entry_desc == description))
-            {
-                found = true;
-                break;
-            }
-        }
-    }
-
-    /*-----------------------------------------------------*\
-    | If the plugin was not in the list, add it to the list |
-    | and default it to enabled, then save the settings     |
-    \*-----------------------------------------------------*/
-    if(!found)
-    {
-        plugin_settings["plugins"][plugin_ct]["name"]           = entry_name;
-        plugin_settings["plugins"][plugin_ct]["description"]    = entry_desc;
-        plugin_settings["plugins"][plugin_ct]["enabled"]        = enabled;
-
-        ResourceManager::get()->GetSettingsManager()->SetSettings("Plugins", plugin_settings);
-        ResourceManager::get()->GetSettingsManager()->SaveSettings();
-    }
-    else
-    {
-        plugin_settings["plugins"][plugin_idx]["enabled"]       = enabled;
-        ResourceManager::get()->GetSettingsManager()->SetSettings("Plugins", plugin_settings);
-        ResourceManager::get()->GetSettingsManager()->SaveSettings();
-    }
-
-    if(enabled)
-    {
-        plugin_manager->EnablePlugin(entry_path);
-    }
-    else
-    {
-        plugin_manager->DisablePlugin(entry_path);
-    }
-}
-
-void Ui::OpenRGBPluginsPage::on_PluginsList_itemSelectionChanged()
-{
-    /*-----------------------------------------------------*\
-    | Get index of selected plugin entry                    |
-    \*-----------------------------------------------------*/
-    int cur_row = ui->PluginsList->currentRow();
-
-    /*-----------------------------------------------------*\
-    | Enable the remove button when there's a selected item |
-    | and the selected item is not a system plugin          |
-    \*-----------------------------------------------------*/
-    if(!entries[cur_row]->is_system)
-    {
-        ui->RemovePluginButton->setEnabled(!ui->PluginsList->selectedItems().empty());
-    }
-}
-
-void Ui::OpenRGBPluginsPage::on_PluginsList_PluginsDropped(std::vector<std::string> path_list)
-{
-    bool installed = false;
-
-    for(const std::string& file_path: path_list)
-    {
-        installed |= InstallPlugin(file_path);
-    }
-
-    if(installed)
-    {
-        RefreshList();
-    }
-}
-
diff --git a/qt/OpenRGBPluginsPage/OpenRGBPluginsPage.h b/qt/OpenRGBPluginsPage/OpenRGBPluginsPage.h
deleted file mode 100644
index b6d61489..00000000
--- a/qt/OpenRGBPluginsPage/OpenRGBPluginsPage.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBPluginsPage.h                                      |
-|                                                           |
-|   User interface entry for OpenRGB plugin settings        |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QWidget>
-#include "OpenRGBPluginsEntry.h"
-#include "ui_OpenRGBPluginsPage.h"
-#include "PluginManager.h"
-
-namespace Ui
-{
-    class OpenRGBPluginsPage;
-}
-
-class Ui::OpenRGBPluginsPage : public QWidget
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBPluginsPage(PluginManager* plugin_manager_ptr, QWidget *parent = nullptr);
-    ~OpenRGBPluginsPage();
-
-    void on_EnableButton_clicked(OpenRGBPluginsEntry* entry);
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_InstallPluginButton_clicked();
-
-    void on_RemovePluginButton_clicked();
-
-    void on_PluginsList_itemSelectionChanged();
-
-    void on_PluginsList_PluginsDropped(std::vector<std::string>);
-
-private:
-    Ui::OpenRGBPluginsPageUi*   ui;
-    PluginManager*              plugin_manager;
-    std::vector<OpenRGBPluginsEntry*> entries;
-
-    bool InstallPlugin(std::string path);
-    void RefreshList();
-};
diff --git a/qt/OpenRGBPluginsPage/OpenRGBPluginsPage.ui b/qt/OpenRGBPluginsPage/OpenRGBPluginsPage.ui
deleted file mode 100644
index 740072a8..00000000
--- a/qt/OpenRGBPluginsPage/OpenRGBPluginsPage.ui
+++ /dev/null
@@ -1,68 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBPluginsPageUi</class>
- <widget class="QWidget" name="OpenRGBPluginsPageUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>400</width>
-    <height>300</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Plugins page</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="1" column="0" colspan="2">
-    <widget class="OpenRGBPluginsList" name="PluginsList">
-     <property name="verticalScrollMode">
-      <enum>QAbstractItemView::ScrollPerPixel</enum>
-     </property>
-    </widget>
-   </item>
-   <item row="2" column="0">
-    <widget class="QPushButton" name="InstallPluginButton">
-     <property name="text">
-      <string>Install Plugin</string>
-     </property>
-    </widget>
-   </item>
-   <item row="2" column="1">
-    <widget class="QPushButton" name="RemovePluginButton">
-     <property name="enabled">
-      <bool>false</bool>
-     </property>
-     <property name="text">
-      <string>Remove Plugin</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="0" colspan="2">
-    <widget class="QLabel" name="LinkLabel">
-     <property name="text">
-      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;Looking for plugins? See the official list at &lt;a href=&quot;https://openrgb.org/plugins.html&quot;&gt;OpenRGB.org&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</string>
-     </property>
-     <property name="textFormat">
-      <enum>Qt::RichText</enum>
-     </property>
-     <property name="alignment">
-      <set>Qt::AlignCenter</set>
-     </property>
-     <property name="openExternalLinks">
-      <bool>true</bool>
-     </property>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <customwidgets>
-  <customwidget>
-   <class>OpenRGBPluginsList</class>
-   <extends>QListWidget</extends>
-   <header>qt/OpenRGBPluginsPage/OpenRGBPluginsList.h</header>
-  </customwidget>
- </customwidgets>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBProfileSaveDialog/OpenRGBProfileSaveDialog.cpp b/qt/OpenRGBProfileSaveDialog/OpenRGBProfileSaveDialog.cpp
deleted file mode 100644
index 3bda9123..00000000
--- a/qt/OpenRGBProfileSaveDialog/OpenRGBProfileSaveDialog.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBProfileSaveDialog.cpp                              |
-|                                                           |
-|   User interface entry for OpenRGB profile save dialog    |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QCloseEvent>
-#include "ResourceManager.h"
-#include "OpenRGBDialog2.h"
-#include "ProfileManager.h"
-#include "OpenRGBProfileSaveDialog.h"
-#include "ui_OpenRGBProfileSaveDialog.h"
-
-#ifdef _WIN32
-#include <QSettings>
-#endif
-
-Ui::OpenRGBProfileSaveDialog::OpenRGBProfileSaveDialog(QWidget *parent) :
-    QDialog(parent), ui(new Ui::OpenRGBProfileSaveDialogUi)
-{
-    ui->setupUi(this);
-
-    std::vector<std::string> filenames = ResourceManager::get()->GetProfileManager()->profile_list;
-
-    if(filenames.empty())
-    {
-        ui->list_profile->setVisible(false);
-        ui->existing->setVisible(false);
-    }
-    else
-    {
-        for(const std::string& f: filenames)
-        {
-            ui->list_profile->addItem(QString::fromStdString(f));
-        }
-
-        connect(ui->list_profile, &QListWidget::currentItemChanged, [=](){
-            ui->lineEdit->setText(ui->list_profile->currentItem()->text());
-        });
-    }
-}
-
-Ui::OpenRGBProfileSaveDialog::~OpenRGBProfileSaveDialog()
-{
-    delete ui;
-}
-
-void Ui::OpenRGBProfileSaveDialog::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-std::string Ui::OpenRGBProfileSaveDialog::show()
-{
-    std::string return_string;
-
-    int result = this->exec();
-
-    if(result == QDialog::Rejected)
-    {
-        return_string = "";
-    }
-    else
-    {
-        return_string = ui->lineEdit->text().toStdString();
-    }
-
-    return(return_string);
-}
diff --git a/qt/OpenRGBProfileSaveDialog/OpenRGBProfileSaveDialog.h b/qt/OpenRGBProfileSaveDialog/OpenRGBProfileSaveDialog.h
deleted file mode 100644
index e0a38c10..00000000
--- a/qt/OpenRGBProfileSaveDialog/OpenRGBProfileSaveDialog.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBProfileSaveDialog.h                                |
-|                                                           |
-|   User interface entry for OpenRGB profile save dialog    |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QDialog>
-#include "ui_OpenRGBProfileSaveDialog.h"
-#include "OpenRGBDialog2.h"
-
-namespace Ui
-{
-    class OpenRGBProfileSaveDialog;
-}
-
-class Ui::OpenRGBProfileSaveDialog : public QDialog
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBProfileSaveDialog(QWidget *parent = nullptr);
-    ~OpenRGBProfileSaveDialog();
-
-    std::string show();
-
-private:
-    Ui::OpenRGBProfileSaveDialogUi *ui;
-
-private slots:
-    void changeEvent(QEvent *event);
-};
diff --git a/qt/OpenRGBProfileSaveDialog/OpenRGBProfileSaveDialog.ui b/qt/OpenRGBProfileSaveDialog/OpenRGBProfileSaveDialog.ui
deleted file mode 100644
index 70c9871d..00000000
--- a/qt/OpenRGBProfileSaveDialog/OpenRGBProfileSaveDialog.ui
+++ /dev/null
@@ -1,90 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBProfileSaveDialogUi</class>
- <widget class="QDialog" name="OpenRGBProfileSaveDialogUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>184</width>
-    <height>186</height>
-   </rect>
-  </property>
-  <property name="sizePolicy">
-   <sizepolicy hsizetype="Maximum" vsizetype="Maximum">
-    <horstretch>0</horstretch>
-    <verstretch>0</verstretch>
-   </sizepolicy>
-  </property>
-  <property name="windowTitle">
-   <string>Profile Name</string>
-  </property>
-  <layout class="QVBoxLayout" name="verticalLayout">
-   <item>
-    <widget class="QLabel" name="existing">
-     <property name="text">
-      <string>Save to an existing profile:</string>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="QListWidget" name="list_profile"/>
-   </item>
-   <item>
-    <widget class="QLabel" name="new_2">
-     <property name="text">
-      <string>Create a new profile:</string>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="QLineEdit" name="lineEdit"/>
-   </item>
-   <item>
-    <widget class="QDialogButtonBox" name="buttonBox">
-     <property name="orientation">
-      <enum>Qt::Horizontal</enum>
-     </property>
-     <property name="standardButtons">
-      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
-     </property>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections>
-  <connection>
-   <sender>buttonBox</sender>
-   <signal>accepted()</signal>
-   <receiver>OpenRGBProfileSaveDialogUi</receiver>
-   <slot>accept()</slot>
-   <hints>
-    <hint type="sourcelabel">
-     <x>248</x>
-     <y>254</y>
-    </hint>
-    <hint type="destinationlabel">
-     <x>157</x>
-     <y>274</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>buttonBox</sender>
-   <signal>rejected()</signal>
-   <receiver>OpenRGBProfileSaveDialogUi</receiver>
-   <slot>reject()</slot>
-   <hints>
-    <hint type="sourcelabel">
-     <x>316</x>
-     <y>260</y>
-    </hint>
-    <hint type="destinationlabel">
-     <x>286</x>
-     <y>274</y>
-    </hint>
-   </hints>
-  </connection>
- </connections>
-</ui>
diff --git a/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsEntry.cpp b/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsEntry.cpp
deleted file mode 100644
index 4154adf2..00000000
--- a/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsEntry.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBSerialSettingsEntry.cpp                            |
-|                                                           |
-|   User interface entry for serial device configuration    |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBSerialSettingsEntry.h"
-#include "ui_OpenRGBSerialSettingsEntry.h"
-
-using namespace Ui;
-
-OpenRGBSerialSettingsEntry::OpenRGBSerialSettingsEntry(QWidget *parent) :
-    QWidget(parent),
-    ui(new Ui::OpenRGBSerialSettingsEntryUi)
-{
-    ui->setupUi(this);
-
-    ui->ProtocolComboBox->addItem("Keyboard Visualizer");
-    ui->ProtocolComboBox->addItem("Adalight");
-    ui->ProtocolComboBox->addItem("TPM2");
-    ui->ProtocolComboBox->addItem("Basic I2C");
-}
-
-OpenRGBSerialSettingsEntry::~OpenRGBSerialSettingsEntry()
-{
-    delete ui;
-}
-
-void OpenRGBSerialSettingsEntry::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void Ui::OpenRGBSerialSettingsEntry::on_ProtocolComboBox_currentIndexChanged(int index)
-{
-    if(index == 3)
-    {
-        ui->BaudLabel->setText("Address:");
-    }
-    else
-    {
-        ui->BaudLabel->setText("Baud:");
-    }
-}
diff --git a/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsEntry.h b/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsEntry.h
deleted file mode 100644
index 3e6be8d8..00000000
--- a/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsEntry.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBSerialSettingsEntry.h                              |
-|                                                           |
-|   User interface entry for serial device configuration    |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QWidget>
-#include "ui_OpenRGBSerialSettingsEntry.h"
-
-namespace Ui
-{
-    class OpenRGBSerialSettingsEntry;
-}
-
-class Ui::OpenRGBSerialSettingsEntry : public QWidget
-{
-    Q_OBJECT
-
-private slots:
-    void changeEvent(QEvent *event);
-
-    void on_ProtocolComboBox_currentIndexChanged(int index);
-
-public:
-    explicit OpenRGBSerialSettingsEntry(QWidget *parent = nullptr);
-    ~OpenRGBSerialSettingsEntry();
-    Ui::OpenRGBSerialSettingsEntryUi *ui;
-};
diff --git a/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsEntry.ui b/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsEntry.ui
deleted file mode 100644
index f487fd58..00000000
--- a/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsEntry.ui
+++ /dev/null
@@ -1,93 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBSerialSettingsEntryUi</class>
- <widget class="QWidget" name="OpenRGBSerialSettingsEntryUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>531</width>
-    <height>237</height>
-   </rect>
-  </property>
-  <property name="sizePolicy">
-   <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
-    <horstretch>0</horstretch>
-    <verstretch>0</verstretch>
-   </sizepolicy>
-  </property>
-  <property name="windowTitle">
-   <string>Serial settings entry</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="1" column="0" colspan="2">
-    <widget class="QGroupBox" name="groupBox">
-     <property name="title">
-      <string/>
-     </property>
-     <layout class="QGridLayout" name="gridLayout_2">
-      <item row="1" column="5">
-       <widget class="QLineEdit" name="PortEdit"/>
-      </item>
-      <item row="1" column="3">
-       <widget class="QLineEdit" name="NameEdit"/>
-      </item>
-      <item row="2" column="0">
-       <widget class="QLabel" name="BaudLabel">
-        <property name="text">
-         <string>Baud:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="0">
-       <widget class="QLabel" name="NameLabel">
-        <property name="text">
-         <string>Name:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="2" column="4">
-       <widget class="QLabel" name="NumLEDsLabel">
-        <property name="text">
-         <string>Number of LEDs:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="4">
-       <widget class="QLabel" name="PortLabel">
-        <property name="text">
-         <string>Port:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="2" column="3">
-       <widget class="QLineEdit" name="BaudEdit"/>
-      </item>
-      <item row="2" column="5">
-       <widget class="QLineEdit" name="NumLEDsEdit"/>
-      </item>
-      <item row="3" column="0">
-       <widget class="QLabel" name="ProtocolLabel">
-        <property name="text">
-         <string>Protocol:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="3" column="3">
-       <widget class="QComboBox" name="ProtocolComboBox"/>
-      </item>
-     </layout>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <tabstops>
-  <tabstop>NameEdit</tabstop>
-  <tabstop>PortEdit</tabstop>
-  <tabstop>BaudEdit</tabstop>
-  <tabstop>NumLEDsEdit</tabstop>
-  <tabstop>ProtocolComboBox</tabstop>
- </tabstops>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsPage.cpp b/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsPage.cpp
deleted file mode 100644
index e07126b5..00000000
--- a/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsPage.cpp
+++ /dev/null
@@ -1,179 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBSerialSettingsPage.cpp                             |
-|                                                           |
-|   User interface for serial device configuration page     |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBSerialSettingsPage.h"
-#include "ui_OpenRGBSerialSettingsPage.h"
-#include "ResourceManager.h"
-#include "SettingsManager.h"
-
-using namespace Ui;
-
-OpenRGBSerialSettingsPage::OpenRGBSerialSettingsPage(QWidget *parent) :
-    QWidget(parent),
-    ui(new Ui::OpenRGBSerialSettingsPageUi)
-{
-    ui->setupUi(this);
-
-    json                ledstrip_settings;
-
-    /*-------------------------------------------------*\
-    | Get LED Strip settings from settings manager      |
-    \*-------------------------------------------------*/
-    ledstrip_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("LEDStripDevices");
-
-    /*-------------------------------------------------*\
-    | If the LEDStrip settings contains devices, process|
-    \*-------------------------------------------------*/
-    if(ledstrip_settings.contains("devices"))
-    {
-        for(unsigned int device_idx = 0; device_idx < ledstrip_settings["devices"].size(); device_idx++)
-        {
-            OpenRGBSerialSettingsEntry* entry = new OpenRGBSerialSettingsEntry;
-
-            if(ledstrip_settings["devices"][device_idx].contains("name"))
-            {
-                entry->ui->NameEdit->setText(QString::fromStdString(ledstrip_settings["devices"][device_idx]["name"]));
-            }
-
-            if(ledstrip_settings["devices"][device_idx].contains("port"))
-            {
-                entry->ui->PortEdit->setText(QString::fromStdString(ledstrip_settings["devices"][device_idx]["port"]));
-            }
-
-            if(ledstrip_settings["devices"][device_idx].contains("baud"))
-            {
-                entry->ui->BaudEdit->setText(QString::number((int)ledstrip_settings["devices"][device_idx]["baud"]));
-            }
-
-            if(ledstrip_settings["devices"][device_idx].contains("num_leds"))
-            {
-                entry->ui->NumLEDsEdit->setText(QString::number((int)ledstrip_settings["devices"][device_idx]["num_leds"]));
-            }
-
-            if(ledstrip_settings["devices"][device_idx].contains("protocol"))
-            {
-                std::string protocol_string = ledstrip_settings["devices"][device_idx]["protocol"];
-
-                if(protocol_string == "keyboard_visualizer")
-                {
-                    entry->ui->ProtocolComboBox->setCurrentIndex(0);
-                }
-                else if(protocol_string == "adalight")
-                {
-                    entry->ui->ProtocolComboBox->setCurrentIndex(1);
-                }
-                else if(protocol_string == "tpm2")
-                {
-                    entry->ui->ProtocolComboBox->setCurrentIndex(2);
-                }
-                else if(protocol_string == "basic_i2c")
-                {
-                    entry->ui->ProtocolComboBox->setCurrentIndex(3);
-                }
-            }
-
-            entries.push_back(entry);
-
-            QListWidgetItem* item = new QListWidgetItem;
-
-            item->setSizeHint(entry->sizeHint());
-
-            ui->SerialDeviceList->addItem(item);
-            ui->SerialDeviceList->setItemWidget(item, entry);
-            ui->SerialDeviceList->show();
-        }
-    }
-}
-
-OpenRGBSerialSettingsPage::~OpenRGBSerialSettingsPage()
-{
-    delete ui;
-}
-
-void OpenRGBSerialSettingsPage::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void Ui::OpenRGBSerialSettingsPage::on_AddSerialDeviceButton_clicked()
-{
-    OpenRGBSerialSettingsEntry* entry = new OpenRGBSerialSettingsEntry;
-    entries.push_back(entry);
-
-    QListWidgetItem* item = new QListWidgetItem;
-
-    item->setSizeHint(entry->sizeHint());
-
-    ui->SerialDeviceList->addItem(item);
-    ui->SerialDeviceList->setItemWidget(item, entry);
-    ui->SerialDeviceList->show();
-}
-
-void Ui::OpenRGBSerialSettingsPage::on_RemoveSerialDeviceButton_clicked()
-{
-    int cur_row = ui->SerialDeviceList->currentRow();
-
-    if(cur_row < 0)
-    {
-        return;
-    }
-
-    QListWidgetItem* item = ui->SerialDeviceList->takeItem(cur_row);
-
-    ui->SerialDeviceList->removeItemWidget(item);
-    delete item;
-
-    delete entries[cur_row];
-    entries.erase(entries.begin() + cur_row);
-}
-
-void Ui::OpenRGBSerialSettingsPage::on_SaveSerialConfigurationButton_clicked()
-{
-    json                ledstrip_settings;
-
-    /*-------------------------------------------------*\
-    | Get E1.31 settings from settings manager          |
-    \*-------------------------------------------------*/
-    ledstrip_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("LEDStripDevices");
-
-    ledstrip_settings["devices"].clear();
-
-    for(unsigned int device_idx = 0; device_idx < entries.size(); device_idx++)
-    {
-        /*-------------------------------------------------*\
-        | Required parameters                               |
-        \*-------------------------------------------------*/
-        ledstrip_settings["devices"][device_idx]["name"]            = entries[device_idx]->ui->NameEdit->text().toStdString();
-        ledstrip_settings["devices"][device_idx]["port"]            = entries[device_idx]->ui->PortEdit->text().toStdString();
-        ledstrip_settings["devices"][device_idx]["num_leds"]        = entries[device_idx]->ui->NumLEDsEdit->text().toUInt();
-        ledstrip_settings["devices"][device_idx]["baud"]            = entries[device_idx]->ui->BaudEdit->text().toUInt();
-
-        switch(entries[device_idx]->ui->ProtocolComboBox->currentIndex())
-        {
-            case 0:
-                ledstrip_settings["devices"][device_idx]["protocol"] = "keyboard_visualizer";
-                break;
-            case 1:
-                ledstrip_settings["devices"][device_idx]["protocol"] = "adalight";
-                break;
-            case 2:
-                ledstrip_settings["devices"][device_idx]["protocol"] = "tpm2";
-                break;
-            case 3:
-                ledstrip_settings["devices"][device_idx]["protocol"] = "basic_i2c";
-                break;
-        }
-    }
-
-    ResourceManager::get()->GetSettingsManager()->SetSettings("LEDStripDevices", ledstrip_settings);
-    ResourceManager::get()->GetSettingsManager()->SaveSettings();
-}
diff --git a/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsPage.h b/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsPage.h
deleted file mode 100644
index 8817acd3..00000000
--- a/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsPage.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBSerialSettingsPage.h                               |
-|                                                           |
-|   User interface for serial device configuration page     |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QWidget>
-
-#include "ui_OpenRGBSerialSettingsPage.h"
-#include "OpenRGBSerialSettingsEntry.h"
-
-namespace Ui
-{
-    class OpenRGBSerialSettingsPage;
-}
-
-class Ui::OpenRGBSerialSettingsPage : public QWidget
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBSerialSettingsPage(QWidget *parent = nullptr);
-    ~OpenRGBSerialSettingsPage();
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_AddSerialDeviceButton_clicked();
-
-    void on_RemoveSerialDeviceButton_clicked();
-
-    void on_SaveSerialConfigurationButton_clicked();
-
-private:
-    Ui::OpenRGBSerialSettingsPageUi *ui;
-    std::vector<OpenRGBSerialSettingsEntry*> entries;
-
-};
diff --git a/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsPage.ui b/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsPage.ui
deleted file mode 100644
index a73c48f6..00000000
--- a/qt/OpenRGBSerialSettingsPage/OpenRGBSerialSettingsPage.ui
+++ /dev/null
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBSerialSettingsPageUi</class>
- <widget class="QWidget" name="OpenRGBSerialSettingsPageUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>400</width>
-    <height>300</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Serial settings page</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="1" column="0">
-    <widget class="QPushButton" name="AddSerialDeviceButton">
-     <property name="text">
-      <string>Add</string>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="1">
-    <widget class="QPushButton" name="RemoveSerialDeviceButton">
-     <property name="text">
-      <string>Remove</string>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="2">
-    <widget class="QPushButton" name="SaveSerialConfigurationButton">
-     <property name="text">
-      <string>Save</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="0" colspan="3">
-    <widget class="QListWidget" name="SerialDeviceList">
-     <property name="verticalScrollMode">
-      <enum>QAbstractItemView::ScrollPerPixel</enum>
-     </property>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBServerInfoPage/OpenRGBServerInfoPage.cpp b/qt/OpenRGBServerInfoPage/OpenRGBServerInfoPage.cpp
deleted file mode 100644
index 508dc2d9..00000000
--- a/qt/OpenRGBServerInfoPage/OpenRGBServerInfoPage.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBServerInfoPage.cpp                                 |
-|                                                           |
-|   User interface for server information page              |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBServerInfoPage.h"
-
-using namespace Ui;
-
-static void UpdateInfoCallback(void * this_ptr)
-{
-    OpenRGBServerInfoPage * this_obj = (OpenRGBServerInfoPage *)this_ptr;
-
-    QMetaObject::invokeMethod(this_obj, "UpdateInfo", Qt::QueuedConnection);
-}
-
-OpenRGBServerInfoPage::OpenRGBServerInfoPage(NetworkServer * server, QWidget *parent) :
-    QFrame(parent),
-    ui(new Ui::OpenRGBServerInfoPageUi)
-{
-    network_server = server;
-
-    ui->setupUi(this);
-
-    UpdateInfo();
-
-    network_server->RegisterClientInfoChangeCallback(UpdateInfoCallback, this);
-    network_server->RegisterServerListeningChangeCallback(UpdateInfoCallback, this);
-}
-
-OpenRGBServerInfoPage::~OpenRGBServerInfoPage()
-{
-    delete ui;
-}
-
-void OpenRGBServerInfoPage::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void OpenRGBServerInfoPage::UpdateInfo()
-{
-    ui->ServerHostValue->setText(network_server->GetHost().c_str());
-    ui->ServerPortValue->setText(std::to_string(network_server->GetPort()).c_str());
-
-    if(network_server->GetListening() && !network_server->GetOnline())
-    {
-        ui->ServerStatusValue->setText(tr("Stopping..."));
-        ui->ServerStartButton->setEnabled(false);
-        ui->ServerStopButton->setEnabled(false);
-        ui->ServerHostValue->setEnabled(false);
-        ui->ServerPortValue->setEnabled(false);
-    }
-    else if(network_server->GetListening())
-    {
-        ui->ServerStatusValue->setText(tr("Online"));
-        ui->ServerStartButton->setEnabled(false);
-        ui->ServerStopButton->setEnabled(true);
-        ui->ServerHostValue->setEnabled(false);
-        ui->ServerPortValue->setEnabled(false);
-    }
-    else
-    {
-        ui->ServerStatusValue->setText(tr("Offline"));
-        ui->ServerStartButton->setEnabled(true);
-        ui->ServerStopButton->setEnabled(false);
-        ui->ServerHostValue->setEnabled(true);
-        ui->ServerPortValue->setEnabled(true);
-    }
-
-    ui->ServerClientTree->clear();
-    for(unsigned int client_idx = 0; client_idx < network_server->GetNumClients(); client_idx++)
-    {
-        QTreeWidgetItem * new_item = new QTreeWidgetItem();
-
-        new_item->setText(0, network_server->GetClientIP(client_idx));
-        new_item->setText(1, QString::number(network_server->GetClientProtocolVersion(client_idx)));
-        new_item->setText(2, network_server->GetClientString(client_idx));
-
-        ui->ServerClientTree->addTopLevelItem(new_item);
-    }
-}
-
-void Ui::OpenRGBServerInfoPage::on_ServerStartButton_clicked()
-{
-    if(network_server->GetOnline() == false)
-    {
-        network_server->SetHost(ui->ServerHostValue->text().toStdString());
-        network_server->SetPort(ui->ServerPortValue->text().toInt());
-        network_server->StartServer();
-
-        UpdateInfo();
-    }
-}
-
-void Ui::OpenRGBServerInfoPage::on_ServerStopButton_clicked()
-{
-    if(network_server->GetOnline() == true)
-    {
-        network_server->StopServer();
-
-        UpdateInfo();
-    }
-}
diff --git a/qt/OpenRGBServerInfoPage/OpenRGBServerInfoPage.h b/qt/OpenRGBServerInfoPage/OpenRGBServerInfoPage.h
deleted file mode 100644
index a78aaded..00000000
--- a/qt/OpenRGBServerInfoPage/OpenRGBServerInfoPage.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBServerInfoPage.h                                   |
-|                                                           |
-|   User interface for server information page              |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QFrame>
-#include "RGBController.h"
-#include "ui_OpenRGBServerInfoPage.h"
-#include "NetworkServer.h"
-
-namespace Ui
-{
-    class OpenRGBServerInfoPage;
-}
-
-class Ui::OpenRGBServerInfoPage : public QFrame
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBServerInfoPage(NetworkServer * server, QWidget *parent = nullptr);
-    ~OpenRGBServerInfoPage();
-
-public slots:
-    void UpdateInfo();
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_ServerStartButton_clicked();
-    void on_ServerStopButton_clicked();
-
-private:
-    Ui::OpenRGBServerInfoPageUi *ui;
-
-    NetworkServer* network_server;
-};
diff --git a/qt/OpenRGBServerInfoPage/OpenRGBServerInfoPage.ui b/qt/OpenRGBServerInfoPage/OpenRGBServerInfoPage.ui
deleted file mode 100644
index 3df2a6e0..00000000
--- a/qt/OpenRGBServerInfoPage/OpenRGBServerInfoPage.ui
+++ /dev/null
@@ -1,131 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBServerInfoPageUi</class>
- <widget class="QFrame" name="OpenRGBServerInfoPageUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>664</width>
-    <height>300</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Server info page</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="2" column="3">
-    <widget class="QPushButton" name="ServerStopButton">
-     <property name="text">
-      <string>Stop Server</string>
-     </property>
-    </widget>
-   </item>
-   <item row="2" column="0">
-    <widget class="QLabel" name="ServerPortLabel">
-     <property name="text">
-      <string>Server Port:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="4" column="0">
-    <widget class="QLabel" name="ServerClientsLabel">
-     <property name="text">
-      <string>Connected Clients:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="5" column="0" colspan="4">
-    <widget class="QTreeWidget" name="ServerClientTree">
-     <property name="columnCount">
-      <number>3</number>
-     </property>
-     <column>
-      <property name="text">
-       <string>Client IP</string>
-      </property>
-     </column>
-     <column>
-      <property name="text">
-       <string>Protocol Version</string>
-      </property>
-     </column>
-     <column>
-      <property name="text">
-       <string>Client Name</string>
-      </property>
-     </column>
-    </widget>
-   </item>
-   <item row="2" column="1">
-    <widget class="QLineEdit" name="ServerPortValue">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
-       <horstretch>0</horstretch>
-       <verstretch>0</verstretch>
-      </sizepolicy>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="0">
-    <widget class="QLabel" name="ServerStatusLabel">
-     <property name="text">
-      <string>Server Status:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="3">
-    <widget class="QPushButton" name="ServerStartButton">
-     <property name="text">
-      <string>Start Server</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="1">
-    <widget class="QLabel" name="ServerStatusValue">
-     <property name="text">
-      <string>Offline</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="2">
-    <spacer name="horizontalSpacer">
-     <property name="orientation">
-      <enum>Qt::Horizontal</enum>
-     </property>
-     <property name="sizeHint" stdset="0">
-      <size>
-       <width>40</width>
-       <height>20</height>
-      </size>
-     </property>
-    </spacer>
-   </item>
-   <item row="1" column="0">
-    <widget class="QLabel" name="ServerHostLabel">
-     <property name="text">
-      <string>Server Host:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="1">
-    <widget class="QLineEdit" name="ServerHostValue">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
-       <horstretch>0</horstretch>
-       <verstretch>0</verstretch>
-      </sizepolicy>
-     </property>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <tabstops>
-  <tabstop>ServerPortValue</tabstop>
-  <tabstop>ServerStartButton</tabstop>
-  <tabstop>ServerStopButton</tabstop>
-  <tabstop>ServerClientTree</tabstop>
- </tabstops>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBSettingsPage/OpenRGBSettingsPage.cpp b/qt/OpenRGBSettingsPage/OpenRGBSettingsPage.cpp
deleted file mode 100644
index 86af79f6..00000000
--- a/qt/OpenRGBSettingsPage/OpenRGBSettingsPage.cpp
+++ /dev/null
@@ -1,979 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBSettingsPage.cpp                                   |
-|                                                           |
-|   User interface for general settings page                |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QUrl>
-#include <QDesktopServices>
-#include "AutoStart.h"
-#include "OpenRGBSettingsPage.h"
-#include "ui_OpenRGBSettingsPage.h"
-#include "LogManager.h"
-#include "ResourceManager.h"
-#include "SettingsManager.h"
-#include "ProfileManager.h"
-
-using namespace Ui;
-
-OpenRGBSettingsPage::OpenRGBSettingsPage(QWidget *parent) :
-    QWidget(parent),
-    ui(new Ui::OpenRGBSettingsPageUi)
-{
-    ui->setupUi(this);
-
-    /*---------------------------------------------------------*\
-    | App translation                                           |
-    | To add a new language:                                    |
-    |   Add an entry to TRANSLATIONS in OpenRGB.pro             |
-    |   Then run lupdate OpenRGB.pro to generate the new file   |
-    |                                                           |
-    | Edit this file with                                       |
-    |   linguist qt/i18n/OpenRGB_en.ts qt/i18n/OpenRGB_XX.ts    |
-    | or manually with any text editor                          |
-    \*---------------------------------------------------------*/
-
-    /*---------------------------------------------------------*\
-    | Load available languages                                  |
-    |  Tehcnically the QString is unused but declared           |
-    |  here to show up in the translation file.                 |
-    \*---------------------------------------------------------*/
-    QTranslator translator;
-    QMap<QString, QString> map;
-    QString language = tr("English - US");
-
-    QDirIterator file(":/i18n/", QDirIterator::Subdirectories);
-    while(file.hasNext())
-    {
-        translator.load(file.next());
-        map.insert(translator.translate("Ui::OpenRGBSettingsPage", "English - US"), file.filePath());
-    }
-
-    ui->ComboBoxLanguage->blockSignals(true);
-    ui->ComboBoxLanguage->addItem(tr("System Default"), "default");
-    QMapIterator<QString, QString> i(map);
-    while(i.hasNext())
-    {
-        i.next();
-        ui->ComboBoxLanguage->addItem(i.key(), i.value());
-    }
-    ui->ComboBoxLanguage->blockSignals(false);
-
-    /*---------------------------------------------------------*\
-    | Populate hex format combo box                             |
-    \*---------------------------------------------------------*/
-    ui->ComboBoxHexFormat->addItem("RGB");
-    ui->ComboBoxHexFormat->addItem("BGR");
-
-    hex_format_initialized = true;
-
-    /*---------------------------------------------------------*\
-    | Load theme settings                                       |
-    \*---------------------------------------------------------*/
-    ui->ComboBoxTheme->addItems({"auto", "light", "dark"});
-
-    json theme_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Theme");
-
-    if(theme_settings.contains("theme"))
-    {
-        std::string theme = theme_settings["theme"];
-        ui->ComboBoxTheme->setCurrentText(QString::fromStdString(theme));
-    }
-    else
-    {
-        ui->ComboBoxTheme->setCurrentText(QString::fromStdString(("light")));
-    }
-
-    theme_initialized = true;
-
-    /*---------------------------------------------------------*\
-    | Load user interface settings                              |
-    \*---------------------------------------------------------*/
-    json ui_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-
-    if(ui_settings.contains("language"))
-    {
-        /*-----------------------------------------------------*\
-        | Get the language preference from settings             |
-        |   and check the language combobox for a match         |
-        \*-----------------------------------------------------*/
-        std::string language        = ui_settings["language"].get<std::string>();
-        int language_index          = ui->ComboBoxLanguage->findText(QString::fromStdString(language));
-
-        if(language_index > -1)
-        {
-            ui->ComboBoxLanguage->setCurrentIndex(language_index);
-        }
-    }
-    else
-    {
-        ui_settings["language"] = "default";
-        ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface",ui_settings);
-        SaveSettings();
-        ui->ComboBoxLanguage->setCurrentIndex(0);
-    }
-
-    if(ui_settings.contains("greyscale_tray_icon"))
-    {
-        ui->CheckboxTrayIconGreyscale->setChecked(ui_settings["greyscale_tray_icon"]);
-    }
-
-    if(ui_settings.contains("minimize_on_close"))
-    {
-        ui->CheckboxMinimizeOnClose->setChecked(ui_settings["minimize_on_close"]);
-    }
-
-    if(ui_settings.contains("geometry"))
-    {
-        if(ui_settings["geometry"].contains("load_geometry"))
-        {
-            ui->CheckboxLoadGeometry->setChecked(ui_settings["geometry"]["load_geometry"]);
-        }
-
-        if(ui_settings["geometry"].contains("save_on_exit"))
-        {
-            ui->CheckboxSaveGeometry->setChecked(ui_settings["geometry"]["save_on_exit"]);
-        }
-    }
-
-    if(ui_settings.contains("RunZoneChecks"))
-    {
-        ui->CheckboxRunZoneChecks->setChecked(ui_settings["RunZoneChecks"]);
-    }
-    else
-    {   // default value
-        ui->CheckboxRunZoneChecks->setChecked(true);
-    }
-
-    if(ui_settings.contains("disable_key_expansion"))
-    {
-        ui->CheckboxDisableKeyExpansion->setChecked(ui_settings["disable_key_expansion"]);
-    }
-    else
-    {
-        ui->CheckboxDisableKeyExpansion->setChecked(false);
-    }
-
-    if(ui_settings.contains("show_led_view"))
-    {
-        ui->CheckboxShowLEDView->setChecked(ui_settings["show_led_view"]);
-    }
-    else
-    {
-        ui->CheckboxShowLEDView->setChecked(false);
-    }
-
-    if(ui_settings.contains("hex_format"))
-    {
-        if(ui_settings["hex_format"] == "RGB")
-        {
-            ui->ComboBoxHexFormat->setCurrentIndex(0);
-        }
-        else if(ui_settings["hex_format"] == "BGR")
-        {
-            ui->ComboBoxHexFormat->setCurrentIndex(1);
-        }
-    }
-
-    /*---------------------------------------------------------*\
-    | Load LogManager settings                                  |
-    \*---------------------------------------------------------*/
-    json log_manager_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("LogManager");
-
-    /*---------------------------------------------------------*\
-    | Checkboxes                                                |
-    \*---------------------------------------------------------*/
-    if(log_manager_settings.contains("log_console"))
-    {
-        ui->CheckboxLogConsole->setChecked(log_manager_settings["log_console"]);
-    }
-
-    /*---------------------------------------------------------*\
-    | Load drivers settings (Windows only)                      |
-    \*---------------------------------------------------------*/
-#ifdef _WIN32
-    json drivers_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Drivers");
-
-    if(drivers_settings.contains("amd_smbus_reduce_cpu"))
-    {
-        ui->CheckboxAMDSMBusReduceCPU->setChecked(drivers_settings["amd_smbus_reduce_cpu"]);
-    }
-
-    if(drivers_settings.contains("shared_smbus_access"))
-    {
-        ui->CheckboxSharedSMBusAccess->setChecked(drivers_settings["shared_smbus_access"]);
-    }
-    else
-    {
-        ui->CheckboxSharedSMBusAccess->setChecked(true);
-    }
-#else
-    ui->DriversSettingsLabel->hide();
-    ui->CheckboxAMDSMBusReduceCPU->hide();
-    ui->CheckboxSharedSMBusAccess->hide();
-#endif
-
-    UpdateProfiles();
-
-    /*---------------------------------------------------------*\
-    | Make sure autostart settings exist                        |
-    \*---------------------------------------------------------*/
-    CreateAutoStartSettings();
-
-    /*---------------------------------------------------------*\
-    | Initialise UI to current settings or defaults             |
-    \*---------------------------------------------------------*/
-    json autostart_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("AutoStart");
-
-    RemediateAutoStartProfile(autostart_settings);
-
-    /*---------------------------------------------------------*\
-    | Text boxes                                                |
-    \*---------------------------------------------------------*/
-    ui->TextServerHost->setText(QString::fromStdString(autostart_settings["host"]));
-    ui->TextServerHost->setEnabled(autostart_settings["setserverhost"]);
-
-    ui->TextServerPort->setText(QString::fromStdString(autostart_settings["port"]));
-    ui->TextServerPort->setEnabled(autostart_settings["setserverport"]);
-
-    ui->TextClientHost->setText(QString::fromStdString(autostart_settings["client"]));
-    ui->TextClientHost->setEnabled(autostart_settings["setclient"]);
-
-    ui->TextCustomArgs->setText(QString::fromStdString(autostart_settings["custom"]));
-    ui->TextCustomArgs->setEnabled(autostart_settings["setcustom"]);
-
-    /*---------------------------------------------------------*\
-    | Checkboxes                                                |
-    \*---------------------------------------------------------*/
-    ui->CheckboxAutoStart->setChecked(autostart_settings["enabled"]);
-    SetAutoStartVisibility(autostart_settings["enabled"]);
-
-    ui->CheckboxAutoStartMinimized->setChecked(autostart_settings["setminimized"]);
-    ui->CheckboxAutoStartClient->setChecked(autostart_settings["setclient"]);
-    ui->CheckboxAutoStartServer->setChecked(autostart_settings["setserver"]);
-    ui->CheckboxAutoStartSetServerHost->setChecked(autostart_settings["setserverhost"]);
-    ui->CheckboxAutoStartSetServerPort->setChecked(autostart_settings["setserverport"]);
-    ui->CheckboxAutoStartCustom->setChecked(autostart_settings["setcustom"]);
-
-    ui->AutoStartStatusLabel->hide();
-    autostart_initialized = true;
-}
-
-OpenRGBSettingsPage::~OpenRGBSettingsPage()
-{
-    delete ui;
-}
-
-void OpenRGBSettingsPage::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void OpenRGBSettingsPage::UpdateProfiles()
-{
-    /*---------------------------------------------------------*\
-    | Load AutoStart settings                                   |
-    \*---------------------------------------------------------*/
-    ProfileManager* profile_manager = ResourceManager::get()->GetProfileManager();
-
-    /*---------------------------------------------------------*\
-    | Load profiles into combo box                              |
-    \*---------------------------------------------------------*/
-    if(profile_manager != NULL)
-    {
-        ui->ComboBoxAutoStartProfile->blockSignals(true);
-        ui->ComboBoxSuspendProfile->blockSignals(true);
-        ui->ComboBoxResumeProfile->blockSignals(true);
-        ui->ComboBoxExitProfile->blockSignals(true);
-
-        ui->ComboBoxAutoStartProfile->clear();
-        ui->ComboBoxSuspendProfile->clear();
-        ui->ComboBoxResumeProfile->clear();
-        ui->ComboBoxExitProfile->clear();
-
-        for(std::size_t profile_index = 0; profile_index < profile_manager->profile_list.size(); profile_index++)
-        {
-            QString new_profile = QString(profile_manager->profile_list[profile_index].c_str());
-
-            ui->ComboBoxAutoStartProfile->addItem(new_profile);
-            ui->ComboBoxSuspendProfile->addItem(new_profile);
-            ui->ComboBoxResumeProfile->addItem(new_profile);
-            ui->ComboBoxExitProfile->addItem(new_profile);
-        }
-
-        ui->ComboBoxAutoStartProfile->blockSignals(false);
-        ui->ComboBoxSuspendProfile->blockSignals(false);
-        ui->ComboBoxResumeProfile->blockSignals(false);
-        ui->ComboBoxExitProfile->blockSignals(false);
-    }
-
-    /*---------------------------------------------------------*\
-    | Load user interface settings                              |
-    \*---------------------------------------------------------*/
-    json autostart_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("AutoStart");
-
-    if(autostart_settings.contains("profile"))
-    {
-        /*-----------------------------------------------------*\
-        | Set the profile name from settings and check the      |
-        |   profile combobox for a match                        |
-        \*-----------------------------------------------------*/
-        std::string profile_name    = autostart_settings["profile"].get<std::string>();
-        int profile_index           = ui->ComboBoxAutoStartProfile->findText(QString::fromStdString(profile_name));
-
-        if(profile_index > -1)
-        {
-            ui->ComboBoxAutoStartProfile->setCurrentIndex(profile_index);
-        }
-    }
-
-    /*---------------------------------------------------------*\
-    | Load user interface settings                              |
-    \*---------------------------------------------------------*/
-    json ui_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-
-    if(ui_settings.contains("autoload_profiles"))
-    {
-        json autoload_profiles = ui_settings["autoload_profiles"];
-
-        if(autoload_profiles.contains("exit_profile"))
-        {
-            json profile = autoload_profiles["exit_profile"];
-
-            if(profile.contains("enabled"))
-            {
-                bool is_enabled = profile["enabled"].get<bool>();
-                ui->CheckboxSetOnExit->setChecked(is_enabled);
-                ui->ComboBoxExitProfile->setEnabled(is_enabled);
-            }
-
-            if(profile.contains("name"))
-            {
-                /*-----------------------------------------------------*\
-                | Set the profile name from settings and check the      |
-                |   profile combobox for a match                        |
-                \*-----------------------------------------------------*/
-                std::string profile_name = profile["name"].get<std::string>();
-                int profile_index        = ui->ComboBoxExitProfile->findText(QString::fromStdString(profile_name));
-
-                if(profile_index > -1)
-                {
-                    ui->ComboBoxExitProfile->setCurrentIndex(profile_index);
-                }
-            }
-        }
-
-        if(autoload_profiles.contains("resume_profile"))
-        {
-            json profile = autoload_profiles["resume_profile"];
-
-            if(profile.contains("enabled"))
-            {
-                bool is_enabled = profile["enabled"].get<bool>();
-                ui->CheckboxSetOnResume->setChecked(is_enabled);
-                ui->ComboBoxResumeProfile->setEnabled(is_enabled);
-            }
-
-            if(profile.contains("name"))
-            {
-                /*-----------------------------------------------------*\
-                | Set the profile name from settings and check the      |
-                |   profile combobox for a match                        |
-                \*-----------------------------------------------------*/
-                std::string profile_name = profile["name"].get<std::string>();
-                int profile_index        = ui->ComboBoxResumeProfile->findText(QString::fromStdString(profile_name));
-
-                if(profile_index > -1)
-                {
-                    ui->ComboBoxResumeProfile->setCurrentIndex(profile_index);
-                }
-            }
-        }
-
-        if(autoload_profiles.contains("suspend_profile"))
-        {
-            json profile = autoload_profiles["suspend_profile"];
-
-            if(profile.contains("enabled"))
-            {
-                bool is_enabled = profile["enabled"].get<bool>();
-                ui->CheckboxSetOnSuspend->setChecked(is_enabled);
-                ui->ComboBoxSuspendProfile->setEnabled(is_enabled);
-            }
-
-            if(profile.contains("name"))
-            {
-                /*-----------------------------------------------------*\
-                | Set the profile name from settings and check the      |
-                |   profile combobox for a match                        |
-                \*-----------------------------------------------------*/
-                std::string profile_name = profile["name"].get<std::string>();
-                int profile_index        = ui->ComboBoxSuspendProfile->findText(QString::fromStdString(profile_name));
-
-                if(profile_index > -1)
-                {
-                    ui->ComboBoxSuspendProfile->setCurrentIndex(profile_index);
-                }
-            }
-        }
-    }
-}
-
-void OpenRGBSettingsPage::on_ComboBoxLanguage_currentTextChanged(const QString language)
-{
-
-    bool loaded             = false;
-    QString file            = ui->ComboBoxLanguage->currentData().toString();
-    QApplication* app       = static_cast<QApplication *>(QApplication::instance());
-
-    app->removeTranslator(&translator);
-
-    if(file == "default")
-    {
-        QLocale locale = QLocale(QLocale::system());
-        QLocale::setDefault(locale);
-
-        loaded = translator.load(":/i18n/" + QString("OpenRGB_%1.qm").arg(locale.name()));
-    }
-    else
-    {
-        loaded = translator.load(file);
-    }
-
-    if(loaded)
-    {
-        app->installTranslator(&translator);
-        LOG_DEBUG("[Settings] Changed Language to %s from the %s file\n", language.toStdString().c_str(), file.toStdString().c_str());
-
-        json ui_settings    = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-        std::string saved   = ui_settings["language"].get<std::string>();
-
-        if(saved != language.toStdString())
-        {
-            ui_settings["language"] = language.toStdString();
-            ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface",ui_settings);
-            SaveSettings();
-        }
-    }
-}
-
-void OpenRGBSettingsPage::on_ComboBoxTheme_currentTextChanged(const QString theme)
-{
-    if(theme_initialized)
-    {
-        json theme_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Theme");
-        theme_settings["theme"] = theme.toStdString();
-        ResourceManager::get()->GetSettingsManager()->SetSettings("Theme", theme_settings);
-        SaveSettings();
-    }
-}
-
-void OpenRGBSettingsPage::on_ComboBoxHexFormat_currentTextChanged(const QString hex_format)
-{
-    if(hex_format_initialized)
-    {
-        json ui_settings    = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-        ui_settings["hex_format"] = hex_format.toStdString();
-        ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface",ui_settings);
-        SaveSettings();
-    }
-}
-
-void OpenRGBSettingsPage::on_CheckboxTrayIconGreyscale_clicked()
-{
-    json ui_settings    = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    bool tray_icon      = ui->CheckboxTrayIconGreyscale->isChecked();
-
-    ui_settings["greyscale_tray_icon"] = tray_icon;
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-
-    emit TrayIconChanged(tray_icon);
-}
-
-void OpenRGBSettingsPage::on_CheckboxMinimizeOnClose_clicked()
-{
-    json ui_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    ui_settings["minimize_on_close"] = ui->CheckboxMinimizeOnClose->isChecked();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxLoadGeometry_clicked()
-{
-    json ui_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    ui_settings["geometry"]["load_geometry"] = ui->CheckboxLoadGeometry->isChecked();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxSaveGeometry_clicked()
-{
-    json ui_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    ui_settings["geometry"]["save_on_exit"] = ui->CheckboxSaveGeometry->isChecked();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxRunZoneChecks_clicked()
-{
-    json ui_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    ui_settings["RunZoneChecks"] = ui->CheckboxRunZoneChecks->isChecked();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxSetOnExit_clicked(bool checked)
-{
-    json ui_settings                                             = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    ui_settings["autoload_profiles"]["exit_profile"]["enabled"]  = checked;
-    ui_settings["autoload_profiles"]["exit_profile"]["name"]     = ui->ComboBoxExitProfile->currentText().toStdString();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-
-    ui->ComboBoxExitProfile->setEnabled(checked);
-}
-
-void Ui::OpenRGBSettingsPage::on_ComboBoxExitProfile_currentTextChanged(const QString exit_profile_name)
-{
-    json ui_settings                                         = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    ui_settings["autoload_profiles"]["exit_profile"]["name"] = exit_profile_name.toStdString();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxSetOnResume_clicked(bool checked)
-{
-    json ui_settings                                              = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    ui_settings["autoload_profiles"]["resume_profile"]["enabled"] = checked;
-    ui_settings["autoload_profiles"]["resume_profile"]["name"]    = ui->ComboBoxResumeProfile->currentText().toStdString();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-
-    ui->ComboBoxResumeProfile->setEnabled(checked);
-}
-
-void Ui::OpenRGBSettingsPage::on_ComboBoxResumeProfile_currentTextChanged(const QString resume_profile_name)
-{
-    json ui_settings                                           = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    ui_settings["autoload_profiles"]["resume_profile"]["name"] = resume_profile_name.toStdString();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxSetOnSuspend_clicked(bool checked)
-{
-    json ui_settings                                               = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    ui_settings["autoload_profiles"]["suspend_profile"]["enabled"] = checked;
-    ui_settings["autoload_profiles"]["suspend_profile"]["name"]    = ui->ComboBoxSuspendProfile->currentText().toStdString();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-
-    ui->ComboBoxSuspendProfile->setEnabled(checked);
-}
-
-void Ui::OpenRGBSettingsPage::on_ComboBoxSuspendProfile_currentTextChanged(const QString suspend_profile_name)
-{
-    json ui_settings                                            = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    ui_settings["autoload_profiles"]["suspend_profile"]["name"] = suspend_profile_name.toStdString();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxAutoStart_clicked()
-{
-    if(autostart_initialized)
-    {
-        json autostart_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("AutoStart");
-        autostart_settings["enabled"] = ui->CheckboxAutoStart->isChecked();
-
-        if(autostart_settings["enabled"])
-        {
-            RemediateAutoStartProfile(autostart_settings);
-        }
-
-        ResourceManager::get()->GetSettingsManager()->SetSettings("AutoStart", autostart_settings);
-        SaveSettings();
-
-        SetAutoStartVisibility(autostart_settings["enabled"]);
-
-        ConfigureAutoStart();
-    }
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxAutoStartMinimized_clicked()
-{
-    SaveAutoStartSetting("setminimized", ui->CheckboxAutoStartMinimized->isChecked());
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxAutoStartServer_clicked()
-{
-    SaveAutoStartSetting("setserver", ui->CheckboxAutoStartServer->isChecked());
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxAutoStartSetServerHost_clicked()
-{
-    SaveAutoStartSetting("setserverhost", ui->CheckboxAutoStartSetServerHost->isChecked());
-    ui->TextServerHost->setEnabled(ui->CheckboxAutoStartSetServerHost->isChecked());
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxAutoStartSetServerPort_clicked()
-{
-    SaveAutoStartSetting("setserverport", ui->CheckboxAutoStartSetServerPort->isChecked());
-    ui->TextServerPort->setEnabled(ui->CheckboxAutoStartSetServerPort->isChecked());
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxAutoStartClient_clicked()
-{
-    SaveAutoStartSetting("setclient", ui->CheckboxAutoStartClient->isChecked());
-    ui->TextClientHost->setEnabled(ui->CheckboxAutoStartClient->isChecked());
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxAutoStartProfile_clicked()
-{
-    SaveAutoStartSetting("setprofile", ui->CheckboxAutoStartProfile->isChecked());
-    ui->ComboBoxAutoStartProfile->setEnabled(ui->CheckboxAutoStartProfile->isChecked());
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxAutoStartCustom_clicked()
-{
-    SaveAutoStartSetting("setcustom", ui->CheckboxAutoStartCustom->isChecked());
-    ui->TextCustomArgs->setEnabled(ui->CheckboxAutoStartCustom->isChecked());
-}
-
-void Ui::OpenRGBSettingsPage::on_TextServerHost_textChanged(QString host)
-{
-    SaveAutoStartSetting("host", host);
-}
-
-void Ui::OpenRGBSettingsPage::on_TextServerPort_textChanged(QString port)
-{
-    SaveAutoStartSetting("port", port);
-}
-
-void Ui::OpenRGBSettingsPage::on_TextClientHost_textChanged(QString client)
-{
-    SaveAutoStartSetting("client", client);
-}
-
-void Ui::OpenRGBSettingsPage::on_TextCustomArgs_textChanged(QString custom)
-{
-    SaveAutoStartSetting("custom", custom);
-}
-
-void Ui::OpenRGBSettingsPage::on_ComboBoxAutoStartProfile_currentTextChanged(const QString profile)
-{
-    SaveAutoStartSetting("profile", profile);
-}
-
-void OpenRGBSettingsPage::SaveAutoStartSetting(std::string name, QString value)
-{
-    if(autostart_initialized)
-    {
-        json autostart_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("AutoStart");
-        autostart_settings[name] = value.toStdString();
-        ResourceManager::get()->GetSettingsManager()->SetSettings("AutoStart", autostart_settings);
-        SaveSettings();
-
-        ConfigureAutoStart();
-    }
-}
-
-void OpenRGBSettingsPage::SaveAutoStartSetting(std::string name, bool value)
-{
-    if(autostart_initialized)
-    {
-        json autostart_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("AutoStart");
-        autostart_settings[name] = value;
-        ResourceManager::get()->GetSettingsManager()->SetSettings("AutoStart", autostart_settings);
-        SaveSettings();
-
-        ConfigureAutoStart();
-    }
-}
-
-void OpenRGBSettingsPage::SetAutoStartVisibility(bool visible)
-{
-    if (!visible)
-    {
-        ui->ComboBoxAutoStartProfile->hide();
-        ui->CheckboxAutoStartClient->hide();
-        ui->CheckboxAutoStartCustom->hide();
-        ui->CheckboxAutoStartMinimized->hide();
-        ui->CheckboxAutoStartProfile->hide();
-        ui->CheckboxAutoStartServer->hide();
-        ui->CheckboxAutoStartSetServerHost->hide();
-        ui->CheckboxAutoStartSetServerPort->hide();
-        ui->TextCustomArgs->hide();
-        ui->TextClientHost->hide();
-        ui->TextServerHost->hide();
-        ui->TextServerPort->hide();
-        ui->AutoStartStatusLabel->hide();
-    }
-    else
-    {
-        ui->ComboBoxAutoStartProfile->show();
-        ui->CheckboxAutoStartClient->show();
-        ui->CheckboxAutoStartCustom->show();
-        ui->CheckboxAutoStartMinimized->show();
-        ui->CheckboxAutoStartProfile->show();
-        ui->CheckboxAutoStartServer->show();
-        ui->CheckboxAutoStartSetServerHost->show();
-        ui->CheckboxAutoStartSetServerPort->show();
-        ui->TextCustomArgs->show();
-        ui->TextClientHost->show();
-        ui->TextServerHost->show();
-        ui->TextServerPort->show();
-        ui->AutoStartStatusLabel->show();
-    }
-}
-
-void OpenRGBSettingsPage::ConfigureAutoStart()
-{
-    std::map<std::string, std::tuple<std::string, std::string, bool>> autostart_map = {
-        {"setminimized", {"--startminimized","",false}},
-        {"setserver", {"--server","",false}},
-        {"setserverhost", {"--server-host","host",false}},
-        {"setserverport", {"--server-port","port",false}},
-        {"setclient", {"--client","client",false}},
-        {"setprofile", {"--profile","profile",true}},
-        {"setcustom", {"","custom",false}},
-    };
-
-    json autostart_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("AutoStart");
-
-    AutoStart auto_start("OpenRGB");
-
-    if (!autostart_settings["enabled"])
-    {
-        if (!auto_start.DisableAutoStart())
-        {
-            ui->AutoStartStatusLabel->setText("A problem occurred disabling Start At Login.");
-            ui->AutoStartStatusLabel->show();
-            SetAutoStartVisibility(true);
-        }
-        else
-        {
-            ui->AutoStartStatusLabel->hide();
-        }
-    }
-    else
-    {
-        std::string desc = "OpenRGB ";
-        desc += VERSION_STRING;
-        desc += ", for controlling RGB lighting.";
-
-        std::string arguments = "";
-
-        for(std::pair<const std::string, std::tuple<std::string, std::string, bool>>& x: autostart_map)
-        {
-            std::string argumentsetting = x.first;
-            std::string argument = std::get<0>(x.second);
-            std::string argumentvaluename = std::get<1>(x.second);
-            bool argumentquoted = std::get<2>(x.second);
-
-            if (autostart_settings[x.first])
-            {
-                if (argument != "")
-                {
-                    if (arguments != "")
-                    {
-                        arguments += " ";
-                    }
-                    arguments += argument;
-                }
-                if (argumentvaluename != "")
-                {
-                    std::string argumentvalue = autostart_settings[argumentvaluename];
-                    if (argumentvalue != "")
-                    {
-                        if (arguments != "")
-                        {
-                            arguments += " ";
-                        }
-                        if (argumentquoted)
-                        {
-                            arguments += "\"" + argumentvalue + "\"";
-                        }
-                        else
-                        {
-                            arguments += argumentvalue;
-                        }
-                    }
-                }
-            }
-        }
-
-        AutoStartInfo auto_start_info;
-
-        auto_start_info.args        = arguments;
-        auto_start_info.category    = "Utility;";
-        auto_start_info.desc        = desc;
-        auto_start_info.icon        = "OpenRGB";
-        auto_start_info.path        = auto_start.GetExePath();
-
-        if (!auto_start.EnableAutoStart(auto_start_info))
-        {
-            ui->AutoStartStatusLabel->setText(tr("A problem occurred enabling Start At Login."));
-            ui->AutoStartStatusLabel->show();
-            SetAutoStartVisibility(true);
-        }
-        else
-        {
-            ui->AutoStartStatusLabel->hide();
-        }
-    }
-}
-
-void OpenRGBSettingsPage::CreateAutoStartSettings()
-{
-    std::map<std::string, std::string> autostart_default_map_string = {
-        {"custom", ""},
-        {"host", "0.0.0.0"},
-        {"port", "6742"},
-        {"client","localhost:6742"},
-        {"profile",ui->ComboBoxAutoStartProfile->count() > 0 ? ui->ComboBoxAutoStartProfile->itemText(0).toStdString(): ""}
-    };
-
-    std::map<std::string, bool> autostart_default_map_bool = {
-        {"enabled", false},
-        {"setminimized", false},
-        {"setclient", false},
-        {"setserver", false},
-        {"setserverhost", false},
-        {"setserverport", false},
-        {"setcustom", false},
-        {"setprofile", false},
-    };
-
-    json autostart_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("AutoStart");
-
-    for(std::pair<const std::string, bool>& x: autostart_default_map_bool)
-    {
-        if(!autostart_settings.contains(x.first))
-        {
-            autostart_settings[x.first] = x.second;
-        }
-    }
-
-    for(std::pair<const std::string, std::string>& x: autostart_default_map_string)
-    {
-        if(!autostart_settings.contains(x.first))
-        {
-            autostart_settings[x.first] = x.second;
-        }
-    }
-
-    ResourceManager::get()->GetSettingsManager()->SetSettings("AutoStart", autostart_settings);
-}
-
-void OpenRGBSettingsPage::RemediateAutoStartProfile(json &autostart_settings)
-{
-    /*---------------------------------------------------------*\
-    | If there are no profiles then we disable the UI for       |
-    | profiles and if AutoStart is enabled then we force        |
-    | disable setprofile                                        |
-    \*---------------------------------------------------------*/
-    if(ui->ComboBoxAutoStartProfile->count() == 0)
-    {
-        ui->CheckboxAutoStartProfile->setEnabled(false);
-        ui->ComboBoxAutoStartProfile->setEnabled(false);
-
-        autostart_settings["profile"] = "";
-
-        if(autostart_settings["enabled"])
-        {
-            autostart_settings["setprofile"] = false;
-
-            ResourceManager::get()->GetSettingsManager()->SetSettings("AutoStart", autostart_settings);
-
-            ConfigureAutoStart();
-            SaveSettings();
-        }
-    }
-
-    /*---------------------------------------------------------*\
-    | Else If the profile we want doesn't exist then we force   |
-    | it to a profile which exists and if AutoStart is enabled  |
-    | then we force disable setprofile                          |
-    \*---------------------------------------------------------*/
-    else if(autostart_settings["profile"] == "" ||
-           (autostart_settings["profile"] != "" &&
-            ui->ComboBoxAutoStartProfile->findText(QString::fromStdString(autostart_settings["profile"])) == -1))
-    {
-        autostart_settings["profile"] = ui->ComboBoxAutoStartProfile->itemText(0).toStdString();
-
-        if(autostart_settings["enabled"])
-        {
-            autostart_settings["setprofile"] = false;
-
-            ResourceManager::get()->GetSettingsManager()->SetSettings("AutoStart", autostart_settings);
-
-            ConfigureAutoStart();
-            SaveSettings();
-        }
-    }
-
-    ui->ComboBoxAutoStartProfile->setCurrentText(QString::fromStdString(autostart_settings["profile"]));
-    ui->ComboBoxAutoStartProfile->setEnabled(autostart_settings["setprofile"]);
-    ui->CheckboxAutoStartProfile->setChecked(autostart_settings["setprofile"]);
-}
-
-void OpenRGBSettingsPage::SaveSettings()
-{
-    ResourceManager::get()->GetSettingsManager()->SaveSettings();
-}
-
-void Ui::OpenRGBSettingsPage::on_OpenSettingsFolderButton_clicked()
-{
-    std::string config_dir = ResourceManager::get()->GetConfigurationDirectory().generic_u8string();
-    QUrl url = QUrl::fromLocalFile(QString::fromStdString(config_dir));
-    QDesktopServices::openUrl(url);
-}
-
-
-void Ui::OpenRGBSettingsPage::on_CheckboxLogConsole_clicked()
-{
-    json log_manager_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("LogManager");
-    log_manager_settings["log_console"] = ui->CheckboxLogConsole->isChecked();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("LogManager", log_manager_settings);
-    SaveSettings();
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxAMDSMBusReduceCPU_clicked()
-{
-    json drivers_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Drivers");
-    drivers_settings["amd_smbus_reduce_cpu"] = ui->CheckboxAMDSMBusReduceCPU->isChecked();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("Drivers", drivers_settings);
-    SaveSettings();
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxSharedSMBusAccess_clicked()
-{
-    json drivers_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Drivers");
-    drivers_settings["shared_smbus_access"] = ui->CheckboxSharedSMBusAccess->isChecked();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("Drivers", drivers_settings);
-    SaveSettings();
-}
-
-void Ui::OpenRGBSettingsPage::on_CheckboxDisableKeyExpansion_clicked()
-{
-    json ui_settings                            = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    ui_settings["disable_key_expansion"]        = ui->CheckboxDisableKeyExpansion->isChecked();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-}
-
-void  Ui::OpenRGBSettingsPage::on_CheckboxShowLEDView_clicked()
-{
-    json ui_settings                = ResourceManager::get()->GetSettingsManager()->GetSettings("UserInterface");
-    ui_settings["show_led_view"]    = ui->CheckboxShowLEDView->isChecked();
-    ResourceManager::get()->GetSettingsManager()->SetSettings("UserInterface", ui_settings);
-    SaveSettings();
-}
diff --git a/qt/OpenRGBSettingsPage/OpenRGBSettingsPage.h b/qt/OpenRGBSettingsPage/OpenRGBSettingsPage.h
deleted file mode 100644
index 4e33aa83..00000000
--- a/qt/OpenRGBSettingsPage/OpenRGBSettingsPage.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBSettingsPage.h                                     |
-|                                                           |
-|   User interface for general settings page                |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QCoreApplication>
-#include <QDirIterator>
-#include <QTranslator>
-#include <QWidget>
-#include <json.hpp>
-#include "ui_OpenRGBSettingsPage.h"
-
-using json = nlohmann::json;
-
-namespace Ui
-{
-    class OpenRGBSettingsPage;
-}
-
-class Ui::OpenRGBSettingsPage : public QWidget
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBSettingsPage(QWidget *parent = nullptr);
-    ~OpenRGBSettingsPage();
-
-signals:
-    void TrayIconChanged(bool tray_icon);
-
-public slots:
-    void UpdateProfiles();
-
-private:
-    Ui::OpenRGBSettingsPageUi *ui;
-    void SaveSettings();
-
-    void CreateAutoStartSettings();
-    void ConfigureAutoStart();
-    void RemediateAutoStartProfile(json &autostart_settings);
-    void SetAutoStartVisibility(bool visible);
-    void SaveAutoStartSetting(std::string name, QString value);
-    void SaveAutoStartSetting(std::string name, bool value);
-
-    bool theme_initialized = false;
-    bool autostart_initialized = false;
-    bool hex_format_initialized = false;
-    QTranslator translator;
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_ComboBoxLanguage_currentTextChanged(const QString);
-    void on_ComboBoxTheme_currentTextChanged(const QString);
-    void on_ComboBoxHexFormat_currentTextChanged(const QString);
-    void on_CheckboxMinimizeOnClose_clicked();
-    void on_CheckboxTrayIconGreyscale_clicked();
-    void on_CheckboxLoadGeometry_clicked();
-    void on_CheckboxSaveGeometry_clicked();
-    void on_CheckboxAutoStart_clicked();
-    void on_CheckboxAutoStartMinimized_clicked();
-    void on_CheckboxAutoStartServer_clicked();
-    void on_CheckboxAutoStartClient_clicked();
-    void on_CheckboxAutoStartProfile_clicked();
-    void on_TextServerHost_textChanged(const QString);
-    void on_TextServerPort_textChanged(const QString);
-    void on_TextClientHost_textChanged(const QString);
-    void on_TextCustomArgs_textChanged(const QString);
-    void on_ComboBoxAutoStartProfile_currentTextChanged(const QString);
-    void on_CheckboxAutoStartSetServerHost_clicked();
-    void on_CheckboxAutoStartSetServerPort_clicked();
-    void on_CheckboxAutoStartCustom_clicked();
-    void on_CheckboxRunZoneChecks_clicked();
-    void on_OpenSettingsFolderButton_clicked();
-    void on_CheckboxLogConsole_clicked();
-    void on_CheckboxAMDSMBusReduceCPU_clicked();
-    void on_CheckboxSharedSMBusAccess_clicked();
-
-    void on_CheckboxSetOnExit_clicked(bool checked);
-    void on_ComboBoxExitProfile_currentTextChanged(const QString exit_profile_name);
-    void on_CheckboxSetOnResume_clicked(bool checked);
-    void on_ComboBoxResumeProfile_currentTextChanged(const QString resume_profile_name);
-    void on_CheckboxSetOnSuspend_clicked(bool checked);
-    void on_ComboBoxSuspendProfile_currentTextChanged(const QString suspend_profile_name);
-    void on_CheckboxDisableKeyExpansion_clicked();
-    void on_CheckboxShowLEDView_clicked();
-};
diff --git a/qt/OpenRGBSettingsPage/OpenRGBSettingsPage.ui b/qt/OpenRGBSettingsPage/OpenRGBSettingsPage.ui
deleted file mode 100644
index 638d1a15..00000000
--- a/qt/OpenRGBSettingsPage/OpenRGBSettingsPage.ui
+++ /dev/null
@@ -1,309 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBSettingsPageUi</class>
- <widget class="QWidget" name="OpenRGBSettingsPageUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>475</width>
-    <height>500</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Settings page</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="1" column="1" colspan="6">
-    <widget class="QPushButton" name="OpenSettingsFolderButton">
-     <property name="text">
-      <string>Open Settings Folder</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="1" colspan="6">
-    <widget class="QScrollArea" name="scrollArea">
-     <property name="widgetResizable">
-      <bool>true</bool>
-     </property>
-     <widget class="QWidget" name="scrollAreaWidgetContents_2">
-      <property name="geometry">
-       <rect>
-        <x>0</x>
-        <y>0</y>
-        <width>441</width>
-        <height>856</height>
-       </rect>
-      </property>
-      <layout class="QGridLayout" name="gridLayout_3">
-       <item row="29" column="0">
-        <widget class="QCheckBox" name="CheckboxAutoStartProfile">
-         <property name="text">
-          <string>Load Profile</string>
-         </property>
-        </widget>
-       </item>
-       <item row="28" column="0">
-        <widget class="QCheckBox" name="CheckboxAutoStartCustom">
-         <property name="text">
-          <string>Custom Arguments</string>
-         </property>
-        </widget>
-       </item>
-       <item row="19" column="0">
-        <widget class="QCheckBox" name="CheckboxAutoStart">
-         <property name="text">
-          <string>Start At Login</string>
-         </property>
-        </widget>
-       </item>
-       <item row="6" column="0">
-        <widget class="QCheckBox" name="CheckboxTrayIconGreyscale">
-         <property name="text">
-          <string>Greyscale Tray Icon</string>
-         </property>
-        </widget>
-       </item>
-       <item row="16" column="0">
-        <widget class="QCheckBox" name="CheckboxAMDSMBusReduceCPU">
-         <property name="text">
-          <string>AMD SMBus: Reduce CPU Usage (restart required)</string>
-         </property>
-        </widget>
-       </item>
-       <item row="18" column="0">
-        <widget class="QLabel" name="AutoStartLabel">
-         <property name="text">
-          <string>Start At Login Settings:</string>
-         </property>
-        </widget>
-       </item>
-       <item row="24" column="0">
-        <widget class="QCheckBox" name="CheckboxAutoStartServer">
-         <property name="text">
-          <string>Start Server</string>
-         </property>
-        </widget>
-       </item>
-       <item row="32" column="0">
-        <widget class="QCheckBox" name="CheckboxSetOnExit">
-         <property name="text">
-          <string>Set Profile on Exit</string>
-         </property>
-        </widget>
-       </item>
-       <item row="4" column="0">
-        <widget class="QLabel" name="ThemeLabel">
-         <property name="text">
-          <string>Theme (restart required)</string>
-         </property>
-        </widget>
-       </item>
-       <item row="29" column="1">
-        <widget class="QComboBox" name="ComboBoxAutoStartProfile"/>
-       </item>
-       <item row="11" column="0">
-        <widget class="QCheckBox" name="CheckboxShowLEDView">
-         <property name="text">
-          <string>Show LED view by default</string>
-         </property>
-        </widget>
-       </item>
-       <item row="28" column="1">
-        <widget class="QLineEdit" name="TextCustomArgs"/>
-       </item>
-       <item row="9" column="0">
-        <widget class="QCheckBox" name="CheckboxRunZoneChecks">
-         <property name="text">
-          <string>Run zone checks on rescan</string>
-         </property>
-        </widget>
-       </item>
-       <item row="32" column="1">
-        <widget class="QComboBox" name="ComboBoxExitProfile"/>
-       </item>
-       <item row="14" column="0">
-        <widget class="QCheckBox" name="CheckboxLogConsole">
-         <property name="text">
-          <string>Enable Log Console (restart required)</string>
-         </property>
-        </widget>
-       </item>
-       <item row="4" column="1">
-        <widget class="QComboBox" name="ComboBoxTheme"/>
-       </item>
-       <item row="27" column="0">
-        <widget class="QCheckBox" name="CheckboxAutoStartClient">
-         <property name="text">
-          <string>Start Client</string>
-         </property>
-        </widget>
-       </item>
-       <item row="10" column="0">
-        <widget class="QCheckBox" name="CheckboxDisableKeyExpansion">
-         <property name="text">
-          <string>Disable key expansion in device view</string>
-         </property>
-        </widget>
-       </item>
-       <item row="33" column="0">
-        <widget class="QLabel" name="AutoStartStatusLabel">
-         <property name="text">
-          <string>Start at Login Status</string>
-         </property>
-        </widget>
-       </item>
-       <item row="34" column="0">
-        <spacer name="verticalSpacer">
-         <property name="orientation">
-          <enum>Qt::Vertical</enum>
-         </property>
-         <property name="sizeType">
-          <enum>QSizePolicy::MinimumExpanding</enum>
-         </property>
-         <property name="sizeHint" stdset="0">
-          <size>
-           <width>20</width>
-           <height>40</height>
-          </size>
-         </property>
-        </spacer>
-       </item>
-       <item row="25" column="1">
-        <widget class="QLineEdit" name="TextServerHost"/>
-       </item>
-       <item row="8" column="0">
-        <widget class="QCheckBox" name="CheckboxSaveGeometry">
-         <property name="text">
-          <string>Save Geometry On Close</string>
-         </property>
-        </widget>
-       </item>
-       <item row="5" column="0">
-        <widget class="QCheckBox" name="CheckboxMinimizeOnClose">
-         <property name="text">
-          <string>Minimize On Close</string>
-         </property>
-        </widget>
-       </item>
-       <item row="23" column="0">
-        <widget class="QCheckBox" name="CheckboxAutoStartMinimized">
-         <property name="text">
-          <string>Start Minimized</string>
-         </property>
-        </widget>
-       </item>
-       <item row="2" column="0">
-        <widget class="QLabel" name="UserInterfaceSettingsLabel">
-         <property name="text">
-          <string>User Interface Settings:</string>
-         </property>
-        </widget>
-       </item>
-       <item row="27" column="1">
-        <widget class="QLineEdit" name="TextClientHost"/>
-       </item>
-       <item row="17" column="0">
-        <widget class="QCheckBox" name="CheckboxSharedSMBusAccess">
-         <property name="text">
-          <string>Shared SMBus Access (restart required)</string>
-         </property>
-        </widget>
-       </item>
-       <item row="15" column="0">
-        <widget class="QLabel" name="DriversSettingsLabel">
-         <property name="text">
-          <string>Drivers Settings</string>
-         </property>
-        </widget>
-       </item>
-       <item row="3" column="1">
-        <widget class="QComboBox" name="ComboBoxLanguage"/>
-       </item>
-       <item row="26" column="0">
-        <widget class="QCheckBox" name="CheckboxAutoStartSetServerPort">
-         <property name="text">
-          <string>Set Server Port</string>
-         </property>
-        </widget>
-       </item>
-       <item row="7" column="0">
-        <widget class="QCheckBox" name="CheckboxLoadGeometry">
-         <property name="text">
-          <string>Load Window Geometry</string>
-         </property>
-        </widget>
-       </item>
-       <item row="26" column="1">
-        <widget class="QLineEdit" name="TextServerPort">
-         <property name="inputMask">
-          <string>90000</string>
-         </property>
-         <property name="text">
-          <string/>
-         </property>
-         <property name="placeholderText">
-          <string/>
-         </property>
-        </widget>
-       </item>
-       <item row="13" column="0">
-        <widget class="QLabel" name="LogManagerSettingsLabel">
-         <property name="text">
-          <string>Log Manager Settings:</string>
-         </property>
-        </widget>
-       </item>
-       <item row="3" column="0">
-        <widget class="QLabel" name="LabelLanguage">
-         <property name="text">
-          <string>Language</string>
-         </property>
-        </widget>
-       </item>
-       <item row="25" column="0">
-        <widget class="QCheckBox" name="CheckboxAutoStartSetServerHost">
-         <property name="text">
-          <string>Set Server Host</string>
-         </property>
-        </widget>
-       </item>
-       <item row="12" column="0">
-        <widget class="QLabel" name="HexFormatLabel">
-         <property name="text">
-          <string>Hex Format</string>
-         </property>
-        </widget>
-       </item>
-       <item row="12" column="1">
-        <widget class="QComboBox" name="ComboBoxHexFormat"/>
-       </item>
-       <item row="30" column="0">
-        <widget class="QCheckBox" name="CheckboxSetOnSuspend">
-         <property name="text">
-          <string>Set Profile on Suspend</string>
-         </property>
-        </widget>
-       </item>
-       <item row="30" column="1">
-        <widget class="QComboBox" name="ComboBoxSuspendProfile"/>
-       </item>
-       <item row="31" column="0">
-        <widget class="QCheckBox" name="CheckboxSetOnResume">
-         <property name="text">
-          <string>Set Profile on Resume</string>
-         </property>
-        </widget>
-       </item>
-       <item row="31" column="1">
-        <widget class="QComboBox" name="ComboBoxResumeProfile"/>
-       </item>
-      </layout>
-     </widget>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBSoftwareInfoPage/OpenRGBSoftwareInfoPage.cpp b/qt/OpenRGBSoftwareInfoPage/OpenRGBSoftwareInfoPage.cpp
deleted file mode 100644
index 4e98e5b9..00000000
--- a/qt/OpenRGBSoftwareInfoPage/OpenRGBSoftwareInfoPage.cpp
+++ /dev/null
@@ -1,42 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBSoftwareInfoPage.cpp                               |
-|                                                           |
-|   User interface for software information page            |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBSoftwareInfoPage.h"
-#include "OpenRGBPluginInterface.h"
-#include "NetworkProtocol.h"
-
-using namespace Ui;
-
-OpenRGBSoftwareInfoPage::OpenRGBSoftwareInfoPage(QWidget *parent) :
-    QFrame(parent),
-    ui(new Ui::OpenRGBSoftwareInfoPageUi)
-{
-    ui->setupUi(this);
-
-    ui->VersionValue->setText(VERSION_STRING);
-    ui->SDKVersionValue->setText(QString::number(OPENRGB_SDK_PROTOCOL_VERSION));
-    ui->PluginAPIVersionValue->setText(QString::number(OPENRGB_PLUGIN_API_VERSION));
-    ui->BuildDateValue->setText(BUILDDATE_STRING);
-    ui->GitCommitIDValue->setText(GIT_COMMIT_ID);
-    ui->GitCommitDateValue->setText(GIT_COMMIT_DATE);
-    ui->GitBranchValue->setText(GIT_BRANCH);
-}
-
-OpenRGBSoftwareInfoPage::~OpenRGBSoftwareInfoPage()
-{
-    delete ui;
-}
-
-void OpenRGBSoftwareInfoPage::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
diff --git a/qt/OpenRGBSoftwareInfoPage/OpenRGBSoftwareInfoPage.h b/qt/OpenRGBSoftwareInfoPage/OpenRGBSoftwareInfoPage.h
deleted file mode 100644
index c4475003..00000000
--- a/qt/OpenRGBSoftwareInfoPage/OpenRGBSoftwareInfoPage.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBSoftwareInfoPage.h                                 |
-|                                                           |
-|   User interface for software information page            |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QFrame>
-#include "ui_OpenRGBSoftwareInfoPage.h"
-
-namespace Ui
-{
-    class OpenRGBSoftwareInfoPage;
-}
-
-class Ui::OpenRGBSoftwareInfoPage : public QFrame
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBSoftwareInfoPage(QWidget *parent = nullptr);
-    ~OpenRGBSoftwareInfoPage();
-
-private:
-    Ui::OpenRGBSoftwareInfoPageUi *ui;
-
-private slots:
-    void changeEvent(QEvent *event);
-};
diff --git a/qt/OpenRGBSoftwareInfoPage/OpenRGBSoftwareInfoPage.ui b/qt/OpenRGBSoftwareInfoPage/OpenRGBSoftwareInfoPage.ui
deleted file mode 100644
index 06589aba..00000000
--- a/qt/OpenRGBSoftwareInfoPage/OpenRGBSoftwareInfoPage.ui
+++ /dev/null
@@ -1,186 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBSoftwareInfoPageUi</class>
- <widget class="QFrame" name="OpenRGBSoftwareInfoPageUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>699</width>
-    <height>312</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Software info page</string>
-  </property>
-  <property name="autoFillBackground">
-   <bool>false</bool>
-  </property>
-  <property name="frameShape">
-   <enum>QFrame::NoFrame</enum>
-  </property>
-  <property name="frameShadow">
-   <enum>QFrame::Sunken</enum>
-  </property>
-  <layout class="QGridLayout" name="gridLayout" columnstretch="0">
-   <item row="0" column="0">
-    <widget class="QFrame" name="SoftwareInfoFrame">
-     <property name="autoFillBackground">
-      <bool>true</bool>
-     </property>
-     <property name="frameShape">
-      <enum>QFrame::StyledPanel</enum>
-     </property>
-     <property name="frameShadow">
-      <enum>QFrame::Sunken</enum>
-     </property>
-     <layout class="QGridLayout" name="gridLayout_2" columnstretch="0,1">
-      <item row="7" column="1">
-       <widget class="QLabel" name="GitlabLinkValue">
-        <property name="text">
-         <string>&lt;a href=&quot;https://gitlab.com/CalcProgrammer1/OpenRGB&quot;&gt;https://gitlab.com/CalcProgrammer1/OpenRGB&lt;/a&gt;</string>
-        </property>
-        <property name="textFormat">
-         <enum>Qt::RichText</enum>
-        </property>
-        <property name="openExternalLinks">
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
-      <item row="4" column="1">
-       <widget class="QLabel" name="GitCommitIDValue">
-        <property name="text">
-         <string notr="true">Git Commit ID Value</string>
-        </property>
-        <property name="textInteractionFlags">
-         <set>Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>
-        </property>
-       </widget>
-      </item>
-      <item row="4" column="0">
-       <widget class="QLabel" name="GitCommitIDLabel">
-        <property name="text">
-         <string>Git Commit ID:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="8" column="1">
-       <widget class="QLabel" name="WebsiteLinkValue">
-        <property name="text">
-         <string>&lt;a href=&quot;https://openrgb.org&quot;&gt;https://openrgb.org&lt;/a&gt;</string>
-        </property>
-        <property name="textFormat">
-         <enum>Qt::RichText</enum>
-        </property>
-        <property name="openExternalLinks">
-         <bool>true</bool>
-        </property>
-       </widget>
-      </item>
-      <item row="7" column="0">
-       <widget class="QLabel" name="GitlabLinkLabel">
-        <property name="text">
-         <string>Gitlab page</string>
-        </property>
-       </widget>
-      </item>
-      <item row="6" column="0">
-       <widget class="QLabel" name="GitBranchLabel">
-        <property name="text">
-         <string>Git Branch:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="3" column="1">
-       <widget class="QLabel" name="BuildDateValue">
-        <property name="text">
-         <string notr="true">Build Date Value</string>
-        </property>
-       </widget>
-      </item>
-      <item row="6" column="1">
-       <widget class="QLabel" name="GitBranchValue">
-        <property name="text">
-         <string notr="true">Git Branch Value</string>
-        </property>
-       </widget>
-      </item>
-      <item row="8" column="0">
-       <widget class="QLabel" name="WebsiteLinkLabel">
-        <property name="text">
-         <string>Website</string>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="1">
-       <widget class="QLabel" name="GitCommitDateValue">
-        <property name="text">
-         <string notr="true">Git Commit Date Value</string>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="0">
-       <widget class="QLabel" name="SDKVersionLabel">
-        <property name="text">
-         <string>SDK Version:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="0" column="0">
-       <widget class="QLabel" name="VersionLabel">
-        <property name="text">
-         <string>Version:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="0">
-       <widget class="QLabel" name="GitCommitDateLabel">
-        <property name="text">
-         <string>Git Commit Date:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="0" column="1">
-       <widget class="QLabel" name="VersionValue">
-        <property name="text">
-         <string notr="true">Version Value</string>
-        </property>
-       </widget>
-      </item>
-      <item row="3" column="0">
-       <widget class="QLabel" name="BuildDateLabel">
-        <property name="text">
-         <string>Build Date:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="2" column="0">
-       <widget class="QLabel" name="PluginAPIVersionLabel">
-        <property name="text">
-         <string>Plugin API Version:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="1" column="1">
-       <widget class="QLabel" name="SDKVersionValue">
-        <property name="text">
-         <string>SDK Version Value</string>
-        </property>
-       </widget>
-      </item>
-      <item row="2" column="1">
-       <widget class="QLabel" name="PluginAPIVersionValue">
-        <property name="text">
-         <string>Plugin API Version Value</string>
-        </property>
-       </widget>
-      </item>
-     </layout>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBSupportedDevicesPage/OpenRGBSupportedDevicesPage.cpp b/qt/OpenRGBSupportedDevicesPage/OpenRGBSupportedDevicesPage.cpp
deleted file mode 100644
index 62dc01ae..00000000
--- a/qt/OpenRGBSupportedDevicesPage/OpenRGBSupportedDevicesPage.cpp
+++ /dev/null
@@ -1,83 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBSupportedDevicePage.cpp                            |
-|                                                           |
-|   User interface for enabling and disabling devices       |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBSupportedDevicesPage.h"
-#include "ui_OpenRGBSupportedDevicesPage.h"
-#include "ResourceManager.h"
-#include "OpenRGBHardwareIDsDialog.h"
-
-using namespace Ui;
-
-OpenRGBSupportedDevicesPage::OpenRGBSupportedDevicesPage(QWidget *parent) :
-    QWidget(parent),
-    ui(new Ui::OpenRGBSupportedDevicesPageUi)
-{
-    ui->setupUi(this);
-
-    /*-----------------------------------------------------*\
-    | Create a detector table model and a sort model and    |
-    | set them                                              |
-    \*-----------------------------------------------------*/
-    detectorTableModel = new DetectorTableModel;
-    detectorSortModel = new QSortFilterProxyModel;
-
-    detectorSortModel->setSourceModel(detectorTableModel);
-    ui->SupportedDevicesTable->setModel(detectorSortModel);
-
-    /*-----------------------------------------------------*\
-    | Disable header, enable sorting, and sort in ascending |
-    | order                                                 |
-    \*-----------------------------------------------------*/
-    ui->SupportedDevicesTable->verticalHeader()->setVisible(0);
-    ui->SupportedDevicesTable->setSortingEnabled(true);
-    ui->SupportedDevicesTable->sortByColumn(0, Qt::AscendingOrder);
-
-    /*-----------------------------------------------------*\
-    | Resize columns to fit the contents                    |
-    \*-----------------------------------------------------*/
-    ui->SupportedDevicesTable->horizontalHeader()->setSectionResizeMode(0, QHeaderView::Stretch);
-}
-
-OpenRGBSupportedDevicesPage::~OpenRGBSupportedDevicesPage()
-{
-    delete ui;
-}
-
-void OpenRGBSupportedDevicesPage::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void OpenRGBSupportedDevicesPage::on_SaveButton_clicked()
-{
-    detectorTableModel->applySettings();
-}
-
-void OpenRGBSupportedDevicesPage::on_GetHardwareIDsButton_clicked()
-{
-    OpenRGBHardwareIDsDialog dialog(this);
-    dialog.show();
-}
-
-void OpenRGBSupportedDevicesPage::on_Filter_textChanged(const QString &arg1)
-{
-#ifdef _QT6
-    detectorSortModel->setFilterRegularExpression(QRegularExpression(arg1 , QRegularExpression::CaseInsensitiveOption));
-#else
-    detectorSortModel->setFilterRegExp(QRegExp(arg1, Qt::CaseInsensitive));
-#endif
-}
-
-void OpenRGBSupportedDevicesPage::on_ToggleAllCheckbox_toggled(const bool checked)
-{
-    detectorTableModel->toggleAll(checked, detectorSortModel);
-}
diff --git a/qt/OpenRGBSupportedDevicesPage/OpenRGBSupportedDevicesPage.h b/qt/OpenRGBSupportedDevicesPage/OpenRGBSupportedDevicesPage.h
deleted file mode 100644
index 8ba07e22..00000000
--- a/qt/OpenRGBSupportedDevicesPage/OpenRGBSupportedDevicesPage.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBSupportedDevicePage.h                              |
-|                                                           |
-|   User interface for enabling and disabling devices       |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QWidget>
-#include <QSortFilterProxyModel>
-#include "DetectorTableModel.h"
-#include "ui_OpenRGBSupportedDevicesPage.h"
-
-namespace Ui
-{
-    class OpenRGBSupportedDevicesPage;
-}
-
-class Ui::OpenRGBSupportedDevicesPage : public QWidget
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBSupportedDevicesPage(QWidget *parent = nullptr);
-    ~OpenRGBSupportedDevicesPage();
-    DetectorTableModel* detectorTableModel;
-    QSortFilterProxyModel* detectorSortModel;
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_SaveButton_clicked();
-    void on_GetHardwareIDsButton_clicked();
-
-    void on_Filter_textChanged(const QString &arg1);
-
-    void on_ToggleAllCheckbox_toggled(const bool checked);
-
-private:
-    Ui::OpenRGBSupportedDevicesPageUi *ui;
-};
diff --git a/qt/OpenRGBSupportedDevicesPage/OpenRGBSupportedDevicesPage.ui b/qt/OpenRGBSupportedDevicesPage/OpenRGBSupportedDevicesPage.ui
deleted file mode 100644
index aaf686a6..00000000
--- a/qt/OpenRGBSupportedDevicesPage/OpenRGBSupportedDevicesPage.ui
+++ /dev/null
@@ -1,63 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBSupportedDevicesPageUi</class>
- <widget class="QWidget" name="OpenRGBSupportedDevicesPageUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>400</width>
-    <height>300</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Supported devices</string>
-  </property>
-  <layout class="QVBoxLayout" name="verticalLayout">
-   <item>
-    <layout class="QHBoxLayout" name="horizontalLayout">
-     <item>
-      <widget class="QLabel" name="label">
-       <property name="text">
-        <string>Filter:</string>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <widget class="QLineEdit" name="Filter"/>
-     </item>
-     <item>
-      <widget class="QCheckBox" name="ToggleAllCheckbox">
-       <property name="text">
-        <string>Enable/Disable all</string>
-       </property>
-      </widget>
-     </item>
-    </layout>
-   </item>
-   <item>
-    <widget class="QTableView" name="SupportedDevicesTable"/>
-   </item>
-   <item>
-    <layout class="QHBoxLayout" name="ButtonsLayout">
-     <item>
-      <widget class="QPushButton" name="SaveButton">
-       <property name="text">
-        <string>Apply changes</string>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <widget class="QPushButton" name="GetHardwareIDsButton">
-       <property name="text">
-        <string>Get hardware IDs</string>
-       </property>
-      </widget>
-     </item>
-    </layout>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBSystemInfoPage/OpenRGBSystemInfoPage.cpp b/qt/OpenRGBSystemInfoPage/OpenRGBSystemInfoPage.cpp
deleted file mode 100644
index da1ab0fa..00000000
--- a/qt/OpenRGBSystemInfoPage/OpenRGBSystemInfoPage.cpp
+++ /dev/null
@@ -1,148 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBSystemInfoPage.cpp                                 |
-|                                                           |
-|   User interface entry for OpenRGB system information page|
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include "OpenRGBSystemInfoPage.h"
-#include "ResourceManager.h"
-#include "i2c_tools.h"
-
-using namespace Ui;
-
-static void UpdateBusListCallback(void * this_ptr)
-{
-    OpenRGBSystemInfoPage * this_obj = (OpenRGBSystemInfoPage *)this_ptr;
-
-    QMetaObject::invokeMethod(this_obj, "UpdateBusList", Qt::QueuedConnection);
-}
-
-OpenRGBSystemInfoPage::OpenRGBSystemInfoPage(std::vector<i2c_smbus_interface *>& bus, QWidget *parent) :
-    QFrame(parent),
-    ui(new Ui::OpenRGBSystemInfoPageUi),
-    busses(bus)
-{
-    ui->setupUi(this);
-
-    /*-----------------------------------------------------*\
-    | Use a monospace font for the text box                 |
-    \*-----------------------------------------------------*/
-    QFont MonoFont("monospace");
-    MonoFont.setStyleHint(QFont::Monospace);
-    ui->SMBusDataText->setFont(MonoFont);
-
-    /*-----------------------------------------------------*\
-    | Register I2C bus list change callback                 |
-    \*-----------------------------------------------------*/
-    ResourceManager::get()->RegisterI2CBusListChangeCallback(UpdateBusListCallback, this);
-
-    /*-----------------------------------------------------*\
-    | Update the bus list                                   |
-    \*-----------------------------------------------------*/
-    UpdateBusList();
-
-    ui->SMBusDetectionModeBox->addItem("Auto");
-    ui->SMBusDetectionModeBox->addItem("Quick");
-    ui->SMBusDetectionModeBox->addItem("Read");
-
-    ui->SMBusDetectionModeBox->setCurrentIndex(0);
-}
-
-OpenRGBSystemInfoPage::~OpenRGBSystemInfoPage()
-{
-    delete ui;
-}
-
-void OpenRGBSystemInfoPage::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void Ui::OpenRGBSystemInfoPage::UpdateBusList()
-{
-    /*-----------------------------------------------------*\
-    | Fill in the combo boxes with device information       |
-    \*-----------------------------------------------------*/
-    ui->SMBusAdaptersBox->clear();
-
-    for (std::size_t i = 0; i < busses.size(); i++)
-    {
-        ui->SMBusAdaptersBox->addItem(busses[i]->device_name);
-    }
-
-    ui->SMBusAdaptersBox->setCurrentIndex(0);
-}
-
-void Ui::OpenRGBSystemInfoPage::on_DetectButton_clicked()
-{
-    int current_index = ui->SMBusAdaptersBox->currentIndex();
-
-    if(current_index < 0)
-    {
-        current_index = 0;
-    }
-
-    if((int)(busses.size()) > current_index)
-    {
-        i2c_smbus_interface* bus = busses[current_index];
-
-        switch(ui->SMBusDetectionModeBox->currentIndex())
-        {
-        case 0:
-            ui->SMBusDataText->setPlainText(i2c_detect(bus, MODE_AUTO).c_str());
-            break;
-
-        case 1:
-            ui->SMBusDataText->setPlainText(i2c_detect(bus, MODE_QUICK).c_str());
-            break;
-
-        case 2:
-            ui->SMBusDataText->setPlainText(i2c_detect(bus, MODE_READ).c_str());
-            break;
-        }
-    }
-}
-
-void Ui::OpenRGBSystemInfoPage::on_DumpButton_clicked()
-{
-    int current_index = ui->SMBusAdaptersBox->currentIndex();
-
-    if(current_index < 0)
-    {
-        current_index = 0;
-    }
-
-    if((int)(busses.size()) > current_index)
-    {
-        i2c_smbus_interface* bus = busses[current_index];
-        unsigned char address = ui->DumpAddressBox->value();
-
-        ui->SMBusDataText->setPlainText(i2c_dump(bus, address).c_str());
-    }
-}
-
-void Ui::OpenRGBSystemInfoPage::on_ReadButton_clicked()
-{
-    int current_index = ui->SMBusAdaptersBox->currentIndex();
-
-    if(current_index < 0)
-    {
-        current_index = 0;
-    }
-
-    if((int)(busses.size()) > current_index)
-    {
-        i2c_smbus_interface* bus = busses[current_index];
-        unsigned char address = ui->ReadAddressBox->value();
-        unsigned char regaddr = ui->ReadRegisterBox->value();
-        unsigned char size    = ui->ReadSizeBox->value();
-
-        ui->SMBusDataText->setPlainText(i2c_read(bus, address, regaddr, size).c_str());
-    }
-}
diff --git a/qt/OpenRGBSystemInfoPage/OpenRGBSystemInfoPage.h b/qt/OpenRGBSystemInfoPage/OpenRGBSystemInfoPage.h
deleted file mode 100644
index 6b4ef94e..00000000
--- a/qt/OpenRGBSystemInfoPage/OpenRGBSystemInfoPage.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBSystemInfoPage.h                                   |
-|                                                           |
-|   User interface entry for OpenRGB system information page|
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QFrame>
-#include "ui_OpenRGBSystemInfoPage.h"
-#include "i2c_smbus.h"
-
-namespace Ui
-{
-    class OpenRGBSystemInfoPage;
-}
-
-class Ui::OpenRGBSystemInfoPage : public QFrame
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBSystemInfoPage(std::vector<i2c_smbus_interface *>& bus, QWidget *parent = nullptr);
-    ~OpenRGBSystemInfoPage();
-
-public slots:
-    void UpdateBusList();
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_DetectButton_clicked();
-
-    void on_DumpButton_clicked();
-
-    void on_ReadButton_clicked();
-
-private:
-    Ui::OpenRGBSystemInfoPageUi *ui;
-    std::vector<i2c_smbus_interface *>& busses;
-};
diff --git a/qt/OpenRGBSystemInfoPage/OpenRGBSystemInfoPage.ui b/qt/OpenRGBSystemInfoPage/OpenRGBSystemInfoPage.ui
deleted file mode 100644
index 4592247e..00000000
--- a/qt/OpenRGBSystemInfoPage/OpenRGBSystemInfoPage.ui
+++ /dev/null
@@ -1,171 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBSystemInfoPageUi</class>
- <widget class="QFrame" name="OpenRGBSystemInfoPageUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>500</width>
-    <height>320</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>System info page</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="0" column="0">
-    <widget class="QLabel" name="SMBusAdaptersLabel">
-     <property name="text">
-      <string>SMBus Adapters:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="2" column="1">
-    <widget class="QLabel" name="DumpAddressLabel">
-     <property name="text">
-      <string>Address:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="3" column="3">
-    <widget class="QPushButton" name="ReadButton">
-     <property name="text">
-      <string>Read Device</string>
-     </property>
-    </widget>
-   </item>
-   <item row="4" column="0" colspan="4">
-    <widget class="QPlainTextEdit" name="SMBusDataText"/>
-   </item>
-   <item row="2" column="0">
-    <widget class="QLabel" name="SMBusDumpLabel">
-     <property name="text">
-      <string>SMBus Dumper:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="2" column="2">
-    <widget class="QSpinBox" name="DumpAddressBox">
-     <property name="suffix">
-      <string/>
-     </property>
-     <property name="prefix">
-      <string>0x</string>
-     </property>
-     <property name="maximum">
-      <number>255</number>
-     </property>
-     <property name="displayIntegerBase">
-      <number>16</number>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="0">
-    <widget class="QLabel" name="SMBusDetectorLabel">
-     <property name="text">
-      <string>SMBus Detector:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="1" colspan="3">
-    <widget class="QComboBox" name="SMBusAdaptersBox"/>
-   </item>
-   <item row="1" column="1">
-    <widget class="QLabel" name="SMBusDetectModeLabel">
-     <property name="text">
-      <string>Detection Mode:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="2">
-    <widget class="QComboBox" name="SMBusDetectionModeBox"/>
-   </item>
-   <item row="1" column="3">
-    <widget class="QPushButton" name="DetectButton">
-     <property name="text">
-      <string>Detect Devices</string>
-     </property>
-    </widget>
-   </item>
-   <item row="2" column="3">
-    <widget class="QPushButton" name="DumpButton">
-     <property name="text">
-      <string>Dump Device</string>
-     </property>
-    </widget>
-   </item>
-   <item row="3" column="0">
-    <widget class="QLabel" name="SMBusReaderLabel">
-     <property name="text">
-      <string>SMBus Reader:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="3" column="1" colspan="2">
-    <layout class="QHBoxLayout" name="horizontalLayout">
-     <item>
-      <widget class="QLabel" name="ReadAddressLabel">
-       <property name="text">
-        <string>Addr:</string>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <widget class="QSpinBox" name="ReadAddressBox">
-       <property name="prefix">
-        <string>0x</string>
-       </property>
-       <property name="maximum">
-        <number>255</number>
-       </property>
-       <property name="displayIntegerBase">
-        <number>16</number>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <widget class="QLabel" name="ReadRegisterLabel">
-       <property name="text">
-        <string>Reg:</string>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <widget class="QSpinBox" name="ReadRegisterBox">
-       <property name="prefix">
-        <string>0x</string>
-       </property>
-       <property name="maximum">
-        <number>255</number>
-       </property>
-       <property name="displayIntegerBase">
-        <number>16</number>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <widget class="QLabel" name="ReadSizeLabel">
-       <property name="text">
-        <string>Size:</string>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <widget class="QSpinBox" name="ReadSizeBox"/>
-     </item>
-    </layout>
-   </item>
-  </layout>
- </widget>
- <tabstops>
-  <tabstop>SMBusAdaptersBox</tabstop>
-  <tabstop>SMBusDetectionModeBox</tabstop>
-  <tabstop>DetectButton</tabstop>
-  <tabstop>DumpAddressBox</tabstop>
-  <tabstop>DumpButton</tabstop>
-  <tabstop>SMBusDataText</tabstop>
- </tabstops>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/OpenRGBThemeManager.cpp b/qt/OpenRGBThemeManager.cpp
deleted file mode 100644
index 4f3c992a..00000000
--- a/qt/OpenRGBThemeManager.cpp
+++ /dev/null
@@ -1,128 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBThemeManager.cpp                                   |
-|                                                           |
-|   Functionality for managing dark theme mode              |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QApplication>
-#include <QWidget>
-#include <QStyle>
-#include <QPalette>
-#include <QStyleFactory>
-
-#ifdef _WIN32
-#include <QSettings>
-#endif
-
-#include "OpenRGBThemeManager.h"
-#include "ResourceManager.h"
-#include "PluginManager.h"
-#include "SettingsManager.h"
-
-void OpenRGBThemeManager::Init()
-{
-
-#ifdef __APPLE__
-    /*-------------------------------------------------*\
-    | Apply Qt Fusion theme on MacOS, as the MacOS      |
-    | default theme does not handle vertical tabs well  |
-    \*-------------------------------------------------*/
-    QApplication::setStyle(QStyleFactory::create("Fusion"));
-#else
-    /*---------------------------------------------------*\
-    | Apply dark theme on Windows and Linux if configured |
-    \*---------------------------------------------------*/
-    if(IsDarkTheme())
-    {
-        SetDarkTheme();
-    }
-#endif
-
-}
-
-void OpenRGBThemeManager::SetDarkTheme()
-{
-    QPalette pal;
-
-    pal.setColor(QPalette::WindowText,      Qt::white);
-    pal.setColor(QPalette::Link,            QColor(0,127,220));
-    pal.setColor(QPalette::LinkVisited,     QColor(64,196,220));
-    pal.setColor(QPalette::Window,          QColor(53,53,53));
-    pal.setColor(QPalette::Base,            QColor(53,53,53));
-    pal.setColor(QPalette::AlternateBase,   QColor(66,66,66));
-    pal.setColor(QPalette::ToolTipBase,     Qt::white);
-    pal.setColor(QPalette::ToolTipText,     Qt::black);
-    pal.setColor(QPalette::Text,            Qt::white);
-    pal.setColor(QPalette::Dark,            QColor(35,35,35));
-    pal.setColor(QPalette::Shadow,          QColor(20,20,20));
-    pal.setColor(QPalette::Button,          QColor(53,53,53));
-    pal.setColor(QPalette::ButtonText,      Qt::white);
-    pal.setColor(QPalette::BrightText,      Qt::red);
-    pal.setColor(QPalette::Highlight,       QColor(42,130,218));
-    pal.setColor(QPalette::HighlightedText, Qt::white);
-
-    pal.setColor(QPalette::Disabled, QPalette::Text,             QColor(127,127,127));
-    pal.setColor(QPalette::Disabled, QPalette::WindowText,       QColor(127,127,127));
-    pal.setColor(QPalette::Disabled, QPalette::Highlight,        QColor(80,80,80)   );
-    pal.setColor(QPalette::Disabled, QPalette::ButtonText,       QColor(127,127,127));
-    pal.setColor(QPalette::Disabled, QPalette::HighlightedText,  QColor(127,127,127));
-    pal.setColor(QPalette::Disabled, QPalette::Text,             QColor(127,127,127));
-    pal.setColor(QPalette::Disabled, QPalette::ButtonText,       QColor(127,127,127));
-
-#ifdef _WIN32
-    QApplication::setStyle(QStyleFactory::create("Fusion"));
-#endif
-
-    QApplication::setPalette(pal);
-}
-
-bool OpenRGBThemeManager::IsDarkTheme()
-{
-
-    /*-------------------------------------------------*\
-    | Dark theme settings                               |
-    \*-------------------------------------------------*/
-    json            theme_settings;
-
-    /*-------------------------------------------------*\
-    | Get prefered theme from settings manager          |
-    \*-------------------------------------------------*/
-    theme_settings = ResourceManager::get()->GetSettingsManager()->GetSettings("Theme");
-
-    /*-------------------------------------------------*\
-    | Read the theme key and adjust accordingly         |
-    \*-------------------------------------------------*/
-    std::string current_theme = "light";
-
-    if(theme_settings.contains("theme"))
-    {
-        current_theme = theme_settings["theme"];
-    }
-
-    if(current_theme == "dark")
-    {
-        return true;
-    }
-#ifdef _WIN32
-    else if(current_theme == "auto")
-    {
-        QSettings settings("HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize", QSettings::NativeFormat);
-
-        if(settings.value("AppsUseLightTheme") != 0)
-        {
-            return false;
-        }
-        else
-        {
-            return true;
-        }
-    }
-
-    return false;
-#endif
-
-    return false;
-}
diff --git a/qt/OpenRGBThemeManager.h b/qt/OpenRGBThemeManager.h
deleted file mode 100644
index 334da2fe..00000000
--- a/qt/OpenRGBThemeManager.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBThemeManager.h                                     |
-|                                                           |
-|   Functionality for managing dark theme mode              |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <string>
-
-class OpenRGBThemeManager
-{
-public:
-    static void Init();
-    static void SetDarkTheme();
-    static bool IsDarkTheme();
-};
diff --git a/qt/OpenRGBZoneResizeDialog/OpenRGBZoneResizeDialog.cpp b/qt/OpenRGBZoneResizeDialog/OpenRGBZoneResizeDialog.cpp
deleted file mode 100644
index 290078d6..00000000
--- a/qt/OpenRGBZoneResizeDialog/OpenRGBZoneResizeDialog.cpp
+++ /dev/null
@@ -1,303 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBZoneResizeDialog.cpp                               |
-|                                                           |
-|   User interface for resizing zones                       |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QLineEdit>
-#include "OpenRGBZoneResizeDialog.h"
-
-using namespace Ui;
-
-OpenRGBZoneResizeDialog::OpenRGBZoneResizeDialog(RGBController* edit_dev_ptr, unsigned int edit_zone_idx_val, QWidget *parent) :
-    QDialog(parent),
-    ui(new Ui::OpenRGBZoneResizeDialogUi)
-{
-    edit_dev      = edit_dev_ptr;
-    edit_zone_idx = edit_zone_idx_val;
-
-    unsigned int size_min     = edit_dev->zones[edit_zone_idx].leds_min;
-    unsigned int size_max     = edit_dev->zones[edit_zone_idx].leds_max;
-    unsigned int size_current = edit_dev->zones[edit_zone_idx].leds_count;
-
-    ui->setupUi(this);
-
-    QStringList header_labels;
-    header_labels << "Name" << "Size" << "";
-    ui->SegmentsTreeWidget->setHeaderLabels(header_labels);
-
-    ui->ResizeSlider->setRange(size_min, size_max);
-    ui->ResizeBox->setRange(size_min, size_max);
-
-    ui->ResizeSlider->setValue(size_current);
-    ui->ResizeBox->setValue(size_current);
-
-    for(unsigned int segment_idx = 0; segment_idx < edit_dev->zones[edit_zone_idx].segments.size(); segment_idx++)
-    {
-        QTreeWidgetItem* new_item   = new QTreeWidgetItem(ui->SegmentsTreeWidget);
-
-        QLineEdit* lineedit_name    = new QLineEdit(ui->SegmentsTreeWidget);
-        QLineEdit* lineedit_length  = new QLineEdit(ui->SegmentsTreeWidget);
-        QSlider*   slider_length    = new QSlider(Qt::Horizontal, ui->SegmentsTreeWidget);
-
-        slider_length->setMaximum(edit_dev->zones[edit_zone_idx].leds_count);
-
-        lineedit_name->setText(QString::fromStdString(edit_dev->zones[edit_zone_idx].segments[segment_idx].name));
-        lineedit_length->setText(QString::number(edit_dev->zones[edit_zone_idx].segments[segment_idx].leds_count));
-        slider_length->setSliderPosition(edit_dev->zones[edit_zone_idx].segments[segment_idx].leds_count);
-
-        ui->SegmentsTreeWidget->setItemWidget(new_item, 0, lineedit_name);
-        ui->SegmentsTreeWidget->setItemWidget(new_item, 1, lineedit_length);
-        ui->SegmentsTreeWidget->setItemWidget(new_item, 2, slider_length);
-
-        connect(slider_length, &QSlider::valueChanged, this, &OpenRGBZoneResizeDialog::on_segment_slider_valueChanged);
-        connect(lineedit_length, &QLineEdit::textChanged, this, &OpenRGBZoneResizeDialog::on_segment_lineedit_textChanged);
-    }
-}
-
-OpenRGBZoneResizeDialog::OpenRGBZoneResizeDialog(unsigned int edit_zone_min_val, unsigned int edit_zone_max_val, unsigned int edit_zone_current_val, QWidget *parent) :
-    QDialog(parent),
-    ui(new Ui::OpenRGBZoneResizeDialogUi)
-{
-    /*-----------------------------------------------------*\
-    | This constructor does not use a device pointer.       |
-    \*-----------------------------------------------------*/
-    edit_dev = NULL;
-
-    ui->setupUi(this);
-
-    /*-----------------------------------------------------*\
-    | This constructor is used for resizing mode-specific   |
-    | colors.  Segments are not used in this mode, so hide  |
-    | the Segments tree view and buttons.                   |
-    \*-----------------------------------------------------*/
-    ui->SegmentsTreeWidget->hide();
-    ui->AddSegmentButton->hide();
-    ui->RemoveSegmentButton->hide();
-
-    ui->ResizeSlider->setRange(edit_zone_min_val, edit_zone_max_val);
-    ui->ResizeBox->setRange(edit_zone_min_val, edit_zone_max_val);
-
-    ui->ResizeSlider->setValue(edit_zone_current_val);
-    ui->ResizeBox->setValue(edit_zone_current_val);
-}
-
-OpenRGBZoneResizeDialog::~OpenRGBZoneResizeDialog()
-{
-    delete ui;
-}
-
-void OpenRGBZoneResizeDialog::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void Ui::OpenRGBZoneResizeDialog::on_ResizeSlider_valueChanged(int value)
-{
-    ui->ResizeBox->blockSignals(true);
-    ui->ResizeBox->setValue(value);
-    ui->ResizeBox->blockSignals(false);
-
-    /*-----------------------------------------------------*\
-    | Set maximum value for all segment sliders to new zone |
-    | size                                                  |
-    \*-----------------------------------------------------*/
-    for(int item_idx = 0; item_idx < ui->SegmentsTreeWidget->topLevelItemCount(); item_idx++)
-    {
-        ((QSlider*)ui->SegmentsTreeWidget->itemWidget(ui->SegmentsTreeWidget->topLevelItem(item_idx), 2))->setMaximum(value);
-    }
-
-    CheckSegmentsValidity();
-}
-
-void Ui::OpenRGBZoneResizeDialog::on_segment_lineedit_textChanged()
-{
-    /*-----------------------------------------------------*\
-    | Update the Slider with the LineEdit value for each    |
-    | segment                                               |
-    \*-----------------------------------------------------*/
-    for(int item_idx = 0; item_idx < ui->SegmentsTreeWidget->topLevelItemCount(); item_idx++)
-    {
-        int lineedit_value = ((QLineEdit*)ui->SegmentsTreeWidget->itemWidget(ui->SegmentsTreeWidget->topLevelItem(item_idx), 1))->text().toInt();
-        ((QSlider*)ui->SegmentsTreeWidget->itemWidget(ui->SegmentsTreeWidget->topLevelItem(item_idx), 2))->setValue(lineedit_value);
-    }
-
-    CheckSegmentsValidity();
-}
-
-void Ui::OpenRGBZoneResizeDialog::on_segment_slider_valueChanged(int)
-{
-    /*-----------------------------------------------------*\
-    | Update the LineEdit with the Slider value for each    |
-    | segment                                               |
-    \*-----------------------------------------------------*/
-    for(int item_idx = 0; item_idx < ui->SegmentsTreeWidget->topLevelItemCount(); item_idx++)
-    {
-        int slider_value = ((QSlider*)ui->SegmentsTreeWidget->itemWidget(ui->SegmentsTreeWidget->topLevelItem(item_idx), 2))->value();
-        ((QLineEdit*)ui->SegmentsTreeWidget->itemWidget(ui->SegmentsTreeWidget->topLevelItem(item_idx), 1))->setText(QString::number(slider_value));
-    }
-
-    CheckSegmentsValidity();
-}
-
-void Ui::OpenRGBZoneResizeDialog::on_ResizeBox_valueChanged(int value)
-{
-    ui->ResizeSlider->blockSignals(true);
-    ui->ResizeSlider->setValue(value);
-    ui->ResizeSlider->blockSignals(false);
-
-    /*-----------------------------------------------------*\
-    | Set maximum value for all segment sliders to new zone |
-    | size                                                  |
-    \*-----------------------------------------------------*/
-    for(int item_idx = 0; item_idx < ui->SegmentsTreeWidget->topLevelItemCount(); item_idx++)
-    {
-        ((QSlider*)ui->SegmentsTreeWidget->itemWidget(ui->SegmentsTreeWidget->topLevelItem(item_idx), 2))->setMaximum(value);
-    }
-
-    CheckSegmentsValidity();
-}
-
-int Ui::OpenRGBZoneResizeDialog::show()
-{
-    int ret_val = 0;
-
-    int result = this->exec();
-
-    if(result == QDialog::Rejected)
-    {
-        ret_val = -1;
-    }
-    else
-    {
-        ret_val = ui->ResizeBox->value();
-    }
-
-    if(ret_val >= 0 && edit_dev != NULL)
-    {
-        edit_dev->ResizeZone(edit_zone_idx, ret_val);
-
-        edit_dev->zones[edit_zone_idx].segments.clear();
-
-        unsigned int start_idx = 0;
-
-        for(int item_idx = 0; item_idx < ui->SegmentsTreeWidget->topLevelItemCount(); item_idx++)
-        {
-            segment new_segment;
-            new_segment.type       = ZONE_TYPE_LINEAR;
-            new_segment.name       = ((QLineEdit*)ui->SegmentsTreeWidget->itemWidget(ui->SegmentsTreeWidget->topLevelItem(item_idx), 0))->text().toStdString();
-            new_segment.start_idx  = start_idx;
-            new_segment.leds_count = ((QLineEdit*)ui->SegmentsTreeWidget->itemWidget(ui->SegmentsTreeWidget->topLevelItem(item_idx), 1))->text().toInt();
-
-            edit_dev->zones[edit_zone_idx].segments.push_back(new_segment);
-
-            start_idx += new_segment.leds_count;
-        }
-    }
-
-    return(ret_val);
-}
-
-void Ui::OpenRGBZoneResizeDialog::on_AddSegmentButton_clicked()
-{
-    /*---------------------------------------------------------*\
-    | Create new line in segments list tree                     |
-    \*---------------------------------------------------------*/
-    QTreeWidgetItem* new_item   = new QTreeWidgetItem(ui->SegmentsTreeWidget);
-
-    /*---------------------------------------------------------*\
-    | Create new widgets for line                               |
-    \*---------------------------------------------------------*/
-    QLineEdit* lineedit_name    = new QLineEdit(ui->SegmentsTreeWidget);
-    QLineEdit* lineedit_length  = new QLineEdit(ui->SegmentsTreeWidget);
-    QSlider*   slider_length    = new QSlider(Qt::Horizontal, ui->SegmentsTreeWidget);
-
-    /*---------------------------------------------------------*\
-    | Fill in new Name field as "Segment X"                     |
-    \*---------------------------------------------------------*/
-    std::string new_name        = "Segment ";
-
-    new_name.append(std::to_string(ui->SegmentsTreeWidget->topLevelItemCount() + 1));
-
-    lineedit_name->setText(new_name.c_str());
-
-    /*---------------------------------------------------------*\
-    | Restrict slider maximum to zone size                      |
-    \*---------------------------------------------------------*/
-    slider_length->setMaximum(edit_dev->zones[edit_zone_idx].leds_count);
-
-    /*---------------------------------------------------------*\
-    | Add new widgets to tree                                   |
-    \*---------------------------------------------------------*/
-    ui->SegmentsTreeWidget->setItemWidget(new_item, 0, lineedit_name);
-    ui->SegmentsTreeWidget->setItemWidget(new_item, 1, lineedit_length);
-    ui->SegmentsTreeWidget->setItemWidget(new_item, 2, slider_length);
-
-    /*---------------------------------------------------------*\
-    | Connect signals for handling slider and line edits        |
-    \*---------------------------------------------------------*/
-    connect(lineedit_name, &QLineEdit::textChanged, this, &OpenRGBZoneResizeDialog::on_segment_lineedit_textChanged);
-    connect(slider_length, &QSlider::valueChanged, this, &OpenRGBZoneResizeDialog::on_segment_slider_valueChanged);
-    connect(lineedit_length, &QLineEdit::textChanged, this, &OpenRGBZoneResizeDialog::on_segment_lineedit_textChanged);
-
-    CheckSegmentsValidity();
-}
-
-void Ui::OpenRGBZoneResizeDialog::CheckSegmentsValidity()
-{
-    bool segments_valid = true;
-
-    /*---------------------------------------------------------*\
-    | Only check validity if segments are configured            |
-    \*---------------------------------------------------------*/
-    if(ui->SegmentsTreeWidget->topLevelItemCount() != 0)
-    {
-        /*-----------------------------------------------------*\
-        | Verify all segments add up to zone size               |
-        \*-----------------------------------------------------*/
-        int total_segment_leds = 0;
-
-        for(int segment_idx = 0; segment_idx < ui->SegmentsTreeWidget->topLevelItemCount(); segment_idx++)
-        {
-            unsigned int segment_leds = ((QLineEdit*)ui->SegmentsTreeWidget->itemWidget(ui->SegmentsTreeWidget->topLevelItem(segment_idx), 1))->text().toInt();
-
-            /*-------------------------------------------------*\
-            | Zero-length segment is not allowed                |
-            \*-------------------------------------------------*/
-            if(segment_leds == 0)
-            {
-                segments_valid = false;
-            }
-
-            total_segment_leds += segment_leds;
-
-            /*-------------------------------------------------*\
-            | Empty name is not allowed                         |
-            \*-------------------------------------------------*/
-            if(((QLineEdit*)ui->SegmentsTreeWidget->itemWidget(ui->SegmentsTreeWidget->topLevelItem(segment_idx), 0))->text().isEmpty())
-            {
-                segments_valid = false;
-            }
-        }
-
-        if(total_segment_leds != ui->ResizeBox->value())
-        {
-            segments_valid = false;
-        }
-    }
-
-    ui->ButtonBox->setEnabled(segments_valid);
-}
-
-void Ui::OpenRGBZoneResizeDialog::on_RemoveSegmentButton_clicked()
-{
-    ui->SegmentsTreeWidget->takeTopLevelItem(ui->SegmentsTreeWidget->topLevelItemCount() - 1);
-
-    CheckSegmentsValidity();
-}
diff --git a/qt/OpenRGBZoneResizeDialog/OpenRGBZoneResizeDialog.h b/qt/OpenRGBZoneResizeDialog/OpenRGBZoneResizeDialog.h
deleted file mode 100644
index 065c666b..00000000
--- a/qt/OpenRGBZoneResizeDialog/OpenRGBZoneResizeDialog.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBZoneResizeDialog.h                                 |
-|                                                           |
-|   User interface for resizing zones                       |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QDialog>
-#include "ui_OpenRGBZoneResizeDialog.h"
-
-#include "RGBController.h"
-
-namespace Ui
-{
-    class OpenRGBZoneResizeDialog;
-}
-
-class Ui::OpenRGBZoneResizeDialog : public QDialog
-{
-    Q_OBJECT
-
-public:
-    explicit OpenRGBZoneResizeDialog(RGBController* edit_dev_ptr, unsigned int edit_zone_idx_val, QWidget *parent = nullptr);
-    explicit OpenRGBZoneResizeDialog(unsigned int edit_zone_min_val, unsigned int edit_zone_max_val, unsigned int edit_zone_current_val, QWidget *parent = nullptr);
-    ~OpenRGBZoneResizeDialog();
-
-    int show();
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_ResizeSlider_valueChanged(int value);
-
-    void on_ResizeBox_valueChanged(int arg1);
-
-    void on_AddSegmentButton_clicked();
-
-    void on_RemoveSegmentButton_clicked();
-
-    void on_segment_slider_valueChanged(int);
-
-    void on_segment_lineedit_textChanged();
-
-private:
-    Ui::OpenRGBZoneResizeDialogUi *ui;
-    RGBController* edit_dev;
-    unsigned int edit_zone_idx;
-
-    void CheckSegmentsValidity();
-};
diff --git a/qt/OpenRGBZoneResizeDialog/OpenRGBZoneResizeDialog.ui b/qt/OpenRGBZoneResizeDialog/OpenRGBZoneResizeDialog.ui
deleted file mode 100644
index 350a5ccc..00000000
--- a/qt/OpenRGBZoneResizeDialog/OpenRGBZoneResizeDialog.ui
+++ /dev/null
@@ -1,140 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBZoneResizeDialogUi</class>
- <widget class="QDialog" name="OpenRGBZoneResizeDialogUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>450</width>
-    <height>250</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Resize Zone</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout" columnstretch="1,0">
-   <item row="3" column="0" colspan="2">
-    <layout class="QHBoxLayout" name="horizontalLayout">
-     <item>
-      <widget class="QPushButton" name="AddSegmentButton">
-       <property name="text">
-        <string>Add Segment</string>
-       </property>
-      </widget>
-     </item>
-     <item>
-      <widget class="QPushButton" name="RemoveSegmentButton">
-       <property name="text">
-        <string>Remove Segment</string>
-       </property>
-      </widget>
-     </item>
-    </layout>
-   </item>
-   <item row="0" column="0">
-    <widget class="QTooltipedSlider" name="ResizeSlider">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
-       <horstretch>0</horstretch>
-       <verstretch>0</verstretch>
-      </sizepolicy>
-     </property>
-     <property name="orientation">
-      <enum>Qt::Horizontal</enum>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="0" colspan="2">
-    <widget class="QTreeWidget" name="SegmentsTreeWidget">
-     <property name="columnCount">
-      <number>3</number>
-     </property>
-     <column>
-      <property name="text">
-       <string notr="true">Name</string>
-      </property>
-     </column>
-     <column>
-      <property name="text">
-       <string>Length</string>
-      </property>
-     </column>
-     <column>
-      <property name="text">
-       <string> </string>
-      </property>
-     </column>
-    </widget>
-   </item>
-   <item row="4" column="0" colspan="2">
-    <widget class="QDialogButtonBox" name="ButtonBox">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
-       <horstretch>0</horstretch>
-       <verstretch>0</verstretch>
-      </sizepolicy>
-     </property>
-     <property name="orientation">
-      <enum>Qt::Horizontal</enum>
-     </property>
-     <property name="standardButtons">
-      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="1">
-    <widget class="QSpinBox" name="ResizeBox">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
-       <horstretch>0</horstretch>
-       <verstretch>0</verstretch>
-      </sizepolicy>
-     </property>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <customwidgets>
-  <customwidget>
-   <class>QTooltipedSlider</class>
-   <extends>QSlider</extends>
-   <header location="global">QTooltipedSlider.h</header>
-  </customwidget>
- </customwidgets>
- <resources/>
- <connections>
-  <connection>
-   <sender>ButtonBox</sender>
-   <signal>accepted()</signal>
-   <receiver>OpenRGBZoneResizeDialogUi</receiver>
-   <slot>accept()</slot>
-   <hints>
-    <hint type="sourcelabel">
-     <x>248</x>
-     <y>254</y>
-    </hint>
-    <hint type="destinationlabel">
-     <x>157</x>
-     <y>274</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>ButtonBox</sender>
-   <signal>rejected()</signal>
-   <receiver>OpenRGBZoneResizeDialogUi</receiver>
-   <slot>reject()</slot>
-   <hints>
-    <hint type="sourcelabel">
-     <x>316</x>
-     <y>260</y>
-    </hint>
-    <hint type="destinationlabel">
-     <x>286</x>
-     <y>274</y>
-    </hint>
-   </hints>
-  </connection>
- </connections>
-</ui>
diff --git a/qt/OpenRGBZonesBulkResizer/OpenRGBZonesBulkResizer.cpp b/qt/OpenRGBZonesBulkResizer/OpenRGBZonesBulkResizer.cpp
deleted file mode 100644
index 6fb7477e..00000000
--- a/qt/OpenRGBZonesBulkResizer/OpenRGBZonesBulkResizer.cpp
+++ /dev/null
@@ -1,239 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBZonesBulkResizer.cpp                               |
-|                                                           |
-|   User interface for bulk resizing zones                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QDialog>
-#include <QFile>
-#include "OpenRGBZonesBulkResizer.h"
-#include "ui_OpenRGBZonesBulkResizer.h"
-#include "ResourceManager.h"
-#include "SettingsManager.h"
-#include "LogManager.h"
-#include "OpenRGBDialog2.h"
-
-using namespace Ui;
-
-void OpenRGBZonesBulkResizer::RunChecks(QWidget *parent)
-{
-    /*---------------------------------------------------------*\
-    | Determine if we should run (user setting)                 |
-    \*---------------------------------------------------------*/
-    SettingsManager* settings_manager = ResourceManager::get()->GetSettingsManager();
-    json ui_settings = settings_manager->GetSettings("UserInterface");
-
-    if(!ui_settings.is_null() && ui_settings.contains("RunZoneChecks"))
-    {
-        json run_zone_checks = ui_settings["RunZoneChecks"];
-
-        if(!run_zone_checks.is_null() && run_zone_checks.is_boolean())
-        {
-            bool should_run = run_zone_checks;
-
-            if(!should_run)
-            {
-                LOG_DEBUG("Skipping zones sizes checks.");
-                return;
-            }
-        }
-    }
-
-    LOG_DEBUG("Running zones sizes checks...");
-
-    /*---------------------------------------------------------*\
-    | Collect the unconfigured zones                            |
-    \*---------------------------------------------------------*/
-    std::vector<RGBController*>& controllers = ResourceManager::get()->GetRGBControllers();
-
-    std::vector<std::tuple<RGBController*, unsigned int>> zones;
-
-    for(RGBController* controller: controllers)
-    {
-        for(unsigned int zone_index = 0; zone_index < controller->zones.size(); zone_index++)
-        {
-            // Consider unconfigured if 0 leds AND led_count < leds_max
-            if(controller->zones[zone_index].leds_count == 0
-                    && controller->zones[zone_index].leds_count < controller->zones[zone_index].leds_max)
-            {
-                zones.push_back({controller, zone_index});
-            }
-        }
-    }
-
-    LOG_DEBUG("Zones checks finished: %d unconfigured zone(s).", zones.size());
-
-    /*---------------------------------------------------------*\
-    | Show the configuration tool GUI if we have some           |
-    | unconfigured zones                                        |
-    \*---------------------------------------------------------*/
-    if(!zones.empty())
-    {
-        QDialog* dialog = new QDialog(parent);
-        dialog->setWindowTitle(tr("Resize the zones"));
-
-        dialog->setMinimumSize(600,480);
-        dialog->setModal(true);
-
-        QVBoxLayout* dialog_layout = new QVBoxLayout(dialog);
-
-        OpenRGBZonesBulkResizer* widget = new OpenRGBZonesBulkResizer(dialog, zones);
-
-        dialog_layout->addWidget(widget);
-
-        connect(widget, &OpenRGBZonesBulkResizer::CloseRequest, [=](){
-            dialog->reject();
-        });
-
-        dialog->exec();
-    }
-}
-
-OpenRGBZonesBulkResizer::OpenRGBZonesBulkResizer(QWidget *parent,  const std::vector<std::tuple<RGBController*, unsigned int>>& unconfigured_zones) :
-    QWidget(parent),
-    ui(new Ui::OpenRGBZonesBulkResizerUi),
-    unconfigured_zones(unconfigured_zones)
-{
-    ui->setupUi(this);
-
-    /*---------------------------------------------------------*\
-    | Set the table view settings (headers, resize behavior...) |
-    \*---------------------------------------------------------*/
-    ui->zones_table->setColumnCount(3);
-    ui->zones_table->verticalHeader()->setVisible(false);
-    ui->zones_table->setSelectionMode(QAbstractItemView::SelectionMode::NoSelection);
-    ui->zones_table->setSelectionBehavior(QAbstractItemView::SelectionBehavior::SelectRows);
-
-    ui->zones_table->horizontalHeader()->setSectionResizeMode(0, QHeaderView::Stretch);
-    ui->zones_table->horizontalHeader()->setSectionResizeMode(1, QHeaderView::Stretch);
-    ui->zones_table->horizontalHeader()->setSectionResizeMode(2, QHeaderView::Fixed);
-
-    ui->zones_table->setHorizontalHeaderLabels({tr("Controller"), tr("Zone"), tr("Size")});
-
-    /*---------------------------------------------------------*\
-    | Fill the table with widgets (labels, spinbox)             |
-    \*---------------------------------------------------------*/
-    for(const std::tuple<RGBController*, unsigned int>& tuple: unconfigured_zones)
-    {
-        CreateZoneWidget(std::get<0>(tuple), std::get<1>(tuple));
-    }
-}
-
-OpenRGBZonesBulkResizer::~OpenRGBZonesBulkResizer()
-{
-    delete ui;
-}
-
-void OpenRGBZonesBulkResizer::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        ui->retranslateUi(this);
-    }
-}
-
-void OpenRGBZonesBulkResizer::CreateZoneWidget(RGBController* controller, unsigned int zone_index)
-{
-    /*---------------------------------------------------------*\
-    | Labels: controller name + zone name                       |
-    \*---------------------------------------------------------*/
-    QLabel* controller_label = new QLabel(this);
-    controller_label->setText(QString::fromStdString(controller->name));
-
-    QLabel* zone_label = new QLabel(this);
-    zone_label->setText(QString::fromStdString(controller->zones[zone_index].name));
-
-    /*---------------------------------------------------------*\
-    | Spin box: controls the zone size                          |
-    \*---------------------------------------------------------*/
-    QSpinBox* spin_box = new QSpinBox(this);
-    spin_box->setValue(0);
-    spin_box->setMinimum(controller->zones[zone_index].leds_min);
-    spin_box->setMaximum(controller->zones[zone_index].leds_max);
-
-    /*---------------------------------------------------------*\
-    | Insert labels + spinbox                                   |
-    \*---------------------------------------------------------*/
-    int row = ui->zones_table->rowCount();
-
-    ui->zones_table->insertRow(row);
-    ui->zones_table->setCellWidget(row, 0, controller_label);
-    ui->zones_table->setCellWidget(row, 1, zone_label);
-    ui->zones_table->setCellWidget(row, 2, spin_box);
-}
-
-void OpenRGBZonesBulkResizer::on_save_button_clicked()
-{
-    bool has_changes = false;
-
-    /*---------------------------------------------------------*\
-    | Resize what needs to be resized                           |
-    \*---------------------------------------------------------*/
-    for(unsigned int i = 0; i < unconfigured_zones.size(); i++)
-    {
-        unsigned int new_size = ((QSpinBox*)ui->zones_table->cellWidget(i,2))->value();
-
-        if(new_size > 0)
-        {
-            RGBController* controller = std::get<0>(unconfigured_zones[i]);
-            unsigned int zone_index = std::get<1>(unconfigured_zones[i]);
-
-            controller->ResizeZone(zone_index, new_size);
-
-            has_changes = true;
-        }
-    }
-
-    /*---------------------------------------------------------*\
-    | Save the sizes if the user did any changes                |
-    \*---------------------------------------------------------*/
-    if(has_changes)
-    {
-        ProfileManager* profile_manager = ResourceManager::get()->GetProfileManager();
-
-        if(profile_manager != NULL)
-        {
-            /*---------------------------------------------------------*\
-            | Save the profile                                          |
-            \*---------------------------------------------------------*/
-            profile_manager->SaveProfile("sizes", true);
-        }
-    }
-
-    /*---------------------------------------------------------*\
-    | Save the "Do not show again" checkbox state, then close   |
-    \*---------------------------------------------------------*/
-    SaveDoNotRunState();
-
-    emit CloseRequest();
-}
-
-void OpenRGBZonesBulkResizer::on_ignore_button_clicked()
-{
-    /*---------------------------------------------------------*\
-    | Save the "Do not show again" checkbox state, then close   |
-    \*---------------------------------------------------------*/
-    SaveDoNotRunState();
-
-    emit CloseRequest();
-}
-
-void OpenRGBZonesBulkResizer::SaveDoNotRunState()
-{
-    /*---------------------------------------------------------*\
-    | Save the "Do not show again" checkbox state in            |
-    | settings manager                                          |
-    \*---------------------------------------------------------*/
-    SettingsManager* settings_manager = ResourceManager::get()->GetSettingsManager();
-    json ui_settings = settings_manager->GetSettings("UserInterface");
-
-    bool state = ui->do_not_show_again_checkbox->checkState() == Qt::Checked;
-
-    ui_settings["RunZoneChecks"] = !state;
-
-    settings_manager->SetSettings("UserInterface", ui_settings);
-    settings_manager->SaveSettings();
-}
diff --git a/qt/OpenRGBZonesBulkResizer/OpenRGBZonesBulkResizer.h b/qt/OpenRGBZonesBulkResizer/OpenRGBZonesBulkResizer.h
deleted file mode 100644
index 54ab468e..00000000
--- a/qt/OpenRGBZonesBulkResizer/OpenRGBZonesBulkResizer.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*---------------------------------------------------------*\
-| OpenRGBZonesBulkResizer.h                                 |
-|                                                           |
-|   User interface for bulk resizing zones                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QWidget>
-#include "ui_OpenRGBZonesBulkResizer.h"
-#include "RGBController.h"
-
-namespace Ui
-{
-    class OpenRGBZonesBulkResizer;
-}
-
-class Ui::OpenRGBZonesBulkResizer : public QWidget
-{
-    Q_OBJECT
-
-public:
-    static void RunChecks(QWidget *parent);
-
-    explicit OpenRGBZonesBulkResizer(QWidget*, const std::vector<std::tuple<RGBController*, unsigned int>>&);
-    ~OpenRGBZonesBulkResizer();
-
-private:
-    Ui::OpenRGBZonesBulkResizerUi *ui;
-
-    const std::vector<std::tuple<RGBController*, unsigned int>>& unconfigured_zones;
-
-    void CreateZoneWidget(RGBController*, unsigned int);
-
-    void SaveDoNotRunState();
-
-signals:
-    void CloseRequest();
-
-private slots:
-    void changeEvent(QEvent *event);
-    void on_save_button_clicked();
-    void on_ignore_button_clicked();
-
-};
diff --git a/qt/OpenRGBZonesBulkResizer/OpenRGBZonesBulkResizer.ui b/qt/OpenRGBZonesBulkResizer/OpenRGBZonesBulkResizer.ui
deleted file mode 100644
index bc1a154b..00000000
--- a/qt/OpenRGBZonesBulkResizer/OpenRGBZonesBulkResizer.ui
+++ /dev/null
@@ -1,114 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>OpenRGBZonesBulkResizerUi</class>
- <widget class="QWidget" name="OpenRGBZonesBulkResizerUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>800</width>
-    <height>500</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Zones resizer</string>
-  </property>
-  <layout class="QGridLayout" name="gridLayout">
-   <item row="3" column="0" colspan="2">
-    <spacer name="verticalSpacer">
-     <property name="orientation">
-      <enum>Qt::Vertical</enum>
-     </property>
-     <property name="sizeHint" stdset="0">
-      <size>
-       <width>20</width>
-       <height>40</height>
-      </size>
-     </property>
-    </spacer>
-   </item>
-   <item row="0" column="0" colspan="2">
-    <widget class="QLabel" name="help_label">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
-       <horstretch>1</horstretch>
-       <verstretch>1</verstretch>
-      </sizepolicy>
-     </property>
-     <property name="text">
-      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;One or more resizable zones have not been configured.  Resizable zones are most commonly used for addressable RGB headers where the size of the connected device cannot be detected automatically.&lt;/p&gt;&lt;p&gt;Please enter the number of LEDs in each zone below.&lt;/p&gt;&lt;p&gt;For more information about calcuating the correct size, please check &lt;a href=&quot;https://openrgb.org/resize.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;this link.&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
-     </property>
-     <property name="wordWrap">
-      <bool>true</bool>
-     </property>
-    </widget>
-   </item>
-   <item row="5" column="0" colspan="2">
-    <widget class="QCheckBox" name="do_not_show_again_checkbox">
-     <property name="text">
-      <string>Do not show again</string>
-     </property>
-    </widget>
-   </item>
-   <item row="4" column="1">
-    <widget class="QPushButton" name="save_button">
-     <property name="text">
-      <string>Save and close</string>
-     </property>
-    </widget>
-   </item>
-   <item row="2" column="0" colspan="2">
-    <widget class="QTableWidget" name="zones_table">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
-       <horstretch>100</horstretch>
-       <verstretch>100</verstretch>
-      </sizepolicy>
-     </property>
-     <property name="styleSheet">
-      <string notr="true"/>
-     </property>
-     <property name="frameShape">
-      <enum>QFrame::StyledPanel</enum>
-     </property>
-     <property name="frameShadow">
-      <enum>QFrame::Raised</enum>
-     </property>
-     <property name="showGrid">
-      <bool>false</bool>
-     </property>
-     <property name="gridStyle">
-      <enum>Qt::NoPen</enum>
-     </property>
-    </widget>
-   </item>
-   <item row="4" column="0">
-    <widget class="QPushButton" name="ignore_button">
-     <property name="text">
-      <string>Ignore</string>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="0" colspan="2">
-    <spacer name="verticalSpacer_2">
-     <property name="orientation">
-      <enum>Qt::Vertical</enum>
-     </property>
-     <property name="sizeHint" stdset="0">
-      <size>
-       <width>20</width>
-       <height>40</height>
-      </size>
-     </property>
-    </spacer>
-   </item>
-  </layout>
-  <zorder>do_not_show_again_checkbox</zorder>
-  <zorder>save_button</zorder>
-  <zorder>zones_table</zorder>
-  <zorder>ignore_button</zorder>
-  <zorder>help_label</zorder>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/QTooltipedSlider.cpp b/qt/QTooltipedSlider.cpp
deleted file mode 100644
index ad7117e4..00000000
--- a/qt/QTooltipedSlider.cpp
+++ /dev/null
@@ -1,19 +0,0 @@
-/*---------------------------------------------------------*\
-| QTooltipedSlider.cpp                                      |
-|                                                           |
-|   Qt widget for OpenRGB tooltiped slider                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QToolTip>
-#include "QTooltipedSlider.h"
-
-QTooltipedSlider::QTooltipedSlider(QWidget *parent) :
-    QSlider(parent)
-{
-    connect(this, &QSlider::sliderMoved,[&](int value) {
-        QToolTip::showText(QCursor::pos(), QString("%1").arg(value), nullptr);
-    });
-}
diff --git a/qt/QTooltipedSlider.h b/qt/QTooltipedSlider.h
deleted file mode 100644
index 6ae5e523..00000000
--- a/qt/QTooltipedSlider.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/*---------------------------------------------------------*\
-| QTooltipedSlider.h                                        |
-|                                                           |
-|   Qt widget for OpenRGB tooltiped slider                  |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QSlider>
-
-class QTooltipedSlider : public QSlider
-{
-    Q_OBJECT
-
-public:
-    explicit QTooltipedSlider(QWidget *parent = nullptr);
-};
diff --git a/qt/TabLabel.cpp b/qt/TabLabel.cpp
deleted file mode 100644
index 2e0c2813..00000000
--- a/qt/TabLabel.cpp
+++ /dev/null
@@ -1,51 +0,0 @@
-/*---------------------------------------------------------*\
-| TabLabel.cpp                                              |
-|                                                           |
-|   Qt widget for OpenRGB tab label                         |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QFontMetrics>
-#include "TabLabel.h"
-#include "OpenRGBFont.h"
-
-Ui::TabLabel::TabLabel(int icon, QString name, char* original, char* context) :
-    QWidget(nullptr),
-    ui(new Ui::TabLabelUi)
-{
-    ui->setupUi(this);
-
-    QFont font = OpenRGBFont::GetFont();
-    font.setPointSize(18);
-
-    ui->icon->setFont(font);
-    ui->icon->setText(OpenRGBFont::icon(icon));
-
-    ui->name->setText(name);
-
-    label   = original;
-    ctxt    = context;
-}
-
-Ui::TabLabel::~TabLabel()
-{
-    delete ui;
-}
-
-void Ui::TabLabel::changeEvent(QEvent *event)
-{
-    if(event->type() == QEvent::LanguageChange)
-    {
-        /*-----------------------------------------------------*\
-        | Storing the base string in label                      |
-        |   enables switching between multiple languages        |
-        | The context needs to be stored as the translation     |
-        |   file requires the originating context               |
-        \*-----------------------------------------------------*/
-        QApplication* app       = static_cast<QApplication *>(QApplication::instance());
-
-        ui->name->setText(app->translate(ctxt, label));
-    }
-}
diff --git a/qt/TabLabel.h b/qt/TabLabel.h
deleted file mode 100644
index 6ca8e868..00000000
--- a/qt/TabLabel.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*---------------------------------------------------------*\
-| TabLabel.h                                                |
-|                                                           |
-|   Qt widget for OpenRGB tab label                         |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QWidget>
-#include "ui_TabLabel.h"
-
-namespace Ui
-{
-    class TabLabel;
-}
-
-class Ui::TabLabel : public QWidget
-{
-    Q_OBJECT
-
-public:
-    TabLabel(int icon, QString name, char* original, char* context);
-    ~TabLabel();
-
-private:
-    Ui::TabLabelUi *ui;
-    char* label;
-    char* ctxt;
-
-private slots:
-    void changeEvent(QEvent *event);
-};
diff --git a/qt/TabLabel.ui b/qt/TabLabel.ui
deleted file mode 100644
index 01e6e558..00000000
--- a/qt/TabLabel.ui
+++ /dev/null
@@ -1,103 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>TabLabelUi</class>
- <widget class="QWidget" name="TabLabelUi">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>222</width>
-    <height>16</height>
-   </rect>
-  </property>
-  <property name="sizePolicy">
-   <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
-    <horstretch>0</horstretch>
-    <verstretch>0</verstretch>
-   </sizepolicy>
-  </property>
-  <property name="windowTitle">
-   <string>Tab Label</string>
-  </property>
-  <layout class="QHBoxLayout" name="horizontalLayout">
-   <property name="sizeConstraint">
-    <enum>QLayout::SetMinAndMaxSize</enum>
-   </property>
-   <property name="topMargin">
-    <number>0</number>
-   </property>
-   <property name="bottomMargin">
-    <number>0</number>
-   </property>
-   <item>
-    <spacer name="horizontalSpacer">
-     <property name="orientation">
-      <enum>Qt::Horizontal</enum>
-     </property>
-     <property name="sizeType">
-      <enum>QSizePolicy::Fixed</enum>
-     </property>
-     <property name="sizeHint" stdset="0">
-      <size>
-       <width>10</width>
-       <height>0</height>
-      </size>
-     </property>
-    </spacer>
-   </item>
-   <item>
-    <widget class="QLabel" name="icon">
-     <property name="text">
-      <string/>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <spacer name="horizontalSpacer_2">
-     <property name="orientation">
-      <enum>Qt::Horizontal</enum>
-     </property>
-     <property name="sizeType">
-      <enum>QSizePolicy::Fixed</enum>
-     </property>
-     <property name="sizeHint" stdset="0">
-      <size>
-       <width>10</width>
-       <height>0</height>
-      </size>
-     </property>
-    </spacer>
-   </item>
-   <item>
-    <widget class="QLabel" name="name">
-     <property name="sizePolicy">
-      <sizepolicy hsizetype="Fixed" vsizetype="Minimum">
-       <horstretch>0</horstretch>
-       <verstretch>0</verstretch>
-      </sizepolicy>
-     </property>
-     <property name="minimumSize">
-      <size>
-       <width>150</width>
-       <height>0</height>
-      </size>
-     </property>
-     <property name="maximumSize">
-      <size>
-       <width>150</width>
-       <height>16777215</height>
-      </size>
-     </property>
-     <property name="text">
-      <string>device name</string>
-     </property>
-     <property name="wordWrap">
-      <bool>true</bool>
-     </property>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>
diff --git a/qt/hsv.cpp b/qt/hsv.cpp
deleted file mode 100644
index aeaa9aba..00000000
--- a/qt/hsv.cpp
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
-* RGB <--> HSV conversion in integer arithmetics, to be used on Windows.
-* Copyright (c) 2013 Martin Mitas
-*
-* Permission is hereby granted, free of charge, to any person obtaining
-* a copy of this software and associated documentation files (the "Software"),
-* to deal in the Software without restriction, including without limitation
-* the rights to use, copy, modify, merge, publish, distribute, sublicense,
-* and/or sell copies of the Software, and to permit persons to whom the
-* Software is furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-* IN THE SOFTWARE.
-*/
-
-#include "hsv.h"
-
-
-#define MIN(a,b)      ((a) < (b) ? (a) : (b))
-#define MAX(a,b)      ((a) > (b) ? (a) : (b))
-
-#define MIN3(a,b,c)   MIN((a), MIN((b), (c)))
-#define MAX3(a,b,c)   MAX((a), MAX((b), (c)))
-
-#define RGBGetRValue(rgb)   (rgb & 0x000000FF)
-#define RGBGetGValue(rgb)   ((rgb >> 8) & 0x000000FF)
-#define RGBGetBValue(rgb)   ((rgb >> 16) & 0x000000FF)
-
-#define ToRGBColor(r, g, b) ((b << 16) | (g << 8) | (r))
-
-void rgb2hsv(unsigned int rgb, hsv_t* hsv)
-{
-    int r = RGBGetRValue(rgb);
-    int g = RGBGetGValue(rgb);
-    int b = RGBGetBValue(rgb);
-	int m = MIN3(r, g, b);
-	int M = MAX3(r, g, b);
-	int delta = M - m;
-
-	if (delta == 0) {
-		/* Achromatic case (i.e. grayscale) */
-		hsv->hue = -1;          /* undefined */
-		hsv->saturation = 0;
-	}
-	else {
-		int h;
-
-		if (r == M)
-			h = ((g - b) * 60 * HUE_DEGREE) / delta;
-		else if (g == M)
-			h = ((b - r) * 60 * HUE_DEGREE) / delta + 120 * HUE_DEGREE;
-		else /*if(b == M)*/
-			h = ((r - g) * 60 * HUE_DEGREE) / delta + 240 * HUE_DEGREE;
-
-		if (h < 0)
-			h += 360 * HUE_DEGREE;
-
-		hsv->hue = h;
-
-		/* The constatnt 8 is tuned to statistically cause as little
-		* tolerated mismatches as possible in RGB -> HSV -> RGB conversion.
-		* (See the unit test at the bottom of this file.)
-		*/
-		hsv->saturation = (256 * delta - 8) / M;
-	}
-	hsv->value = M;
-}
-
-unsigned int hsv2rgb(hsv_t* hsv)
-{
-    unsigned char r = 0;
-	unsigned char g = 0;
-	unsigned char b = 0;
-
-	if (hsv->saturation == 0) {
-		r = g = b = hsv->value;
-	}
-	else {
-		int h = (hsv->hue)%360;
-		int s = hsv->saturation;
-		int v = hsv->value;
-		int i = h / (60 * HUE_DEGREE);
-		int p = (256 * v - s*v) / 256;
-
-		if (i & 1) {
-			int q = (256 * 60 * HUE_DEGREE*v - h*s*v + 60 * HUE_DEGREE*s*v*i) / (256 * 60 * HUE_DEGREE);
-			switch (i) {
-			case 1:   r = q; g = v; b = p; break;
-			case 3:   r = p; g = q; b = v; break;
-			case 5:   r = v; g = p; b = q; break;
-			}
-		}
-		else {
-			int t = (256 * 60 * HUE_DEGREE*v + h*s*v - 60 * HUE_DEGREE*s*v*(i + 1)) / (256 * 60 * HUE_DEGREE);
-			switch (i) {
-			case 0:   r = v; g = t; b = p; break;
-			case 2:   r = p; g = v; b = t; break;
-			case 4:   r = t; g = p; b = v; break;
-			}
-		}
-	}
-
-    return ToRGBColor(r, g, b);
-}
-
-
-#ifdef TEST
-
-#include <stdio.h>
-
-#define DIFF(a,b)     ((a) >= (b) ? (a) - (b) : (b) - (a))
-
-int
-main(int argc, char** argv)
-{
-	int r0, g0, b0;
-	hsv_t hsv;
-	int r1, g1, b1;
-	int ok = 0, fuzzy = 0, ko = 0, total;
-
-	for (r0 = 0; r0 < 256; r0++) {
-		for (g0 = 0; g0 < 256; g0++) {
-			for (b0 = 0; b0 < 256; b0++) {
-				COLORREF tmp;
-
-				rgb2hsv(RGB(r0, g0, b0), &hsv);
-				tmp = hsv2rgb(&hsv);
-				r1 = GetRValue(tmp);
-				g1 = GetGValue(tmp);
-				b1 = GetBValue(tmp);
-
-				if (r0 == r1 && b0 == b1 && g0 == g1)
-					ok++;
-				else if (DIFF(r0, r1) <= 1 && DIFF(b0, b1) <= 1 && DIFF(g0, g1) <= 1)
-					fuzzy++;
-				else
-					ko++;
-			}
-		}
-	}
-
-	total = ok + fuzzy + ko;
-
-	printf("Test results:\n");
-	printf("  * exact matches: %8d (%5.2f%%)\n", ok, (100.0 * ok) / total);
-	printf("  * fuzzy matches: %8d (%5.2f%%)\n", fuzzy, (100.0 * fuzzy) / total);
-	printf("  * mismatches:    %8d (%5.2f%%)\n", ko, (100.0 * ko) / total);
-
-	return (ko == 0 ? 0 : 1);
-}
-#endif  /* TEST */
diff --git a/qt/hsv.h b/qt/hsv.h
deleted file mode 100644
index 3b8a85bd..00000000
--- a/qt/hsv.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
-* RGB <--> HSV conversion in integer arithmetics, to be used on Windows.
-* Copyright (c) 2013 Martin Mitas
-*
-* Permission is hereby granted, free of charge, to any person obtaining
-* a copy of this software and associated documentation files (the "Software"),
-* to deal in the Software without restriction, including without limitation
-* the rights to use, copy, modify, merge, publish, distribute, sublicense,
-* and/or sell copies of the Software, and to permit persons to whom the
-* Software is furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-* IN THE SOFTWARE.
-*/
-
-#ifndef HSV_H
-#define HSV_H
-
-#define HUE_DEGREE    1
-
-typedef struct hsv_tag hsv_t;
-struct hsv_tag {
-    unsigned int  hue;               /* 0 ... (360*HUE_DEGREE - 1) */
-    unsigned char saturation;       /* 0 ... 255 */
-    unsigned char value;            /* 0 ... 255 */
-};
-
-
-void rgb2hsv(unsigned int rgb, hsv_t* hsv);
-
-unsigned int hsv2rgb(hsv_t* hsv);
-
-
-#endif  /* HSV_H */
diff --git a/qt/macutils.h b/qt/macutils.h
deleted file mode 100644
index 8cdec335..00000000
--- a/qt/macutils.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/*---------------------------------------------------------*\
-| macutils.h                                                |
-|                                                           |
-|   Utility function for dockless mode in MacOS             |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#ifndef MACUTILS_H
-#define MACUTILS_H
-
-class MacUtils
-{
-public:
-    static void ToggleApplicationDocklessState(bool showDock);
-};
-
-#endif // MACUTILS_H
diff --git a/qt/macutils.mm b/qt/macutils.mm
deleted file mode 100644
index 11226d8a..00000000
--- a/qt/macutils.mm
+++ /dev/null
@@ -1,18 +0,0 @@
-/*---------------------------------------------------------*\
-| macutils.mm                                               |
-|                                                           |
-|   Utility function for dockless mode in MacOS             |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#import <Cocoa/Cocoa.h>
-#include "macutils.h"
-
-void MacUtils::ToggleApplicationDocklessState(bool showDock)
-{
-    ProcessApplicationTransformState transformState = showDock ? ProcessApplicationTransformState(kProcessTransformToForegroundApplication) : ProcessApplicationTransformState(kProcessTransformToUIElementApplication);
-    ProcessSerialNumber psn = { 0, kCurrentProcess };
-    TransformProcessType(&psn, transformState);
-}
diff --git a/qt/resources.qrc b/qt/resources.qrc
deleted file mode 100644
index d3363808..00000000
--- a/qt/resources.qrc
+++ /dev/null
@@ -1,7 +0,0 @@
-<RCC>
-    <qresource prefix="/">
-        <file>org.openrgb.OpenRGB.png</file>
-        <file>fonts/OpenRGB.ttf</file>
-        <file>OpenRGBGreyscale.png</file>
-    </qresource>
-</RCC>
diff --git a/qt/swatches.cpp b/qt/swatches.cpp
deleted file mode 100644
index b5b1f347..00000000
--- a/qt/swatches.cpp
+++ /dev/null
@@ -1,196 +0,0 @@
-/*---------------------------------------------------------*\
-| swatches.cpp                                              |
-|                                                           |
-|   Custom Colour Swatch widget that allows for adding user |
-|   colours                                                 |
-|                                                           |
-|   Chris M (Dr_No)                             23 Apr 2021 |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#include <QPainter>
-#include <QResizeEvent>
-#include <QStyleOption>
-#include "swatches.h"
-
-Swatches::Swatches(QWidget *parent) :
-    QWidget(parent),
-    initSize(width_inc_margin * minColumns, height_inc_margin * minRows)
-{
-    setBaseSize(initSize);
-    setSizeIncrement(width_inc_margin, height_inc_margin);
-    add_swatch.color.setRgb( 0, 0, 0, 0); //transparent
-
-    /*-----------------------------------------------------*\
-    | Add default swatches to the list                      |
-    \*-----------------------------------------------------*/
-    swatch black_swatch;
-    black_swatch.color.setRgb(0, 0, 0, 255);
-    swatch_list.push_back(black_swatch);
-
-    swatch red_swatch;
-    red_swatch.color.setRgb(255, 0, 0, 255);
-    swatch_list.push_back(red_swatch);
-
-    swatch yellow_swatch;
-    yellow_swatch.color.setRgb(255, 255, 0, 255);
-    swatch_list.push_back(yellow_swatch);
-
-    swatch green_swatch;
-    green_swatch.color.setRgb( 0, 255, 0, 255);
-    swatch_list.push_back(green_swatch);
-
-    swatch cyan_swatch;
-    cyan_swatch.color.setRgb( 0, 255, 255, 255);
-    swatch_list.push_back(cyan_swatch);
-
-    swatch blue_swatch;
-    blue_swatch.color.setRgb( 0, 0, 255, 255);
-    swatch_list.push_back(blue_swatch);
-
-    swatch magenta_swatch;
-    magenta_swatch.color.setRgb(255, 0, 255, 255);
-    swatch_list.push_back(magenta_swatch);
-
-    swatch white_swatch;
-    white_swatch.color.setRgb(255, 255, 255, 255);
-    swatch_list.push_back(white_swatch);
-
-    min_swatches = swatch_list.size();
-}
-
-QColor Swatches::color()
-{
-    return swatch_list[selected].color.toRgb();
-}
-
-QSize Swatches::sizeHint () const
-{
-    return QSize(width(), height());
-}
-
-QSize Swatches::minimumSizeHint () const
-{
-    return baseSize();
-}
-
-void Swatches::setCurrentColor(const QColor &color)
-{
-    if(color == picker_color)
-    {
-        return;
-    }
-
-    picker_color = color;
-}
-
-void Swatches::addCustomSwatch(const QColor &color)
-{
-    swatch new_swatch;
-    new_swatch.color = color;
-    swatch_list.push_back(new_swatch);
-    update();
-}
-
-void Swatches::resizeEvent(QResizeEvent *event)
-{
-    swatch_pixmap   = QPixmap(event->size());
-    swatch_pixmap.fill(Qt::transparent);
-    drawSwatches(event->size());
-    update();
-}
-
-void Swatches::mousePressEvent(QMouseEvent* /*event*/)
-{
-    mouseDown = true;
-}
-
-void Swatches::mouseReleaseEvent(QMouseEvent* event)
-{
-    if(!mouseDown)
-    {
-        return;
-    }
-
-    /*-----------------------------------------------------*\
-    | Clear mouse down and in-region flags                  |
-    \*-----------------------------------------------------*/
-    mouseDown   = false;
-
-    if(false)//add_swatch.region.contains(event->pos()))
-    {
-        addCustomSwatch(picker_color);
-    }
-    else
-    {
-        int swatch_count = swatch_list.size();
-        for(int i = 0; i < swatch_count; i++)
-        {
-            if(swatch_list[i].region.contains(event->pos()))
-            {
-                emit swatchChanged(swatch_list[i].color.toRgb());
-                break;
-            }
-        }
-    }
-}
-
-void Swatches::drawSwatches(const QSize &newSize)
-{
-    /*-----------------------------------------------------*\
-    | Create image canvas & paint background transparent    |
-    \*-----------------------------------------------------*/
-    swatch_image = QImage(newSize, QImage::Format_ARGB32_Premultiplied);
-    swatch_image.fill(Qt::transparent);
-
-    /*-----------------------------------------------------*\
-    | Set up painter                                        |
-    \*-----------------------------------------------------*/
-    QPainter painter(&swatch_image);
-    painter.setPen(border_pen);
-
-    /*-----------------------------------------------------*\
-    | Paint the swatch cluster                              |
-    \*-----------------------------------------------------*/
-    int width           = qMin(width_inc_margin, (newSize.width() / minColumns) - (margin * 2));
-    int height          = minSize;
-    width_inc_margin    = width + (margin * 2);
-    height_inc_margin   = height + (margin * 2);
-    int swatch_count    = swatch_list.size();
-
-    QPoint pointNewSwatch(margin, margin);
-    for(int i = 0; i < swatch_count; i++)
-    {
-        QBrush brush(swatch_list[i].color, Qt::SolidPattern);
-        swatch_list[i].region.setSize(QSize(width, height));
-        swatch_list[i].region.marginsAdded(QMargins(margin, margin, margin, margin));
-        swatch_list[i].region.moveTo(((i % minColumns) * width_inc_margin), ((i / minColumns) * height_inc_margin));
-
-        painter.setBrush(brush);
-        painter.drawRect(swatch_list[i].region);
-    }
-
-    //QBrush brush(add_swatch.color);
-    //add_swatch.region.setSize(QSize(width, height));
-    //add_swatch.region.marginsAdded(QMargins(margin, margin, margin, margin));
-    //add_swatch.region.moveTo(((swatch_count % minColumns) * width_inc_margin), ((swatch_count / minColumns) * height_inc_margin));
-
-    //painter.setBrush(brush);
-    //painter.drawRect(add_swatch.region);
-    //painter.drawText(add_swatch.region, Qt::AlignCenter, QString("+"));
-
-    swatch_pixmap = QPixmap().fromImage(swatch_image);
-}
-
-
-void Swatches::paintEvent(QPaintEvent *)
-{
-    QPainter painter(this);
-    QStyleOption opt;
-    opt.initFrom(this);
-    drawSwatches(this->size());             //This is the main draw function
-    painter.drawPixmap(0,0,swatch_pixmap);
-    style()->drawPrimitive(QStyle::PE_Widget, &opt, &painter, this);
-}
diff --git a/qt/swatches.h b/qt/swatches.h
deleted file mode 100644
index 421a851a..00000000
--- a/qt/swatches.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*---------------------------------------------------------*\
-| swatches.h                                                |
-|                                                           |
-|   Custom Colour Swatch widget that allows for adding user |
-|   colours                                                 |
-|                                                           |
-|   Chris M (Dr_No)                             23 Apr 2021 |
-|                                                           |
-|   This file is part of the OpenRGB project                |
-|   SPDX-License-Identifier: GPL-2.0-only                   |
-\*---------------------------------------------------------*/
-
-#pragma once
-
-#include <QWidget>
-#include <QVector>
-#include <QPen>
-
-class Swatches : public QWidget
-{
-    Q_OBJECT
-public:
-    explicit Swatches(QWidget *parent = nullptr);
-
-    virtual QSize   sizeHint () const;
-    virtual QSize   minimumSizeHint () const;
-    QColor          color();
-
-signals:
-    void            swatchChanged(const QColor color);
-    //void            customSwatches(const QVector<QColor> swatch);
-
-public slots:
-    void            addCustomSwatch(const QColor &color);
-    //void            addCustomSwatches(const QVector<QColor> &swatch);
-    void            setCurrentColor(const QColor &color);
-
-protected:
-    void            mousePressEvent(QMouseEvent *event);
-    void            mouseReleaseEvent(QMouseEvent *);
-    void            resizeEvent(QResizeEvent *event);
-    void            paintEvent(QPaintEvent *);
-
-private:
-    const int       minSize             = 20;
-    const int       minRows             = 1;
-    const int       minColumns          = 8;
-    const int       margin              = 2;
-    const float     corner_radius       = 0.0f;
-    bool            mouseDown           = false;
-    int             selected            = 0;
-    int             width_inc_margin    = minSize + (margin * 2);
-    int             height_inc_margin   = minSize + (margin * 2);
-    int             min_swatches;
-
-    struct swatch
-    {
-        QColor      color           = QColor(0, 0, 0);
-        QRect       region          = QRect(0, 0, 25, 25);
-    };
-
-    swatch          add_swatch;
-    QPen            border_pen      = QColor(128,128,128);  //Grey50
-    QVector<swatch> swatch_list;
-    QColor          picker_color;
-    QSize           initSize;
-    QPixmap         swatch_pixmap;
-    QImage          swatch_image;
-
-    void            drawSwatches(const QSize &newSize);
-};
diff --git a/scsiapi/scsiapi_linux.c b/scsiapi/scsiapi_linux.c
index cd226104..835c76b6 100644
--- a/scsiapi/scsiapi_linux.c
+++ b/scsiapi/scsiapi_linux.c
@@ -81,7 +81,7 @@ struct scsi_device_info * scsi_enumerate(const char * vendor, const char * produ
         /*-------------------------------------------------*\
         | Read the model string and close the model file    |
         \*-------------------------------------------------*/
-        read(sg_model_fd, sg_model_buf, 512);
+        ssize_t ret1 = read(sg_model_fd, sg_model_buf, 512);
         close(sg_model_fd);
 
         for(unsigned int i = 0; i < strlen(sg_model_buf); i++)
@@ -96,7 +96,7 @@ struct scsi_device_info * scsi_enumerate(const char * vendor, const char * produ
         /*-------------------------------------------------*\
         | Read the vendor string and close the vendor file  |
         \*-------------------------------------------------*/
-        read(sg_vendor_fd, sg_vendor_buf, 512);
+        ssize_t ret2 = read(sg_vendor_fd, sg_vendor_buf, 512);
         close(sg_vendor_fd);
 
         for(unsigned int i = 0; i < strlen(sg_vendor_buf); i++)
